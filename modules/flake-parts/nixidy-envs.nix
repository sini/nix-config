{
  config,
  inputs,
  lib,
  withSystem,
  ...
}:
let
  inherit (config.flake.meta) repo;
in
{
  flake = flakeOpts: {
    nixidyEnvs = lib.genAttrs config.systems (
      system:
      (withSystem system (
        { pkgs, ... }:
        (lib.mapAttrs (
          env: environment:
          let
            # Collect nixidy modules from services defined in environment
            enabledServices = lib.attrNames (environment.kubernetes.services or { });
            serviceModules = lib.map (serviceName: flakeOpts.config.kubernetes.services.${serviceName}.nixidy) (
              lib.filter (serviceName: flakeOpts.config.kubernetes.services ? ${serviceName}) enabledServices
            );
          in
          inputs.nixidy.lib.mkEnv {
            inherit pkgs;
            charts = inputs.nixhelm.chartsDerivations.${system};
            extraSpecialArgs = {
              inherit environment;
              hosts = flakeOpts.config.hosts;
            };
            modules = [
              (
                { lib, ... }:
                {
                  # Define kubernetes.services with freeform submodule
                  # This allows both arbitrary attributes AND typed option declarations
                  options.kubernetes.services = lib.mkOption {
                    type = lib.types.submodule {
                      freeformType = lib.types.attrsOf lib.types.attrs;
                      options = { }; # Service modules can add typed options here
                    };
                    default = { };
                    description = "Kubernetes service configurations";
                  };

                  # Inject environment service configs
                  config = {
                    kubernetes.services = environment.kubernetes.services or { };

                    nixidy = {
                      env = lib.mkDefault env;
                      resourceImports =
                        let
                          crdsDir = ../../kubernetes/generated/crds;
                          nixFiles = lib.attrNames (
                            lib.filterAttrs (name: type: type == "regular" && lib.hasSuffix ".nix" name) (
                              builtins.readDir crdsDir
                            )
                          );
                        in
                        map (name: crdsDir + "/${name}") nixFiles;

                      target = {
                        repository = lib.mkDefault "https://github.com/${repo.owner}/${repo.name}.git";
                        branch = lib.mkDefault "main";
                        rootPath = lib.mkDefault "./kubernetes/generated/manifests/${env}";
                      };

                      bootstrapManifest.enable = true;

                      extraFiles."README.md".text = ''
                        # Rendered manifests

                        The manifests in this directory are generated by [nixidy](https://github.com/arnarg/nixidy).
                      '';

                      defaults = {
                        syncPolicy = {
                          autoSync = {
                            enabled = true;
                            prune = true;
                            selfHeal = true;
                          };
                        };

                        # Many helm chars will render all resources with the
                        # following labels.
                        # This produces huge diffs when the charts are updated
                        # because the values of these labels change each release.
                        # Here we add a transformer that strips them out after
                        # templating the helm charts in each application.
                        helm.transformer = map (
                          lib.kube.removeLabels [
                            "app.kubernetes.io/managed-by"
                            "app.kubernetes.io/version"
                            "helm.sh/chart"
                          ]
                        );
                      };
                    };
                  };
                }
              )
            ]
            # Import service modules for services defined in environment
            ++ serviceModules
            ++ [
              ../../kubernetes/envs/${env}
            ];
          }
        ) flakeOpts.config.environments)
      ))
    );
  };

  perSystem =
    {
      inputs',
      pkgs,
      system,
      ...
    }:
    let
      crds = import ../../kubernetes/crds {
        inherit
          inputs
          system
          pkgs
          lib
          ;
      };
    in
    {
      imports = [ crds ];

      devshells.default.packages = [ inputs'.nixidy.packages.default ];
      devshells.default.commands = [
        {
          package = inputs'.nixidy.packages.default;
          help = "Manage kubernetes cluster deployment configuration";
        }
        {
          package = crds.packages.generate-crds;
          help = "Generate CRDs";
        }
      ];
    };
}
