{
  config,
  inputs,
  lib,
  withSystem,
  ...
}:
let
  inherit (config.flake.meta) repo;
  inherit (config.flake.lib.kubernetes-services) nixidyKubernetesType;
in
{
  flake = {
    nixidyEnvs = lib.genAttrs config.systems (
      system:
      (withSystem system (
        { pkgs, ... }:
        (lib.mapAttrs (
          env: environment:
          let
            # Collect nixidy modules from services enabled in environment
            enabledServices = environment.kubernetes.services.enabled or [ ];
            serviceModules = lib.map (serviceName: config.flake.kubernetes.services.${serviceName}.nixidy) (
              lib.filter (serviceName: config.flake.kubernetes.services ? ${serviceName}) enabledServices
            );
          in
          inputs.nixidy.lib.mkEnv {
            inherit pkgs;
            charts = inputs.nixhelm.chartsDerivations.${system};
            extraSpecialArgs = {
              inherit environment;
              hosts = config.flake.hosts;
              secrets = lib.kubernetes-secrets.mkSecretHelpers environment;
            };
            modules = [
              (
                { lib, ... }:

                {
                  # Use flattened nixidy type for direct service access
                  options.kubernetes = lib.mkOption {
                    type = nixidyKubernetesType;
                    default = { };
                    description = "Kubernetes configuration for this nixidy environment";
                  };

                  # Add computed option for secret helpers
                  options.secrets = lib.mkOption {
                    type = lib.types.attrs;
                    readOnly = true;
                    internal = true;
                    description = "Secret helper functions (computed from kubernetes.secretsFile)";
                  };

                  # Inject environment kubernetes config with flattened services structure
                  config = {
                    kubernetes = lib.mkAliasDefinitions (
                      environment.kubernetes
                      // {
                        # Flatten services: move services.config to services for cleaner nixidy access
                        services = environment.kubernetes.services.config or { };
                      }
                    );
                    secrets = lib.kubernetes-secrets.mkSecretHelpers environment;

                    nixidy = {
                      env = lib.mkDefault env;
                      resourceImports =
                        let
                          crdsDir = ../../kubernetes/generated/crds;
                          nixFiles = lib.attrNames (
                            lib.filterAttrs (
                              name: type: type == "regular" && lib.hasSuffix ".nix" name
                              # && (lib.elem (lib.removeSuffix ".nix" name) enabledServices)
                            ) (builtins.readDir crdsDir)
                          );
                        in
                        map (name: crdsDir + "/${name}") nixFiles;

                      target = {
                        repository = lib.mkDefault "https://github.com/${repo.owner}/${repo.name}.git";
                        branch = lib.mkDefault "main";
                        rootPath = lib.mkDefault "./kubernetes/generated/manifests/${env}";
                      };

                      bootstrapManifest.enable = true;

                      extraFiles."README.md".text = ''
                        # Rendered manifests

                        The manifests in this directory are generated by [nixidy](https://github.com/arnarg/nixidy).
                      '';

                      defaults = {
                        syncPolicy = {
                          autoSync = {
                            enabled = true;
                            prune = true;
                            selfHeal = true;
                          };
                        };

                        # Many helm chars will render all resources with the
                        # following labels.
                        # This produces huge diffs when the charts are updated
                        # because the values of these labels change each release.
                        # Here we add a transformer that strips them out after
                        # templating the helm charts in each application.
                        helm.transformer = map (
                          lib.kube.removeLabels [
                            "app.kubernetes.io/managed-by"
                            "app.kubernetes.io/version"
                            "helm.sh/chart"
                          ]
                        );
                      };
                    };
                  };
                }
              )
            ]
            # Import service modules for services defined in environment
            ++ serviceModules
            ++ [
              ../../kubernetes/envs/${env}
            ];
          }
        ) config.flake.environments)
      ))
    );
  };

  perSystem =
    {
      inputs',
      pkgs,
      ...
    }@sharedConfig:
    {

      devshells.default.packages = [ inputs'.nixidy.packages.default ];
      devshells.default.commands = [
        {
          package = inputs'.nixidy.packages.default;
          # help = "Manage kubernetes cluster deployment configuration";
          help = "[DEPRECATED] - use k8s-update-manifests instead as it has secret wrapping";
        }
        {
          package =
            let
              gFiles = builtins.attrNames (builtins.readDir ../../kubernetes/crds);
              generatorFiles = builtins.filter (
                file: builtins.match ".*\\.nix" file != null && file != "default.nix"
              ) gFiles;
              generators = builtins.listToAttrs (
                map (file: {
                  name = builtins.replaceStrings [ ".nix" ] [ "" ] file;
                  value = import (../../kubernetes/crds + "/${file}") (
                    sharedConfig
                    // {
                      inherit inputs;
                    }
                  );
                }) generatorFiles
              );
            in
            pkgs.writeShellScriptBin "generate-crds" ''
              set -eo pipefail

              echo "Generating CRDs..."

              ${lib.concatMapStringsSep "\n" (name: ''
                echo "generate ${name}"
                cat ${generators.${name}} > kubernetes/generated/crds/${name}.nix
              '') (lib.attrNames generators)}
            '';
          help = "Generate CRDs";
        }
      ];
    };
}
