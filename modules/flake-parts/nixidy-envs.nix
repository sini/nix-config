{
  rootPath,
  config,
  inputs,
  lib,
  withSystem,
  ...
}:
let
  inherit (config.flake.meta) repo;
in
{
  flake = flakeOpts: {
    nixidyEnvs = lib.genAttrs config.systems (
      system:
      (withSystem system (
        { pkgs, ... }:
        (lib.mapAttrs (
          env: environment:
          let
            # Collect nixidy modules from services defined in environment
            enabledServices = lib.attrNames (environment.kubernetes.services or { });
            serviceModules = lib.map (serviceName: flakeOpts.config.kubernetes.services.${serviceName}.nixidy) (
              lib.filter (serviceName: flakeOpts.config.kubernetes.services ? ${serviceName}) enabledServices
            );
          in
          inputs.nixidy.lib.mkEnv {
            inherit pkgs;
            charts = inputs.nixhelm.chartsDerivations.${system};
            extraSpecialArgs = {
              inherit environment;
              hosts = flakeOpts.config.hosts;
            };
            modules = [
              (
                { lib, ... }:
                let
                  inherit (flakeOpts.config.lib.modules) kubernetesConfigType;
                  k3sSopsAgeKey = lib.removeSuffix "\n" (
                    builtins.readFile (rootPath + "/.secrets/env/${env}/k3s-sops-age-key.pub")
                  );

                  # We auto encrypt kube secrets for any GPG public keys in .secrets/pub
                  pgpKeyFiles = lib.attrNames (
                    lib.filterAttrs (name: type: type == "regular" && lib.hasSuffix ".asc" name) (
                      builtins.readDir (rootPath + "/.secrets/pub/")
                    )
                  );
                  pgpPublicKeys = map (name: rootPath + "/.secrets/pub/${name}") pgpKeyFiles;
                  pgpRecipients = map (name: lib.head (lib.splitString "-" name)) pgpKeyFiles;

                in
                {
                  # Use shared kubernetesConfigType which includes ageRecipients, network options, and services
                  options.kubernetes = lib.mkOption {
                    type = kubernetesConfigType;
                    default = { };
                    description = "Kubernetes configuration for this nixidy environment";
                  };

                  # Inject environment kubernetes config
                  config = {
                    kubernetes = environment.kubernetes or { } // {
                      ageRecipients = [ k3sSopsAgeKey ];
                      inherit pgpPublicKeys pgpRecipients;
                    };

                    nixidy = {
                      env = lib.mkDefault env;
                      resourceImports =
                        let
                          crdsDir = ../../kubernetes/generated/crds;
                          nixFiles = lib.attrNames (
                            lib.filterAttrs (
                              name: type: type == "regular" && lib.hasSuffix ".nix" name
                              # && (lib.elem (lib.removeSuffix ".nix" name) enabledServices)
                            ) (builtins.readDir crdsDir)
                          );
                        in
                        map (name: crdsDir + "/${name}") nixFiles;

                      target = {
                        repository = lib.mkDefault "https://github.com/${repo.owner}/${repo.name}.git";
                        branch = lib.mkDefault "main";
                        rootPath = lib.mkDefault "./kubernetes/generated/manifests/${env}";
                      };

                      bootstrapManifest.enable = true;

                      extraFiles."README.md".text = ''
                        # Rendered manifests

                        The manifests in this directory are generated by [nixidy](https://github.com/arnarg/nixidy).
                      '';

                      defaults = {
                        syncPolicy = {
                          autoSync = {
                            enabled = true;
                            prune = true;
                            selfHeal = true;
                          };
                        };

                        # Many helm chars will render all resources with the
                        # following labels.
                        # This produces huge diffs when the charts are updated
                        # because the values of these labels change each release.
                        # Here we add a transformer that strips them out after
                        # templating the helm charts in each application.
                        helm.transformer = map (
                          lib.kube.removeLabels [
                            "app.kubernetes.io/managed-by"
                            "app.kubernetes.io/version"
                            "helm.sh/chart"
                          ]
                        );
                      };
                    };
                  };
                }
              )
            ]
            # Import service modules for services defined in environment
            ++ serviceModules
            ++ [
              ../../kubernetes/envs/${env}
            ];
          }
        ) flakeOpts.config.environments)
      ))
    );
  };

  perSystem =
    {
      inputs',
      pkgs,
      ...
    }@sharedConfig:
    {
      devshells.default.packages = [ inputs'.nixidy.packages.default ];
      devshells.default.commands = [
        {
          package = inputs'.nixidy.packages.default;
          help = "Manage kubernetes cluster deployment configuration";
        }
        {
          package =
            let
              gFiles = builtins.attrNames (builtins.readDir ../../kubernetes/crds);
              generatorFiles = builtins.filter (
                file: builtins.match ".*\\.nix" file != null && file != "default.nix"
              ) gFiles;
              generators = builtins.listToAttrs (
                map (file: {
                  name = builtins.replaceStrings [ ".nix" ] [ "" ] file;
                  value = import (../../kubernetes/crds + "/${file}") (
                    sharedConfig
                    // {
                      inherit inputs;
                    }
                  );
                }) generatorFiles
              );
            in
            pkgs.writeShellScriptBin "generate-crds" ''
              set -eo pipefail

              echo "Generating CRDs..."

              ${lib.concatMapStringsSep "\n" (name: ''
                echo "generate ${name}"
                cat ${generators.${name}} > kubernetes/generated/crds/${name}.nix
              '') (lib.attrNames generators)}
            '';
          help = "Generate CRDs";
        }
      ];
    };
}
