# This file was generated with nixidy resource generator, do not edit.
{
  lib,
  options,
  config,
  ...
}:

with lib;

let
  hasAttrNotNull = attr: set: hasAttr attr set && set.${attr} != null;

  attrsToList =
    values:
    if values != null then
      sort (
        a: b:
        if (hasAttrNotNull "_priority" a && hasAttrNotNull "_priority" b) then
          a._priority < b._priority
        else
          false
      ) (mapAttrsToList (n: v: v) values)
    else
      values;

  getDefaults =
    resource: group: version: kind:
    catAttrs "default" (
      filter (
        default:
        (default.resource == null || default.resource == resource)
        && (default.group == null || default.group == group)
        && (default.version == null || default.version == version)
        && (default.kind == null || default.kind == kind)
      ) config.defaults
    );

  types = lib.types // rec {
    str = mkOptionType {
      name = "str";
      description = "string";
      check = isString;
      merge = mergeEqualOption;
    };

    # Either value of type `finalType` or `coercedType`, the latter is
    # converted to `finalType` using `coerceFunc`.
    coercedTo =
      coercedType: coerceFunc: finalType:
      mkOptionType rec {
        inherit (finalType) getSubOptions getSubModules;

        name = "coercedTo";
        description = "${finalType.description} or ${coercedType.description}";
        check = x: finalType.check x || coercedType.check x;
        merge =
          loc: defs:
          let
            coerceVal =
              val:
              if finalType.check val then
                val
              else
                let
                  coerced = coerceFunc val;
                in
                assert finalType.check coerced;
                coerced;

          in
          finalType.merge loc (map (def: def // { value = coerceVal def.value; }) defs);
        substSubModules = m: coercedTo coercedType coerceFunc (finalType.substSubModules m);
        typeMerge = t1: t2: null;
        functor = (defaultFunctor name) // {
          wrapped = finalType;
        };
      };
  };

  mkOptionDefault = mkOverride 1001;

  mergeValuesByKey =
    attrMergeKey: listMergeKeys: values:
    listToAttrs (
      imap0 (
        i: value:
        nameValuePair (
          if hasAttr attrMergeKey value then
            if isAttrs value.${attrMergeKey} then
              toString value.${attrMergeKey}.content
            else
              (toString value.${attrMergeKey})
          else
            # generate merge key for list elements if it's not present
            "__kubenix_list_merge_key_"
            + (concatStringsSep "" (
              map (
                key: if isAttrs value.${key} then toString value.${key}.content else (toString value.${key})
              ) listMergeKeys
            ))
        ) (value // { _priority = i; })
      ) values
    );

  submoduleOf =
    ref:
    types.submodule (
      { name, ... }:
      {
        options = definitions."${ref}".options or { };
        config = definitions."${ref}".config or { };
      }
    );

  globalSubmoduleOf =
    ref:
    types.submodule (
      { name, ... }:
      {
        options = config.definitions."${ref}".options or { };
        config = config.definitions."${ref}".config or { };
      }
    );

  submoduleWithMergeOf =
    ref: mergeKey:
    types.submodule (
      { name, ... }:
      let
        convertName =
          name: if definitions."${ref}".options.${mergeKey}.type == types.int then toInt name else name;
      in
      {
        options = definitions."${ref}".options // {
          # position in original array
          _priority = mkOption {
            type = types.nullOr types.int;
            default = null;
            internal = true;
          };
        };
        config = definitions."${ref}".config // {
          ${mergeKey} = mkOverride 1002 (
            # use name as mergeKey only if it is not coming from mergeValuesByKey
            if (!hasPrefix "__kubenix_list_merge_key_" name) then convertName name else null
          );
        };
      }
    );

  submoduleForDefinition =
    ref: resource: kind: group: version:
    let
      apiVersion = if group == "core" then version else "${group}/${version}";
    in
    types.submodule (
      { name, ... }:
      {
        inherit (definitions."${ref}") options;

        imports = getDefaults resource group version kind;
        config = mkMerge [
          definitions."${ref}".config
          {
            kind = mkOptionDefault kind;
            apiVersion = mkOptionDefault apiVersion;

            # metdata.name cannot use option default, due deep config
            metadata.name = mkOptionDefault name;
          }
        ];
      }
    );

  coerceAttrsOfSubmodulesToListByKey =
    ref: attrMergeKey: listMergeKeys:
    (types.coercedTo (types.listOf (submoduleOf ref)) (mergeValuesByKey attrMergeKey listMergeKeys) (
      types.attrsOf (submoduleWithMergeOf ref attrMergeKey)
    ));

  definitions = {
    "gateway.envoyproxy.io.v1alpha1.Backend" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "Spec defines the desired state of Backend.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendSpec");
        };
        "status" = mkOption {
          description = "Status defines the current status of Backend.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendSpec" = {

      options = {
        "appProtocols" = mkOption {
          description = "AppProtocols defines the application protocols to be supported when connecting to the backend.";
          type = (types.nullOr (types.listOf types.str));
        };
        "endpoints" = mkOption {
          description = "Endpoints defines the endpoints to be used when connecting to the backend.";
          type = (
            types.nullOr (types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendSpecEndpoints"))
          );
        };
        "fallback" = mkOption {
          description = "Fallback indicates whether the backend is designated as a fallback.\nIt is highly recommended to configure active or passive health checks to ensure that failover can be detected\nwhen the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.\nThe overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when\nthe health of the active backends falls below 72%.";
          type = (types.nullOr types.bool);
        };
        "tls" = mkOption {
          description = "TLS defines the TLS settings for the backend.\nIf TLS is specified here and a BackendTLSPolicy is also configured for the backend, the final TLS settings will\nbe a merge of both configurations. In case of overlapping fields, the values defined in the BackendTLSPolicy will\ntake precedence.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendSpecTls"));
        };
        "type" = mkOption {
          description = "Type defines the type of the backend. Defaults to \"Endpoints\"";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "appProtocols" = mkOverride 1002 null;
        "endpoints" = mkOverride 1002 null;
        "fallback" = mkOverride 1002 null;
        "tls" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendSpecEndpoints" = {

      options = {
        "fqdn" = mkOption {
          description = "FQDN defines a FQDN endpoint";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendSpecEndpointsFqdn"));
        };
        "hostname" = mkOption {
          description = "Hostname defines an optional hostname for the backend endpoint.";
          type = (types.nullOr types.str);
        };
        "ip" = mkOption {
          description = "IP defines an IP endpoint. Supports both IPv4 and IPv6 addresses.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendSpecEndpointsIp"));
        };
        "unix" = mkOption {
          description = "Unix defines the unix domain socket endpoint";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendSpecEndpointsUnix"));
        };
        "zone" = mkOption {
          description = "Zone defines the service zone of the backend endpoint.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "fqdn" = mkOverride 1002 null;
        "hostname" = mkOverride 1002 null;
        "ip" = mkOverride 1002 null;
        "unix" = mkOverride 1002 null;
        "zone" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendSpecEndpointsFqdn" = {

      options = {
        "hostname" = mkOption {
          description = "Hostname defines the FQDN hostname of the backend endpoint.";
          type = types.str;
        };
        "port" = mkOption {
          description = "Port defines the port of the backend endpoint.";
          type = types.int;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendSpecEndpointsIp" = {

      options = {
        "address" = mkOption {
          description = "Address defines the IP address of the backend endpoint.\nSupports both IPv4 and IPv6 addresses.";
          type = types.str;
        };
        "port" = mkOption {
          description = "Port defines the port of the backend endpoint.";
          type = types.int;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendSpecEndpointsUnix" = {

      options = {
        "path" = mkOption {
          description = "Path defines the unix domain socket path of the backend endpoint.\nThe path length must not exceed 108 characters.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendSpecTls" = {

      options = {
        "alpnProtocols" = mkOption {
          description = "ALPNProtocols supplies the list of ALPN protocols that should be\nexposed by the listener or used by the proxy to connect to the backend.\nDefaults:\n1. HTTPS Routes: h2 and http/1.1 are enabled in listener context.\n2. Other Routes: ALPN is disabled.\n3. Backends: proxy uses the appropriate ALPN options for the backend protocol.\nWhen an empty list is provided, the ALPN TLS extension is disabled.\n\nDefaults to [h2, http/1.1] if not specified.\n\nTypical Supported values are:\n- http/1.0\n- http/1.1\n- h2";
          type = (types.nullOr (types.listOf types.str));
        };
        "caCertificateRefs" = mkOption {
          description = "CACertificateRefs contains one or more references to Kubernetes objects that\ncontain TLS certificates of the Certificate Authorities that can be used\nas a trust anchor to validate the certificates presented by the backend.\n\nA single reference to a Kubernetes ConfigMap or a Kubernetes Secret,\nwith the CA certificate in a key named `ca.crt` is currently supported.\n\nIf CACertificateRefs is empty or unspecified, then WellKnownCACertificates must be\nspecified. Only one of CACertificateRefs or WellKnownCACertificates may be specified,\nnot both.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "gateway.envoyproxy.io.v1alpha1.BackendSpecTlsCaCertificateRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "ciphers" = mkOption {
          description = "Ciphers specifies the set of cipher suites supported when\nnegotiating TLS 1.0 - 1.2. This setting has no effect for TLS 1.3.\nIn non-FIPS Envoy Proxy builds the default cipher list is:\n- [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]\n- [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]\n- ECDHE-ECDSA-AES256-GCM-SHA384\n- ECDHE-RSA-AES256-GCM-SHA384\nIn builds using BoringSSL FIPS the default cipher list is:\n- ECDHE-ECDSA-AES128-GCM-SHA256\n- ECDHE-RSA-AES128-GCM-SHA256\n- ECDHE-ECDSA-AES256-GCM-SHA384\n- ECDHE-RSA-AES256-GCM-SHA384";
          type = (types.nullOr (types.listOf types.str));
        };
        "clientCertificateRef" = mkOption {
          description = "ClientCertificateRef defines the reference to a Kubernetes Secret that contains\nthe client certificate and private key for Envoy to use when connecting to\nbackend services and external services, such as ExtAuth, ALS, OpenTelemetry, etc.\nThis secret should be located within the same namespace as the Envoy proxy resource that references it.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendSpecTlsClientCertificateRef")
          );
        };
        "ecdhCurves" = mkOption {
          description = "ECDHCurves specifies the set of supported ECDH curves.\nIn non-FIPS Envoy Proxy builds the default curves are:\n- X25519\n- P-256\nIn builds using BoringSSL FIPS the default curve is:\n- P-256";
          type = (types.nullOr (types.listOf types.str));
        };
        "insecureSkipVerify" = mkOption {
          description = "InsecureSkipVerify indicates whether the upstream's certificate verification\nshould be skipped. Defaults to \"false\".";
          type = (types.nullOr types.bool);
        };
        "maxVersion" = mkOption {
          description = "Max specifies the maximal TLS protocol version to allow\nThe default is TLS 1.3 if this is not specified.";
          type = (types.nullOr types.str);
        };
        "minVersion" = mkOption {
          description = "Min specifies the minimal TLS protocol version to allow.\nThe default is TLS 1.2 if this is not specified.";
          type = (types.nullOr types.str);
        };
        "signatureAlgorithms" = mkOption {
          description = "SignatureAlgorithms specifies which signature algorithms the listener should\nsupport.";
          type = (types.nullOr (types.listOf types.str));
        };
        "sni" = mkOption {
          description = "SNI is specifies the SNI value used when establishing an upstream TLS connection to the backend.\n\nEnvoy Gateway will use the HTTP host header value for SNI, when all resources referenced in BackendRefs are:\n1. Backend resources that do not set SNI, or\n2. Service/ServiceImport resources that do not have a BackendTLSPolicy attached to them\n\nWhen a BackendTLSPolicy attaches to a Backend resource, the BackendTLSPolicy's Hostname value takes precedence\nover this value.";
          type = (types.nullOr types.str);
        };
        "wellKnownCACertificates" = mkOption {
          description = "WellKnownCACertificates specifies whether system CA certificates may be used in\nthe TLS handshake between the gateway and backend pod.\n\nIf WellKnownCACertificates is unspecified or empty (\"\"), then CACertificateRefs\nmust be specified with at least one entry for a valid configuration. Only one of\nCACertificateRefs or WellKnownCACertificates may be specified, not both.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "alpnProtocols" = mkOverride 1002 null;
        "caCertificateRefs" = mkOverride 1002 null;
        "ciphers" = mkOverride 1002 null;
        "clientCertificateRef" = mkOverride 1002 null;
        "ecdhCurves" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "maxVersion" = mkOverride 1002 null;
        "minVersion" = mkOverride 1002 null;
        "signatureAlgorithms" = mkOverride 1002 null;
        "sni" = mkOverride 1002 null;
        "wellKnownCACertificates" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendSpecTlsCaCertificateRefs" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"HTTPRoute\" or \"Service\".";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendSpecTlsClientCertificateRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"Secret\".";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referenced object. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Conditions describe the current conditions of the Backend.";
          type = (
            types.nullOr (types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendStatusConditions"))
          );
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = types.str;
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "type of condition in CamelCase or in foo.example.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicy" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "spec defines the desired state of BackendTrafficPolicy.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpec");
        };
        "status" = mkOption {
          description = "status defines the current status of BackendTrafficPolicy.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicyStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpec" = {

      options = {
        "circuitBreaker" = mkOption {
          description = "Circuit Breaker settings for the upstream connections and requests.\nIf not set, circuit breakers will be enabled with the default thresholds";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecCircuitBreaker")
          );
        };
        "compression" = mkOption {
          description = "The compression config for the http streams.\nDeprecated: Use Compressor instead.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecCompression")
            )
          );
        };
        "compressor" = mkOption {
          description = "The compressor config for the http streams.\nThis provides more granular control over compression configuration.\nOrder matters: The first compressor in the list is preferred when q-values in Accept-Encoding are equal.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecCompressor")
            )
          );
        };
        "connection" = mkOption {
          description = "Connection includes backend connection settings.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecConnection")
          );
        };
        "dns" = mkOption {
          description = "DNS includes dns resolution settings.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecDns"));
        };
        "faultInjection" = mkOption {
          description = "FaultInjection defines the fault injection policy to be applied. This configuration can be used to\ninject delays and abort requests to mimic failure scenarios such as service failures and overloads";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecFaultInjection")
          );
        };
        "healthCheck" = mkOption {
          description = "HealthCheck allows gateway to perform active health checking on backends.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheck")
          );
        };
        "http2" = mkOption {
          description = "HTTP2 provides HTTP/2 configuration for backend connections.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHttp2"));
        };
        "httpUpgrade" = mkOption {
          description = "HTTPUpgrade defines the configuration for HTTP protocol upgrades.\nIf not specified, the default upgrade configuration(websocket) will be used.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHttpUpgrade")
            )
          );
        };
        "loadBalancer" = mkOption {
          description = "LoadBalancer policy to apply when routing traffic from the gateway to\nthe backend endpoints. Defaults to `LeastRequest`.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancer")
          );
        };
        "mergeType" = mkOption {
          description = "MergeType determines how this configuration is merged with existing BackendTrafficPolicy\nconfigurations targeting a parent resource. When set, this configuration will be merged\ninto a parent BackendTrafficPolicy (i.e. the one targeting a Gateway or Listener).\nThis field cannot be set when targeting a parent resource (Gateway).\nIf unset, no merging occurs, and only the most specific configuration takes effect.";
          type = (types.nullOr types.str);
        };
        "proxyProtocol" = mkOption {
          description = "ProxyProtocol enables the Proxy Protocol when communicating with the backend.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecProxyProtocol")
          );
        };
        "rateLimit" = mkOption {
          description = "RateLimit allows the user to limit the number of incoming requests\nto a predefined value based on attributes within the traffic flow.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimit")
          );
        };
        "requestBuffer" = mkOption {
          description = "RequestBuffer allows the gateway to buffer and fully receive each request from a client before continuing to send the request\nupstream to the backends. This can be helpful to shield your backend servers from slow clients, and also to enforce a maximum size per request\nas any requests larger than the buffer size will be rejected.\n\nThis can have a negative performance impact so should only be enabled when necessary.\n\nWhen enabling this option, you should also configure your connection buffer size to account for these request buffers. There will also be an\nincrease in memory usage for Envoy that should be accounted for in your deployment settings.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRequestBuffer")
          );
        };
        "responseOverride" = mkOption {
          description = "ResponseOverride defines the configuration to override specific responses with a custom one.\nIf multiple configurations are specified, the first one to match wins.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverride")
            )
          );
        };
        "retry" = mkOption {
          description = "Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.\nIf not set, retry will be disabled.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRetry"));
        };
        "routingType" = mkOption {
          description = "RoutingType can be set to \"Service\" to use the Service Cluster IP for routing to the backend,\nor it can be set to \"Endpoint\" to use Endpoint routing.\nWhen specified, this overrides the EnvoyProxy-level setting for the relevant targeRefs.\nIf not specified, the EnvoyProxy-level setting is used.";
          type = (types.nullOr types.str);
        };
        "targetRef" = mkOption {
          description = "TargetRef is the name of the resource this policy is being attached to.\nThis policy and the TargetRef MUST be in the same namespace for this\nPolicy to have effect\n\nDeprecated: use targetRefs/targetSelectors instead";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTargetRef")
          );
        };
        "targetRefs" = mkOption {
          description = "TargetRefs are the names of the Gateway resources this policy\nis being attached to.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTargetRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "targetSelectors" = mkOption {
          description = "TargetSelectors allow targeting resources for this policy based on labels";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTargetSelectors")
            )
          );
        };
        "tcpKeepalive" = mkOption {
          description = "TcpKeepalive settings associated with the upstream client connection.\nDisabled by default.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTcpKeepalive")
          );
        };
        "telemetry" = mkOption {
          description = "Telemetry configures the telemetry settings for the policy target (Gateway or xRoute).\nThis will override the telemetry settings in the EnvoyProxy resource.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTelemetry")
          );
        };
        "timeout" = mkOption {
          description = "Timeout settings for the backend connections.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTimeout")
          );
        };
        "useClientProtocol" = mkOption {
          description = "UseClientProtocol configures Envoy to prefer sending requests to backends using\nthe same HTTP protocol that the incoming request used. Defaults to false, which means\nthat Envoy will use the protocol indicated by the attached BackendRef.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "circuitBreaker" = mkOverride 1002 null;
        "compression" = mkOverride 1002 null;
        "compressor" = mkOverride 1002 null;
        "connection" = mkOverride 1002 null;
        "dns" = mkOverride 1002 null;
        "faultInjection" = mkOverride 1002 null;
        "healthCheck" = mkOverride 1002 null;
        "http2" = mkOverride 1002 null;
        "httpUpgrade" = mkOverride 1002 null;
        "loadBalancer" = mkOverride 1002 null;
        "mergeType" = mkOverride 1002 null;
        "proxyProtocol" = mkOverride 1002 null;
        "rateLimit" = mkOverride 1002 null;
        "requestBuffer" = mkOverride 1002 null;
        "responseOverride" = mkOverride 1002 null;
        "retry" = mkOverride 1002 null;
        "routingType" = mkOverride 1002 null;
        "targetRef" = mkOverride 1002 null;
        "targetRefs" = mkOverride 1002 null;
        "targetSelectors" = mkOverride 1002 null;
        "tcpKeepalive" = mkOverride 1002 null;
        "telemetry" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
        "useClientProtocol" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecCircuitBreaker" = {

      options = {
        "maxConnections" = mkOption {
          description = "The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxParallelRequests" = mkOption {
          description = "The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxParallelRetries" = mkOption {
          description = "The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxPendingRequests" = mkOption {
          description = "The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxRequestsPerConnection" = mkOption {
          description = "The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.\nDefault: unlimited.";
          type = (types.nullOr types.int);
        };
        "perEndpoint" = mkOption {
          description = "PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecCircuitBreakerPerEndpoint"
            )
          );
        };
      };

      config = {
        "maxConnections" = mkOverride 1002 null;
        "maxParallelRequests" = mkOverride 1002 null;
        "maxParallelRetries" = mkOverride 1002 null;
        "maxPendingRequests" = mkOverride 1002 null;
        "maxRequestsPerConnection" = mkOverride 1002 null;
        "perEndpoint" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecCircuitBreakerPerEndpoint" = {

      options = {
        "maxConnections" = mkOption {
          description = "MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "maxConnections" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecCompression" = {

      options = {
        "brotli" = mkOption {
          description = "The configuration for Brotli compressor.";
          type = (types.nullOr types.attrs);
        };
        "gzip" = mkOption {
          description = "The configuration for GZIP compressor.";
          type = (types.nullOr types.attrs);
        };
        "minContentLength" = mkOption {
          description = "MinContentLength defines the minimum response size in bytes to apply compression.\nResponses smaller than this threshold will not be compressed.\nMust be at least 30 bytes as enforced by Envoy Proxy.\nNote that when the suffix is not provided, the value is interpreted as bytes.\nDefault: 30 bytes";
          type = (types.nullOr (types.either types.int types.str));
        };
        "type" = mkOption {
          description = "CompressorType defines the compressor type to use for compression.";
          type = types.str;
        };
        "zstd" = mkOption {
          description = "The configuration for Zstd compressor.";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "brotli" = mkOverride 1002 null;
        "gzip" = mkOverride 1002 null;
        "minContentLength" = mkOverride 1002 null;
        "zstd" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecCompressor" = {

      options = {
        "brotli" = mkOption {
          description = "The configuration for Brotli compressor.";
          type = (types.nullOr types.attrs);
        };
        "gzip" = mkOption {
          description = "The configuration for GZIP compressor.";
          type = (types.nullOr types.attrs);
        };
        "minContentLength" = mkOption {
          description = "MinContentLength defines the minimum response size in bytes to apply compression.\nResponses smaller than this threshold will not be compressed.\nMust be at least 30 bytes as enforced by Envoy Proxy.\nNote that when the suffix is not provided, the value is interpreted as bytes.\nDefault: 30 bytes";
          type = (types.nullOr (types.either types.int types.str));
        };
        "type" = mkOption {
          description = "CompressorType defines the compressor type to use for compression.";
          type = types.str;
        };
        "zstd" = mkOption {
          description = "The configuration for Zstd compressor.";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "brotli" = mkOverride 1002 null;
        "gzip" = mkOverride 1002 null;
        "minContentLength" = mkOverride 1002 null;
        "zstd" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecConnection" = {

      options = {
        "bufferLimit" = mkOption {
          description = "BufferLimit Soft limit on size of the cluster’s connections read and write buffers.\nBufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.\nIf unspecified, an implementation defined default is applied (32768 bytes).\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote: that when the suffix is not provided, the value is interpreted as bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "preconnect" = mkOption {
          description = "Preconnect configures proactive upstream connections to reduce latency by establishing\nconnections before they’re needed and avoiding connection establishment overhead.\n\nIf unset, Envoy will fetch connections as needed to serve in-flight requests.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecConnectionPreconnect"
            )
          );
        };
        "socketBufferLimit" = mkOption {
          description = "SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket\nto backend.\nSocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote that when the suffix is not provided, the value is interpreted as bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "bufferLimit" = mkOverride 1002 null;
        "preconnect" = mkOverride 1002 null;
        "socketBufferLimit" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecConnectionPreconnect" = {

      options = {
        "perEndpointPercent" = mkOption {
          description = "PerEndpointPercent configures how many additional connections to maintain per\nupstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a\npercentage of the connections required by active streams\n(e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).\n\nAllowed value range is between 100-300. When both PerEndpointPercent and\nPredictivePercent are set, Envoy ensures both are satisfied (max of the two).";
          type = (types.nullOr types.int);
        };
        "predictivePercent" = mkOption {
          description = "PredictivePercent configures how many additional connections to maintain\nacross the cluster by anticipating which upstream endpoint the load balancer\nwill select next, useful for low-QPS services. Relies on deterministic\nloadbalancing and is only supported with Random or RoundRobin.\nExpressed as a percentage of the connections required by active streams\n(e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).\n\nMinimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are\nset Envoy ensures both are satisfied per host (max of the two).";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "perEndpointPercent" = mkOverride 1002 null;
        "predictivePercent" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecDns" = {

      options = {
        "dnsRefreshRate" = mkOption {
          description = "DNSRefreshRate specifies the rate at which DNS records should be refreshed.\nDefaults to 30 seconds.";
          type = (types.nullOr types.str);
        };
        "lookupFamily" = mkOption {
          description = "LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).\nIf set, this configuration overrides other defaults.";
          type = (types.nullOr types.str);
        };
        "respectDnsTtl" = mkOption {
          description = "RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.\nIf the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.\nDefaults to true.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "dnsRefreshRate" = mkOverride 1002 null;
        "lookupFamily" = mkOverride 1002 null;
        "respectDnsTtl" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecFaultInjection" = {

      options = {
        "abort" = mkOption {
          description = "If specified, the request will be aborted if it meets the configuration criteria.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecFaultInjectionAbort"
            )
          );
        };
        "delay" = mkOption {
          description = "If specified, a delay will be injected into the request.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecFaultInjectionDelay"
            )
          );
        };
      };

      config = {
        "abort" = mkOverride 1002 null;
        "delay" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecFaultInjectionAbort" = {

      options = {
        "grpcStatus" = mkOption {
          description = "GrpcStatus specifies the GRPC status code to be returned";
          type = (types.nullOr types.int);
        };
        "httpStatus" = mkOption {
          description = "StatusCode specifies the HTTP status code to be returned";
          type = (types.nullOr types.int);
        };
        "percentage" = mkOption {
          description = "Percentage specifies the percentage of requests to be aborted. Default 100%, if set 0, no requests will be aborted. Accuracy to 0.0001%.";
          type = (types.nullOr (types.either types.int types.float));
        };
      };

      config = {
        "grpcStatus" = mkOverride 1002 null;
        "httpStatus" = mkOverride 1002 null;
        "percentage" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecFaultInjectionDelay" = {

      options = {
        "fixedDelay" = mkOption {
          description = "FixedDelay specifies the fixed delay duration";
          type = types.str;
        };
        "percentage" = mkOption {
          description = "Percentage specifies the percentage of requests to be delayed. Default 100%, if set 0, no requests will be delayed. Accuracy to 0.0001%.";
          type = (types.nullOr (types.either types.int types.float));
        };
      };

      config = {
        "percentage" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheck" = {

      options = {
        "active" = mkOption {
          description = "Active health check configuration";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActive"
            )
          );
        };
        "panicThreshold" = mkOption {
          description = "When number of unhealthy endpoints for a backend reaches this threshold\nEnvoy will disregard health status and balance across all endpoints.\nIt's designed to prevent a situation in which host failures cascade throughout the cluster\nas load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.";
          type = (types.nullOr types.int);
        };
        "passive" = mkOption {
          description = "Passive passive check configuration";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckPassive"
            )
          );
        };
      };

      config = {
        "active" = mkOverride 1002 null;
        "panicThreshold" = mkOverride 1002 null;
        "passive" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActive" = {

      options = {
        "grpc" = mkOption {
          description = "GRPC defines the configuration of the GRPC health checker.\nIt's optional, and can only be used if the specified type is GRPC.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveGrpc"
            )
          );
        };
        "healthyThreshold" = mkOption {
          description = "HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.";
          type = (types.nullOr types.int);
        };
        "http" = mkOption {
          description = "HTTP defines the configuration of http health checker.\nIt's required while the health checker type is HTTP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveHttp"
            )
          );
        };
        "initialJitter" = mkOption {
          description = "InitialJitter defines the maximum time Envoy will wait before the first health check.\nEnvoy will randomly select a value between 0 and the initial jitter value.";
          type = (types.nullOr types.str);
        };
        "interval" = mkOption {
          description = "Interval defines the time between active health checks.";
          type = (types.nullOr types.str);
        };
        "tcp" = mkOption {
          description = "TCP defines the configuration of tcp health checker.\nIt's required while the health checker type is TCP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveTcp"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout defines the time to wait for a health check response.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type defines the type of health checker.";
          type = types.str;
        };
        "unhealthyThreshold" = mkOption {
          description = "UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "grpc" = mkOverride 1002 null;
        "healthyThreshold" = mkOverride 1002 null;
        "http" = mkOverride 1002 null;
        "initialJitter" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "tcp" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
        "unhealthyThreshold" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveGrpc" = {

      options = {
        "service" = mkOption {
          description = "Service to send in the health check request.\nIf this is not specified, then the health check request applies to the entire\nserver and not to a specific service.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "service" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveHttp" = {

      options = {
        "expectedResponse" = mkOption {
          description = "ExpectedResponse defines a list of HTTP expected responses to match.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse"
            )
          );
        };
        "expectedStatuses" = mkOption {
          description = "ExpectedStatuses defines a list of HTTP response statuses considered healthy.\nDefaults to 200 only";
          type = (types.nullOr (types.listOf types.int));
        };
        "hostname" = mkOption {
          description = "Hostname defines the HTTP host that will be requested during health checking.\nDefault: HTTPRoute or GRPCRoute hostname.";
          type = (types.nullOr types.str);
        };
        "method" = mkOption {
          description = "Method defines the HTTP method used for health checking.\nDefaults to GET";
          type = (types.nullOr types.str);
        };
        "path" = mkOption {
          description = "Path defines the HTTP path that will be requested during health checking.";
          type = types.str;
        };
      };

      config = {
        "expectedResponse" = mkOverride 1002 null;
        "expectedStatuses" = mkOverride 1002 null;
        "hostname" = mkOverride 1002 null;
        "method" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse" = {

      options = {
        "binary" = mkOption {
          description = "Binary payload base64 encoded.";
          type = (types.nullOr types.str);
        };
        "text" = mkOption {
          description = "Text payload in plain text.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type defines the type of the payload.";
          type = types.str;
        };
      };

      config = {
        "binary" = mkOverride 1002 null;
        "text" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveTcp" = {

      options = {
        "receive" = mkOption {
          description = "Receive defines the expected response payload.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveTcpReceive"
            )
          );
        };
        "send" = mkOption {
          description = "Send defines the request payload.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveTcpSend"
            )
          );
        };
      };

      config = {
        "receive" = mkOverride 1002 null;
        "send" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveTcpReceive" = {

      options = {
        "binary" = mkOption {
          description = "Binary payload base64 encoded.";
          type = (types.nullOr types.str);
        };
        "text" = mkOption {
          description = "Text payload in plain text.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type defines the type of the payload.";
          type = types.str;
        };
      };

      config = {
        "binary" = mkOverride 1002 null;
        "text" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveTcpSend" = {

      options = {
        "binary" = mkOption {
          description = "Binary payload base64 encoded.";
          type = (types.nullOr types.str);
        };
        "text" = mkOption {
          description = "Text payload in plain text.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type defines the type of the payload.";
          type = types.str;
        };
      };

      config = {
        "binary" = mkOverride 1002 null;
        "text" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHealthCheckPassive" = {

      options = {
        "baseEjectionTime" = mkOption {
          description = "BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.";
          type = (types.nullOr types.str);
        };
        "consecutive5XxErrors" = mkOption {
          description = "Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.";
          type = (types.nullOr types.int);
        };
        "consecutiveGatewayErrors" = mkOption {
          description = "ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.";
          type = (types.nullOr types.int);
        };
        "consecutiveLocalOriginFailures" = mkOption {
          description = "ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.\nParameter takes effect only when split_external_local_origin_errors is set to true.";
          type = (types.nullOr types.int);
        };
        "failurePercentageThreshold" = mkOption {
          description = "FailurePercentageThreshold sets the failure percentage threshold for outlier detection.\nIf the failure percentage of a given host is greater than or equal to this value, it will be ejected.\nDefaults to 85.";
          type = (types.nullOr types.int);
        };
        "interval" = mkOption {
          description = "Interval defines the time between passive health checks.";
          type = (types.nullOr types.str);
        };
        "maxEjectionPercent" = mkOption {
          description = "MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.";
          type = (types.nullOr types.int);
        };
        "splitExternalLocalOriginErrors" = mkOption {
          description = "SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "baseEjectionTime" = mkOverride 1002 null;
        "consecutive5XxErrors" = mkOverride 1002 null;
        "consecutiveGatewayErrors" = mkOverride 1002 null;
        "consecutiveLocalOriginFailures" = mkOverride 1002 null;
        "failurePercentageThreshold" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "maxEjectionPercent" = mkOverride 1002 null;
        "splitExternalLocalOriginErrors" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHttp2" = {

      options = {
        "initialConnectionWindowSize" = mkOption {
          description = "InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.\nIf not set, the default value is 1 MiB.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "initialStreamWindowSize" = mkOption {
          description = "InitialStreamWindowSize sets the initial window size for HTTP/2 streams.\nIf not set, the default value is 64 KiB(64*1024).";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxConcurrentStreams" = mkOption {
          description = "MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.\nIf not set, the default value is 100.";
          type = (types.nullOr types.int);
        };
        "onInvalidMessage" = mkOption {
          description = "OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error\nIt's recommended for L2 Envoy deployments to set this value to TerminateStream.\nhttps://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two\nDefault: TerminateConnection";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "initialConnectionWindowSize" = mkOverride 1002 null;
        "initialStreamWindowSize" = mkOverride 1002 null;
        "maxConcurrentStreams" = mkOverride 1002 null;
        "onInvalidMessage" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHttpUpgrade" = {

      options = {
        "connect" = mkOption {
          description = "Connect specifies the configuration for the CONNECT config.\nThis is allowed only when type is CONNECT.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHttpUpgradeConnect"
            )
          );
        };
        "type" = mkOption {
          description = "Type is the case-insensitive type of protocol upgrade.\ne.g. `websocket`, `CONNECT`, `spdy/3.1` etc.";
          type = types.str;
        };
      };

      config = {
        "connect" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecHttpUpgradeConnect" = {

      options = {
        "terminate" = mkOption {
          description = "Terminate the CONNECT request, and forwards the payload as raw TCP data.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "terminate" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancer" = {

      options = {
        "consistentHash" = mkOption {
          description = "ConsistentHash defines the configuration when the load balancer type is\nset to ConsistentHash";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHash"
            )
          );
        };
        "endpointOverride" = mkOption {
          description = "EndpointOverride defines the configuration for endpoint override.\nWhen specified, the load balancer will attempt to route requests to endpoints\nbased on the override information extracted from request headers or metadata.\n If the override endpoints are not available, the configured load balancer policy will be used as fallback.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerEndpointOverride"
            )
          );
        };
        "slowStart" = mkOption {
          description = "SlowStart defines the configuration related to the slow start load balancer policy.\nIf set, during slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently this is only supported for RoundRobin and LeastRequest load balancers";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerSlowStart"
            )
          );
        };
        "type" = mkOption {
          description = "Type decides the type of Load Balancer policy.\nValid LoadBalancerType values are\n\"ConsistentHash\",\n\"LeastRequest\",\n\"Random\",\n\"RoundRobin\".";
          type = types.str;
        };
        "zoneAware" = mkOption {
          description = "ZoneAware defines the configuration related to the distribution of requests between locality zones.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerZoneAware"
            )
          );
        };
      };

      config = {
        "consistentHash" = mkOverride 1002 null;
        "endpointOverride" = mkOverride 1002 null;
        "slowStart" = mkOverride 1002 null;
        "zoneAware" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHash" = {

      options = {
        "cookie" = mkOption {
          description = "Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHashCookie"
            )
          );
        };
        "header" = mkOption {
          description = "Header configures the header hash policy when the consistent hash type is set to Header.\n\nDeprecated: use Headers instead";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHashHeader"
            )
          );
        };
        "headers" = mkOption {
          description = "Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHashHeaders"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "queryParams" = mkOption {
          description = "QueryParams configures the query parameter hash policy when the consistent hash type is set to QueryParams.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHashQueryParams"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "tableSize" = mkOption {
          description = "The table size for consistent hashing, must be prime number limited to 5000011.";
          type = (types.nullOr types.int);
        };
        "type" = mkOption {
          description = "ConsistentHashType defines the type of input to hash on. Valid Type values are\n\"SourceIP\",\n\"Header\",\n\"Headers\",\n\"Cookie\".\n\"QueryParams\".";
          type = types.str;
        };
      };

      config = {
        "cookie" = mkOverride 1002 null;
        "header" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "queryParams" = mkOverride 1002 null;
        "tableSize" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHashCookie" = {

      options = {
        "attributes" = mkOption {
          description = "Additional Attributes to set for the generated cookie.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name of the cookie to hash.\nIf this cookie does not exist in the request, Envoy will generate a cookie and set\nthe TTL on the response back to the client based on Layer 4\nattributes of the backend endpoint, to ensure that these future requests\ngo to the same backend endpoint. Make sure to set the TTL field for this case.";
          type = types.str;
        };
        "ttl" = mkOption {
          description = "TTL of the generated cookie if the cookie is not present. This value sets the\nMax-Age attribute value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "attributes" = mkOverride 1002 null;
        "ttl" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHashHeader" = {

      options = {
        "name" = mkOption {
          description = "Name of the header to hash.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHashHeaders" = {

      options = {
        "name" = mkOption {
          description = "Name of the header to hash.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHashQueryParams" = {

      options = {
        "name" = mkOption {
          description = "Name of the query param to hash.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerEndpointOverride" = {

      options = {
        "extractFrom" = mkOption {
          description = "ExtractFrom defines the sources to extract endpoint override information from.";
          type = (
            types.listOf (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFrom"
            )
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFrom" = {

      options = {
        "header" = mkOption {
          description = "Header defines the header to get the override endpoint addresses.\nThe header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.\nFor example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.\nThe IPv6 address is enclosed in square brackets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "header" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerSlowStart" = {

      options = {
        "window" = mkOption {
          description = "Window defines the duration of the warm up period for newly added host.\nDuring slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently only supports linear growth of traffic. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerZoneAware" = {

      options = {
        "preferLocal" = mkOption {
          description = "PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal"
            )
          );
        };
      };

      config = {
        "preferLocal" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal" = {

      options = {
        "force" = mkOption {
          description = "ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior\nwhich maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForce"
            )
          );
        };
        "minEndpointsThreshold" = mkOption {
          description = "MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.";
          type = (types.nullOr types.int);
        };
        "percentageEnabled" = mkOption {
          description = "Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "force" = mkOverride 1002 null;
        "minEndpointsThreshold" = mkOverride 1002 null;
        "percentageEnabled" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForce" = {

      options = {
        "minEndpointsInZoneThreshold" = mkOption {
          description = "MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone\noverride. This is useful for protecting zones with fewer endpoints.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "minEndpointsInZoneThreshold" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecProxyProtocol" = {

      options = {
        "version" = mkOption {
          description = "Version of ProxyProtol\nValid ProxyProtocolVersion values are\n\"V1\"\n\"V2\"";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimit" = {

      options = {
        "global" = mkOption {
          description = "Global defines global rate limit configuration.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobal")
          );
        };
        "local" = mkOption {
          description = "Local defines local rate limit configuration.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocal")
          );
        };
        "type" = mkOption {
          description = "Type decides the scope for the RateLimits.\nValid RateLimitType values are \"Global\" or \"Local\".\n\nDeprecated: Use Global and/or Local fields directly instead. Both can be specified simultaneously for combined rate limiting.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "global" = mkOverride 1002 null;
        "local" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobal" = {

      options = {
        "rules" = mkOption {
          description = "Rules are a list of RateLimit selectors and limits. Each rule and its\nassociated limit is applied in a mutually exclusive way. If a request\nmatches multiple rules, each of their associated limits get applied, so a\nsingle request might increase the rate limit counters for multiple rules\nif selected. The rate limit service will return a logical OR of the individual\nrate limit decisions of all matching rules. For example, if a request\nmatches two rules, one rate limited and one not, the final decision will be\nto rate limit the request.";
          type = (
            types.listOf (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRules"
            )
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRules" = {

      options = {
        "clientSelectors" = mkOption {
          description = "ClientSelectors holds the list of select conditions to select\nspecific clients using attributes from the traffic flow.\nAll individual select conditions must hold True for this rule\nand its limit to be applied.\n\nIf no client selectors are specified, the rule applies to all traffic of\nthe targeted Route.\n\nIf the policy targets a Gateway, the rule applies to each Route of the Gateway.\nPlease note that each Route has its own rate limit counters. For example,\nif a Gateway has two Routes, and the policy has a rule with limit 10rps,\neach Route will have its own 10rps limit.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors"
              )
            )
          );
        };
        "cost" = mkOption {
          description = "Cost specifies the cost of requests and responses for the rule.\n\nThis is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on\nthe request path and do not reduce the rate limit counters on the response path.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCost"
            )
          );
        };
        "limit" = mkOption {
          description = "Limit holds the rate limit values.\nThis limit is applied for traffic flows when the selectors\ncompute to True, causing the request to be counted towards the limit.\nThe limit is enforced and the request is ratelimited, i.e. a response with\n429 HTTP status code is sent back to the client when\nthe selected requests have reached the limit.";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesLimit"
          );
        };
        "shadowMode" = mkOption {
          description = "ShadowMode indicates whether this rate-limit rule runs in shadow mode.\nWhen enabled, all rate-limiting operations are performed (cache lookups,\ncounter updates, telemetry generation), but the outcome is never enforced.\nThe request always succeeds, even if the configured limit is exceeded.\n\nOnly supported for Global Rate Limits.";
          type = (types.nullOr types.bool);
        };
        "shared" = mkOption {
          description = "Shared determines whether this rate limit rule applies across all the policy targets.\nIf set to true, the rule is treated as a common bucket and is shared across all policy targets (xRoutes).\nDefault: false.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "clientSelectors" = mkOverride 1002 null;
        "cost" = mkOverride 1002 null;
        "shadowMode" = mkOverride 1002 null;
        "shared" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors" = {

      options = {
        "headers" = mkOption {
          description = "Headers is a list of request headers to match. Multiple header values are ANDed together,\nmeaning, a request MUST match all the specified headers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "methods" = mkOption {
          description = "Methods is a list of request methods to match. Multiple method values are ORed together,\nmeaning, a request can match any one of the specified methods. If not specified, it matches all methods.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethods"
              )
            )
          );
        };
        "path" = mkOption {
          description = "Path is the request path to match.\nSupport Exact, PathPrefix and RegularExpression match types.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPath"
            )
          );
        };
        "queryParams" = mkOption {
          description = "QueryParams is a list of query parameters to match. Multiple query parameter values are ANDed together,\nmeaning, a request MUST match all the specified query parameters.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsQueryParams"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "sourceCIDR" = mkOption {
          description = "SourceCIDR is the client IP Address range to match on.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCIDR"
            )
          );
        };
      };

      config = {
        "headers" = mkOverride 1002 null;
        "methods" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
        "queryParams" = mkOverride 1002 null;
        "sourceCIDR" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders" =
      {

        options = {
          "invert" = mkOption {
            description = "Invert specifies whether the value match result will be inverted.\nDo not set this field when Type=\"Distinct\", implying matching on any/all unique\nvalues within the header.";
            type = (types.nullOr types.bool);
          };
          "name" = mkOption {
            description = "Name of the HTTP header.\nThe header name is case-insensitive unless PreserveHeaderCase is set to true.\nFor example, \"Foo\" and \"foo\" are considered the same header.";
            type = types.str;
          };
          "type" = mkOption {
            description = "Type specifies how to match against the value of the header.";
            type = (types.nullOr types.str);
          };
          "value" = mkOption {
            description = "Value within the HTTP header.\nDo not set this field when Type=\"Distinct\", implying matching on any/all unique\nvalues within the header.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "invert" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
          "value" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethods" =
      {

        options = {
          "invert" = mkOption {
            description = "Invert specifies whether the value match result will be inverted.";
            type = (types.nullOr types.bool);
          };
          "value" = mkOption {
            description = "Value specifies the HTTP method.";
            type = types.str;
          };
        };

        config = {
          "invert" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPath" = {

      options = {
        "invert" = mkOption {
          description = "Invert specifies whether the value match result will be inverted.";
          type = (types.nullOr types.bool);
        };
        "type" = mkOption {
          description = "Type specifies how to match against the value of the path.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value specifies the HTTP path.";
          type = types.str;
        };
      };

      config = {
        "invert" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsQueryParams" =
      {

        options = {
          "invert" = mkOption {
            description = "Invert specifies whether the value match result will be inverted.\nDo not set this field when Type=\"Distinct\", implying matching on any/all unique\nvalues within the query parameter.";
            type = (types.nullOr types.bool);
          };
          "name" = mkOption {
            description = "Name of the query parameter.";
            type = types.str;
          };
          "type" = mkOption {
            description = "Type specifies how to match against the value of the query parameter.";
            type = (types.nullOr types.str);
          };
          "value" = mkOption {
            description = "Value of the query parameter.\nDo not set this field when Type=\"Distinct\", implying matching on any/all unique\nvalues within the query parameter.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "invert" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
          "value" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCIDR" =
      {

        options = {
          "type" = mkOption {
            description = "";
            type = (types.nullOr types.str);
          };
          "value" = mkOption {
            description = "Value is the IP CIDR that represents the range of Source IP Addresses of the client.\nThese could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.\nFor example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.";
            type = types.str;
          };
        };

        config = {
          "type" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCost" = {

      options = {
        "request" = mkOption {
          description = "Request specifies the number to reduce the rate limit counters\non the request path. If this is not specified, the default behavior\nis to reduce the rate limit counters by 1.\n\nWhen Envoy receives a request that matches the rule, it tries to reduce the\nrate limit counters by the specified number. If the counter doesn't have\nenough capacity, the request is rate limited.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest"
            )
          );
        };
        "response" = mkOption {
          description = "Response specifies the number to reduce the rate limit counters\nafter the response is sent back to the client or the request stream is closed.\n\nThe cost is used to reduce the rate limit counters for the matching requests.\nSince the reduction happens after the request stream is complete, the rate limit\nwon't be enforced for the current request, but for the subsequent matching requests.\n\nThis is optional and if not specified, the rate limit counters are not reduced\non the response path.\n\nCurrently, this is only supported for HTTP Global Rate Limits.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse"
            )
          );
        };
      };

      config = {
        "request" = mkOverride 1002 null;
        "response" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest" = {

      options = {
        "from" = mkOption {
          description = "From specifies where to get the rate limit cost. Currently, only \"Number\" and \"Metadata\" are supported.";
          type = types.str;
        };
        "metadata" = mkOption {
          description = "Metadata specifies the per-request metadata to retrieve the usage number from.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadata"
            )
          );
        };
        "number" = mkOption {
          description = "Number specifies the fixed usage number to reduce the rate limit counters.\nUsing zero can be used to only check the rate limit counters without reducing them.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "number" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadata" = {

      options = {
        "key" = mkOption {
          description = "Key is the key to retrieve the usage number from the filter metadata.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the dynamic metadata.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse" = {

      options = {
        "from" = mkOption {
          description = "From specifies where to get the rate limit cost. Currently, only \"Number\" and \"Metadata\" are supported.";
          type = types.str;
        };
        "metadata" = mkOption {
          description = "Metadata specifies the per-request metadata to retrieve the usage number from.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadata"
            )
          );
        };
        "number" = mkOption {
          description = "Number specifies the fixed usage number to reduce the rate limit counters.\nUsing zero can be used to only check the rate limit counters without reducing them.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "number" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadata" =
      {

        options = {
          "key" = mkOption {
            description = "Key is the key to retrieve the usage number from the filter metadata.";
            type = types.str;
          };
          "namespace" = mkOption {
            description = "Namespace is the namespace of the dynamic metadata.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesLimit" = {

      options = {
        "requests" = mkOption {
          description = "";
          type = types.int;
        };
        "unit" = mkOption {
          description = "RateLimitUnit specifies the intervals for setting rate limits.\nValid RateLimitUnit values are \"Second\", \"Minute\", \"Hour\", \"Day\", \"Month\" and \"Year\".";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocal" = {

      options = {
        "rules" = mkOption {
          description = "Rules are a list of RateLimit selectors and limits. If a request matches\nmultiple rules, the strictest limit is applied. For example, if a request\nmatches two rules, one with 10rps and one with 20rps, the final limit will\nbe based on the rule with 10rps.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRules"
              )
            )
          );
        };
      };

      config = {
        "rules" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRules" = {

      options = {
        "clientSelectors" = mkOption {
          description = "ClientSelectors holds the list of select conditions to select\nspecific clients using attributes from the traffic flow.\nAll individual select conditions must hold True for this rule\nand its limit to be applied.\n\nIf no client selectors are specified, the rule applies to all traffic of\nthe targeted Route.\n\nIf the policy targets a Gateway, the rule applies to each Route of the Gateway.\nPlease note that each Route has its own rate limit counters. For example,\nif a Gateway has two Routes, and the policy has a rule with limit 10rps,\neach Route will have its own 10rps limit.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors"
              )
            )
          );
        };
        "cost" = mkOption {
          description = "Cost specifies the cost of requests and responses for the rule.\n\nThis is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on\nthe request path and do not reduce the rate limit counters on the response path.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCost"
            )
          );
        };
        "limit" = mkOption {
          description = "Limit holds the rate limit values.\nThis limit is applied for traffic flows when the selectors\ncompute to True, causing the request to be counted towards the limit.\nThe limit is enforced and the request is ratelimited, i.e. a response with\n429 HTTP status code is sent back to the client when\nthe selected requests have reached the limit.";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesLimit"
          );
        };
        "shadowMode" = mkOption {
          description = "ShadowMode indicates whether this rate-limit rule runs in shadow mode.\nWhen enabled, all rate-limiting operations are performed (cache lookups,\ncounter updates, telemetry generation), but the outcome is never enforced.\nThe request always succeeds, even if the configured limit is exceeded.\n\nOnly supported for Global Rate Limits.";
          type = (types.nullOr types.bool);
        };
        "shared" = mkOption {
          description = "Shared determines whether this rate limit rule applies across all the policy targets.\nIf set to true, the rule is treated as a common bucket and is shared across all policy targets (xRoutes).\nDefault: false.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "clientSelectors" = mkOverride 1002 null;
        "cost" = mkOverride 1002 null;
        "shadowMode" = mkOverride 1002 null;
        "shared" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors" = {

      options = {
        "headers" = mkOption {
          description = "Headers is a list of request headers to match. Multiple header values are ANDed together,\nmeaning, a request MUST match all the specified headers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "methods" = mkOption {
          description = "Methods is a list of request methods to match. Multiple method values are ORed together,\nmeaning, a request can match any one of the specified methods. If not specified, it matches all methods.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethods"
              )
            )
          );
        };
        "path" = mkOption {
          description = "Path is the request path to match.\nSupport Exact, PathPrefix and RegularExpression match types.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPath"
            )
          );
        };
        "queryParams" = mkOption {
          description = "QueryParams is a list of query parameters to match. Multiple query parameter values are ANDed together,\nmeaning, a request MUST match all the specified query parameters.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsQueryParams"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "sourceCIDR" = mkOption {
          description = "SourceCIDR is the client IP Address range to match on.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCIDR"
            )
          );
        };
      };

      config = {
        "headers" = mkOverride 1002 null;
        "methods" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
        "queryParams" = mkOverride 1002 null;
        "sourceCIDR" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders" =
      {

        options = {
          "invert" = mkOption {
            description = "Invert specifies whether the value match result will be inverted.\nDo not set this field when Type=\"Distinct\", implying matching on any/all unique\nvalues within the header.";
            type = (types.nullOr types.bool);
          };
          "name" = mkOption {
            description = "Name of the HTTP header.\nThe header name is case-insensitive unless PreserveHeaderCase is set to true.\nFor example, \"Foo\" and \"foo\" are considered the same header.";
            type = types.str;
          };
          "type" = mkOption {
            description = "Type specifies how to match against the value of the header.";
            type = (types.nullOr types.str);
          };
          "value" = mkOption {
            description = "Value within the HTTP header.\nDo not set this field when Type=\"Distinct\", implying matching on any/all unique\nvalues within the header.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "invert" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
          "value" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethods" =
      {

        options = {
          "invert" = mkOption {
            description = "Invert specifies whether the value match result will be inverted.";
            type = (types.nullOr types.bool);
          };
          "value" = mkOption {
            description = "Value specifies the HTTP method.";
            type = types.str;
          };
        };

        config = {
          "invert" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPath" = {

      options = {
        "invert" = mkOption {
          description = "Invert specifies whether the value match result will be inverted.";
          type = (types.nullOr types.bool);
        };
        "type" = mkOption {
          description = "Type specifies how to match against the value of the path.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value specifies the HTTP path.";
          type = types.str;
        };
      };

      config = {
        "invert" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsQueryParams" =
      {

        options = {
          "invert" = mkOption {
            description = "Invert specifies whether the value match result will be inverted.\nDo not set this field when Type=\"Distinct\", implying matching on any/all unique\nvalues within the query parameter.";
            type = (types.nullOr types.bool);
          };
          "name" = mkOption {
            description = "Name of the query parameter.";
            type = types.str;
          };
          "type" = mkOption {
            description = "Type specifies how to match against the value of the query parameter.";
            type = (types.nullOr types.str);
          };
          "value" = mkOption {
            description = "Value of the query parameter.\nDo not set this field when Type=\"Distinct\", implying matching on any/all unique\nvalues within the query parameter.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "invert" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
          "value" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCIDR" =
      {

        options = {
          "type" = mkOption {
            description = "";
            type = (types.nullOr types.str);
          };
          "value" = mkOption {
            description = "Value is the IP CIDR that represents the range of Source IP Addresses of the client.\nThese could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.\nFor example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.";
            type = types.str;
          };
        };

        config = {
          "type" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCost" = {

      options = {
        "request" = mkOption {
          description = "Request specifies the number to reduce the rate limit counters\non the request path. If this is not specified, the default behavior\nis to reduce the rate limit counters by 1.\n\nWhen Envoy receives a request that matches the rule, it tries to reduce the\nrate limit counters by the specified number. If the counter doesn't have\nenough capacity, the request is rate limited.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostRequest"
            )
          );
        };
        "response" = mkOption {
          description = "Response specifies the number to reduce the rate limit counters\nafter the response is sent back to the client or the request stream is closed.\n\nThe cost is used to reduce the rate limit counters for the matching requests.\nSince the reduction happens after the request stream is complete, the rate limit\nwon't be enforced for the current request, but for the subsequent matching requests.\n\nThis is optional and if not specified, the rate limit counters are not reduced\non the response path.\n\nCurrently, this is only supported for HTTP Global Rate Limits.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostResponse"
            )
          );
        };
      };

      config = {
        "request" = mkOverride 1002 null;
        "response" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostRequest" = {

      options = {
        "from" = mkOption {
          description = "From specifies where to get the rate limit cost. Currently, only \"Number\" and \"Metadata\" are supported.";
          type = types.str;
        };
        "metadata" = mkOption {
          description = "Metadata specifies the per-request metadata to retrieve the usage number from.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadata"
            )
          );
        };
        "number" = mkOption {
          description = "Number specifies the fixed usage number to reduce the rate limit counters.\nUsing zero can be used to only check the rate limit counters without reducing them.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "number" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadata" = {

      options = {
        "key" = mkOption {
          description = "Key is the key to retrieve the usage number from the filter metadata.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the dynamic metadata.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostResponse" = {

      options = {
        "from" = mkOption {
          description = "From specifies where to get the rate limit cost. Currently, only \"Number\" and \"Metadata\" are supported.";
          type = types.str;
        };
        "metadata" = mkOption {
          description = "Metadata specifies the per-request metadata to retrieve the usage number from.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadata"
            )
          );
        };
        "number" = mkOption {
          description = "Number specifies the fixed usage number to reduce the rate limit counters.\nUsing zero can be used to only check the rate limit counters without reducing them.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "number" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadata" = {

      options = {
        "key" = mkOption {
          description = "Key is the key to retrieve the usage number from the filter metadata.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the dynamic metadata.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesLimit" = {

      options = {
        "requests" = mkOption {
          description = "";
          type = types.int;
        };
        "unit" = mkOption {
          description = "RateLimitUnit specifies the intervals for setting rate limits.\nValid RateLimitUnit values are \"Second\", \"Minute\", \"Hour\", \"Day\", \"Month\" and \"Year\".";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRequestBuffer" = {

      options = {
        "limit" = mkOption {
          description = "Limit specifies the maximum allowed size in bytes for each incoming request buffer.\nIf exceeded, the request will be rejected with HTTP 413 Content Too Large.\n\nAccepts values in resource.Quantity format (e.g., \"10Mi\", \"500Ki\").";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "limit" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverride" = {

      options = {
        "match" = mkOption {
          description = "Match configuration.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideMatch");
        };
        "redirect" = mkOption {
          description = "Redirect configuration";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideRedirect"
            )
          );
        };
        "response" = mkOption {
          description = "Response configuration.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponse"
            )
          );
        };
      };

      config = {
        "redirect" = mkOverride 1002 null;
        "response" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideMatch" = {

      options = {
        "statusCodes" = mkOption {
          description = "Status code to match on. The match evaluates to true if any of the matches are successful.";
          type = (
            types.listOf (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideMatchStatusCodes"
            )
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideMatchStatusCodes" = {

      options = {
        "range" = mkOption {
          description = "Range contains the range of status codes.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRange"
            )
          );
        };
        "type" = mkOption {
          description = "Type is the type of value.\nValid values are Value and Range, default is Value.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value contains the value of the status code.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "range" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRange" = {

      options = {
        "end" = mkOption {
          description = "End of the range, including the end value.";
          type = types.int;
        };
        "start" = mkOption {
          description = "Start of the range, including the start value.";
          type = types.int;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideRedirect" = {

      options = {
        "hostname" = mkOption {
          description = "Hostname is the hostname to be used in the value of the `Location`\nheader in the response.\nWhen empty, the hostname in the `Host` header of the request is used.";
          type = (types.nullOr types.str);
        };
        "path" = mkOption {
          description = "Path defines parameters used to modify the path of the incoming request.\nThe modified path is then used to construct the `Location` header. When\nempty, the request path is used as-is.\nOnly ReplaceFullPath path modifier is supported currently.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideRedirectPath"
            )
          );
        };
        "port" = mkOption {
          description = "Port is the port to be used in the value of the `Location`\nheader in the response.\n\nIf redirect scheme is not-empty, the well-known port associated with the redirect scheme will be used.\nSpecifically \"http\" to port 80 and \"https\" to port 443. If the redirect scheme does not have a\nwell-known port or redirect scheme is empty, the listener port of the Gateway will be used.\n\nPort will not be added in the 'Location' header if scheme is HTTP and port is 80\nor scheme is HTTPS and port is 443.";
          type = (types.nullOr types.int);
        };
        "scheme" = mkOption {
          description = "Scheme is the scheme to be used in the value of the `Location` header in\nthe response. When empty, the scheme of the request is used.";
          type = (types.nullOr types.str);
        };
        "statusCode" = mkOption {
          description = "StatusCode is the HTTP status code to be used in response.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "hostname" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "scheme" = mkOverride 1002 null;
        "statusCode" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideRedirectPath" = {

      options = {
        "replaceFullPath" = mkOption {
          description = "ReplaceFullPath specifies the value with which to replace the full path\nof a request during a rewrite or redirect.";
          type = (types.nullOr types.str);
        };
        "replacePrefixMatch" = mkOption {
          description = "ReplacePrefixMatch specifies the value with which to replace the prefix\nmatch of a request during a rewrite or redirect. For example, a request\nto \"/foo/bar\" with a prefix match of \"/foo\" and a ReplacePrefixMatch\nof \"/xyz\" would be modified to \"/xyz/bar\".\n\nNote that this matches the behavior of the PathPrefix match type. This\nmatches full path elements. A path element refers to the list of labels\nin the path split by the `/` separator. When specified, a trailing `/` is\nignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all\nmatch the prefix `/abc`, but the path `/abcd` would not.\n\nReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.\nUsing any other HTTPRouteMatch type on the same HTTPRouteRule will result in\nthe implementation setting the Accepted Condition for the Route to `status: False`.\n\nRequest Path | Prefix Match | Replace Prefix | Modified Path";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type defines the type of path modifier. Additional types may be\nadded in a future release of the API.\n\nNote that values may be added to this enum, implementations\nmust ensure that unknown values will not cause a crash.\n\nUnknown values here must result in the implementation setting the\nAccepted Condition for the Route to `status: False`, with a\nReason of `UnsupportedValue`.";
          type = types.str;
        };
      };

      config = {
        "replaceFullPath" = mkOverride 1002 null;
        "replacePrefixMatch" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponse" = {

      options = {
        "body" = mkOption {
          description = "Body of the Custom Response\nSupports Envoy command operators for dynamic content (see https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseBody"
            )
          );
        };
        "contentType" = mkOption {
          description = "Content Type of the response. This will be set in the Content-Type header.";
          type = (types.nullOr types.str);
        };
        "header" = mkOption {
          description = "Header defines headers to add, set or remove from the response.\nThis allows the response policy to append, add or override headers\nof the final response before it is sent to a downstream client.\nNote: Header removal is not supported for responseOverride.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseHeader"
            )
          );
        };
        "statusCode" = mkOption {
          description = "Status Code of the Custom Response\nIf unset, does not override the status of response.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "body" = mkOverride 1002 null;
        "contentType" = mkOverride 1002 null;
        "header" = mkOverride 1002 null;
        "statusCode" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseBody" = {

      options = {
        "inline" = mkOption {
          description = "Inline contains the value as an inline string.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type is the type of method to use to read the body value.\nValid values are Inline and ValueRef, default is Inline.";
          type = types.str;
        };
        "valueRef" = mkOption {
          description = "ValueRef contains the contents of the body\nspecified as a local object reference.\nOnly a reference to ConfigMap is supported.\n\nThe value of key `response.body` in the ConfigMap will be used as the response body.\nIf the key is not found, the first value in the ConfigMap will be used.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef"
            )
          );
        };
      };

      config = {
        "inline" = mkOverride 1002 null;
        "valueRef" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"HTTPRoute\" or \"Service\".";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseHeader" = {

      options = {
        "add" = mkOption {
          description = "Add adds the given header(s) (name, value) to the request\nbefore the action. It appends to any existing values associated\nwith the header name.\n\nInput:\n  GET /foo HTTP/1.1\n  my-header: foo\n\nConfig:\n  add:\n  - name: \"my-header\"\n    value: \"bar,baz\"\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header: foo,bar,baz";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseHeaderAdd"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "remove" = mkOption {
          description = "Remove the given header(s) from the HTTP request before the action. The\nvalue of Remove is a list of HTTP header names. Note that the header\nnames are case-insensitive (see\nhttps://datatracker.ietf.org/doc/html/rfc2616#section-4.2).\n\nInput:\n  GET /foo HTTP/1.1\n  my-header1: foo\n  my-header2: bar\n  my-header3: baz\n\nConfig:\n  remove: [\"my-header1\", \"my-header3\"]\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header2: bar";
          type = (types.nullOr (types.listOf types.str));
        };
        "set" = mkOption {
          description = "Set overwrites the request with the given header (name, value)\nbefore the action.\n\nInput:\n  GET /foo HTTP/1.1\n  my-header: foo\n\nConfig:\n  set:\n  - name: \"my-header\"\n    value: \"bar\"\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header: bar";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseHeaderSet"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "add" = mkOverride 1002 null;
        "remove" = mkOverride 1002 null;
        "set" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseHeaderAdd" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the HTTP Header to be matched. Name matching MUST be\ncase-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).\n\nIf multiple entries specify equivalent header names, the first entry with\nan equivalent name MUST be considered for a match. Subsequent entries\nwith an equivalent header name MUST be ignored. Due to the\ncase-insensitivity of header names, \"foo\" and \"Foo\" are considered\nequivalent.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value is the value of HTTP Header to be matched.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseHeaderSet" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the HTTP Header to be matched. Name matching MUST be\ncase-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).\n\nIf multiple entries specify equivalent header names, the first entry with\nan equivalent name MUST be considered for a match. Subsequent entries\nwith an equivalent header name MUST be ignored. Due to the\ncase-insensitivity of header names, \"foo\" and \"Foo\" are considered\nequivalent.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value is the value of HTTP Header to be matched.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRetry" = {

      options = {
        "numAttemptsPerPriority" = mkOption {
          description = "NumAttemptsPerPriority defines the number of requests (initial attempt + retries)\nthat should be sent to the same priority before switching to a different one.\nIf not specified or set to 0, all requests are sent to the highest priority that is healthy.";
          type = (types.nullOr types.int);
        };
        "numRetries" = mkOption {
          description = "NumRetries is the number of retries to be attempted. Defaults to 2.";
          type = (types.nullOr types.int);
        };
        "perRetry" = mkOption {
          description = "PerRetry is the retry policy to be applied per retry attempt.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRetryPerRetry")
          );
        };
        "retryOn" = mkOption {
          description = "RetryOn specifies the retry trigger condition.\n\nIf not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRetryRetryOn")
          );
        };
      };

      config = {
        "numAttemptsPerPriority" = mkOverride 1002 null;
        "numRetries" = mkOverride 1002 null;
        "perRetry" = mkOverride 1002 null;
        "retryOn" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRetryPerRetry" = {

      options = {
        "backOff" = mkOption {
          description = "Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential\nback-off algorithm for retries. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRetryPerRetryBackOff"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout is the timeout per retry attempt.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "backOff" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRetryPerRetryBackOff" = {

      options = {
        "baseInterval" = mkOption {
          description = "BaseInterval is the base interval between retries.";
          type = (types.nullOr types.str);
        };
        "maxInterval" = mkOption {
          description = "MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.\nThe default is 10 times the base_interval";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "baseInterval" = mkOverride 1002 null;
        "maxInterval" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecRetryRetryOn" = {

      options = {
        "httpStatusCodes" = mkOption {
          description = "HttpStatusCodes specifies the http status codes to be retried.\nThe retriable-status-codes trigger must also be configured for these status codes to trigger a retry.";
          type = (types.nullOr (types.listOf types.int));
        };
        "triggers" = mkOption {
          description = "Triggers specifies the retry trigger condition(Http/Grpc).";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "httpStatusCodes" = mkOverride 1002 null;
        "triggers" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTargetRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the target resource.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the target resource.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the target resource.";
          type = types.str;
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. When\nunspecified, this targetRef targets the entire resource. In the following\nresources, SectionName is interpreted as the following:\n\n* Gateway: Listener name\n* HTTPRoute: HTTPRouteRule name\n* Service: Port name\n\nIf a SectionName is specified, but does not exist on the targeted object,\nthe Policy must fail to attach, and the policy implementation should record\na `ResolvedRefs` or similar Condition in the Policy's status.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTargetRefs" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the target resource.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the target resource.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the target resource.";
          type = types.str;
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. When\nunspecified, this targetRef targets the entire resource. In the following\nresources, SectionName is interpreted as the following:\n\n* Gateway: Listener name\n* HTTPRoute: HTTPRouteRule name\n* Service: Port name\n\nIf a SectionName is specified, but does not exist on the targeted object,\nthe Policy must fail to attach, and the policy implementation should record\na `ResolvedRefs` or similar Condition in the Policy's status.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTargetSelectors" = {

      options = {
        "group" = mkOption {
          description = "Group is the group that this selector targets. Defaults to gateway.networking.k8s.io";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the resource kind that this selector targets.";
          type = types.str;
        };
        "matchExpressions" = mkOption {
          description = "MatchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTargetSelectorsMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "MatchLabels are the set of label selectors for identifying the targeted resource";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTargetSelectorsMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTcpKeepalive" = {

      options = {
        "idleTime" = mkOption {
          description = "The duration a connection needs to be idle before keep-alive\nprobes start being sent.\nThe duration format is\nDefaults to `7200s`.";
          type = (types.nullOr types.str);
        };
        "interval" = mkOption {
          description = "The duration between keep-alive probes.\nDefaults to `75s`.";
          type = (types.nullOr types.str);
        };
        "probes" = mkOption {
          description = "The total number of unacknowledged probes to send before deciding\nthe connection is dead.\nDefaults to 9.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "idleTime" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "probes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTelemetry" = {

      options = {
        "metrics" = mkOption {
          description = "Metrics defines metrics configuration for the backend or Route.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTelemetryMetrics")
          );
        };
        "tracing" = mkOption {
          description = "Tracing configures the tracing settings for the backend or HTTPRoute.\n\nThis takes precedence over EnvoyProxy tracing when set.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTelemetryTracing")
          );
        };
      };

      config = {
        "metrics" = mkOverride 1002 null;
        "tracing" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTelemetryMetrics" = {

      options = {
        "routeStatName" = mkOption {
          description = "RouteStatName defines the value of the Route stat_prefix, determining how the route stats are named.\nFor more details, see envoy docs: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#config-route-v3-route\nThe supported operators for this pattern are:\n%ROUTE_NAME%: name of Gateway API xRoute resource\n%ROUTE_NAMESPACE%: namespace of Gateway API xRoute resource\n%ROUTE_KIND%: kind of Gateway API xRoute resource\nExample: %ROUTE_KIND%/%ROUTE_NAMESPACE%/%ROUTE_NAME% => httproute/my-ns/my-route\nDisabled by default.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "routeStatName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTelemetryTracing" = {

      options = {
        "customTags" = mkOption {
          description = "CustomTags defines the custom tags to add to each span.\nIf provider is kubernetes, pod name and namespace are added by default.\n\nDeprecated: Use Tags instead.";
          type = (types.nullOr (types.attrsOf types.attrs));
        };
        "samplingFraction" = mkOption {
          description = "SamplingFraction represents the fraction of requests that should be\nselected for tracing if no prior sampling decision has been made.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTelemetryTracingSamplingFraction"
            )
          );
        };
        "spanName" = mkOption {
          description = "SpanName defines the name of the span which will be used for tracing.\nEnvoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators) may be used in the value.\nThe [format string documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings) provides more information.\n\nIf not set, the span name is provider specific.\ne.g. Datadog use `ingress` as the default client span name,\nand `router <UPSTREAM_CLUSTER> egress` as the server span name.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTelemetryTracingSpanName"
            )
          );
        };
        "tags" = mkOption {
          description = "Tags defines the custom tags to add to each span.\nEnvoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators) may be used in the value.\nThe [format string documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings) provides more information.\nIf provider is kubernetes, pod name and namespace are added by default.\n\nSame keys take precedence over CustomTags.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "customTags" = mkOverride 1002 null;
        "samplingFraction" = mkOverride 1002 null;
        "spanName" = mkOverride 1002 null;
        "tags" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTelemetryTracingSamplingFraction" = {

      options = {
        "denominator" = mkOption {
          description = "";
          type = (types.nullOr types.int);
        };
        "numerator" = mkOption {
          description = "";
          type = types.int;
        };
      };

      config = {
        "denominator" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTelemetryTracingSpanName" = {

      options = {
        "client" = mkOption {
          description = "Client defines operation name of the span which will be used for tracing.";
          type = types.str;
        };
        "server" = mkOption {
          description = "Server defines the operation name of the upstream span which will be used for tracing.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTimeout" = {

      options = {
        "http" = mkOption {
          description = "Timeout settings for HTTP.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTimeoutHttp")
          );
        };
        "tcp" = mkOption {
          description = "Timeout settings for TCP.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTimeoutTcp")
          );
        };
      };

      config = {
        "http" = mkOverride 1002 null;
        "tcp" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTimeoutHttp" = {

      options = {
        "connectionIdleTimeout" = mkOption {
          description = "The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.\nDefault: 1 hour.";
          type = (types.nullOr types.str);
        };
        "maxConnectionDuration" = mkOption {
          description = "The maximum duration of an HTTP connection.\nDefault: unlimited.";
          type = (types.nullOr types.str);
        };
        "maxStreamDuration" = mkOption {
          description = "MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time\nfrom when the request is sent until the response stream is fully consumed and does not apply to\nnon-streaming requests.\nWhen set to \"0s\", no max duration is applied and streams can run indefinitely.";
          type = (types.nullOr types.str);
        };
        "requestTimeout" = mkOption {
          description = "RequestTimeout is the time until which entire response is received from the upstream.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "connectionIdleTimeout" = mkOverride 1002 null;
        "maxConnectionDuration" = mkOverride 1002 null;
        "maxStreamDuration" = mkOverride 1002 null;
        "requestTimeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicySpecTimeoutTcp" = {

      options = {
        "connectTimeout" = mkOption {
          description = "The timeout for network connection establishment, including TCP and TLS handshakes.\nDefault: 10 seconds.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "connectTimeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicyStatus" = {

      options = {
        "ancestors" = mkOption {
          description = "Ancestors is a list of ancestor resources (usually Gateways) that are\nassociated with the policy, and the status of the policy with respect to\neach ancestor. When this policy attaches to a parent, the controller that\nmanages the parent and the ancestors MUST add an entry to this list when\nthe controller first sees the policy and SHOULD update the entry as\nappropriate when the relevant ancestor is modified.\n\nNote that choosing the relevant ancestor is left to the Policy designers;\nan important part of Policy design is designing the right object level at\nwhich to namespace this status.\n\nNote also that implementations MUST ONLY populate ancestor status for\nthe Ancestor resources they are responsible for. Implementations MUST\nuse the ControllerName field to uniquely identify the entries in this list\nthat they are responsible for.\n\nNote that to achieve this, the list of PolicyAncestorStatus structs\nMUST be treated as a map with a composite key, made up of the AncestorRef\nand ControllerName fields combined.\n\nA maximum of 16 ancestors will be represented in this list. An empty list\nmeans the Policy is not relevant for any ancestors.\n\nIf this slice is full, implementations MUST NOT add further entries.\nInstead they MUST consider the policy unimplementable and signal that\non any related resources such as the ancestor that would be referenced\nhere. For example, if this list was full on BackendTLSPolicy, no\nadditional Gateways would be able to reference the Service targeted by\nthe BackendTLSPolicy.";
          type = (
            types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicyStatusAncestors")
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicyStatusAncestors" = {

      options = {
        "ancestorRef" = mkOption {
          description = "AncestorRef corresponds with a ParentRef in the spec that this\nPolicyAncestorStatus struct describes the status of.";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicyStatusAncestorsAncestorRef"
          );
        };
        "conditions" = mkOption {
          description = "Conditions describes the status of the Policy with respect to the given Ancestor.\n\n<gateway:util:excludeFromCRD>\n\nNotes for implementors:\n\nConditions are a listType `map`, which means that they function like a\nmap with a key of the `type` field _in the k8s apiserver_.\n\nThis means that implementations must obey some rules when updating this\nsection.\n\n* Implementations MUST perform a read-modify-write cycle on this field\n  before modifying it. That is, when modifying this field, implementations\n  must be confident they have fetched the most recent version of this field,\n  and ensure that changes they make are on that recent version.\n* Implementations MUST NOT remove or reorder Conditions that they are not\n  directly responsible for. For example, if an implementation sees a Condition\n  with type `special.io/SomeField`, it MUST NOT remove, change or update that\n  Condition.\n* Implementations MUST always _merge_ changes into Conditions of the same Type,\n  rather than creating more than one Condition of the same Type.\n* Implementations MUST always update the `observedGeneration` field of the\n  Condition to the `metadata.generation` of the Gateway at the time of update creation.\n* If the `observedGeneration` of a Condition is _greater than_ the value the\n  implementation knows about, then it MUST NOT perform the update on that Condition,\n  but must wait for a future reconciliation and status update. (The assumption is that\n  the implementation's copy of the object is stale and an update will be re-triggered\n  if relevant.)\n\n</gateway:util:excludeFromCRD>";
          type = (
            types.listOf (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicyStatusAncestorsConditions"
            )
          );
        };
        "controllerName" = mkOption {
          description = "ControllerName is a domain/path string that indicates the name of the\ncontroller that wrote this status. This corresponds with the\ncontrollerName field on GatewayClass.\n\nExample: \"example.net/gateway-controller\".\n\nThe format of this field is DOMAIN \"/\" PATH, where DOMAIN and PATH are\nvalid Kubernetes names\n(https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\n\nControllers MUST populate this field when writing status. Controllers should ensure that\nentries to status populated with their ControllerName are cleaned up when they are no\nlonger necessary.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicyStatusAncestorsAncestorRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent.\nWhen unspecified, \"gateway.networking.k8s.io\" is inferred.\nTo set the core API group (such as for a \"Service\" kind referent),\nGroup must be explicitly set to \"\" (empty string).\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent.\n\nThere are two kinds of parent resources with \"Core\" support:\n\n* Gateway (Gateway conformance profile)\n* Service (Mesh conformance profile, ClusterIP Services only)\n\nSupport for other resources is Implementation-Specific.";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.\n\nSupport: Core";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referent. When unspecified, this refers\nto the local namespace of the Route.\n\nNote that there are specific rules for ParentRefs which cross namespace\nboundaries. Cross-namespace references are only valid if they are explicitly\nallowed by something in the namespace they are referring to. For example:\nGateway has the AllowedRoutes field, and ReferenceGrant provides a\ngeneric way to enable any other kind of cross-namespace reference.\n\n<gateway:experimental:description>\nParentRefs from a Route to a Service in the same namespace are \"producer\"\nroutes, which apply default routing rules to inbound connections from\nany namespace to the Service.\n\nParentRefs from a Route to a Service in a different namespace are\n\"consumer\" routes, and these routing rules are only applied to outbound\nconnections originating from the same namespace as the Route, for which\nthe intended destination of the connections are a Service targeted as a\nParentRef of the Route.\n</gateway:experimental:description>\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port is the network port this Route targets. It can be interpreted\ndifferently based on the type of parent resource.\n\nWhen the parent resource is a Gateway, this targets all listeners\nlistening on the specified port that also support this kind of Route(and\nselect this Route). It's not recommended to set `Port` unless the\nnetworking behaviors specified in a Route must apply to a specific port\nas opposed to a listener(s) whose port(s) may be changed. When both Port\nand SectionName are specified, the name and port of the selected listener\nmust match both specified values.\n\n<gateway:experimental:description>\nWhen the parent resource is a Service, this targets a specific port in the\nService spec. When both Port (experimental) and SectionName are specified,\nthe name and port of the selected port must match both specified values.\n</gateway:experimental:description>\n\nImplementations MAY choose to support other parent resources.\nImplementations supporting other types of parent resources MUST clearly\ndocument how/if Port is interpreted.\n\nFor the purpose of status, an attachment is considered successful as\nlong as the parent resource accepts it partially. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment\nfrom the referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route,\nthe Route MUST be considered detached from the Gateway.\n\nSupport: Extended";
          type = (types.nullOr types.int);
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. In the\nfollowing resources, SectionName is interpreted as the following:\n\n* Gateway: Listener name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n* Service: Port name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n\nImplementations MAY choose to support attaching Routes to other resources.\nIf that is the case, they MUST clearly document how SectionName is\ninterpreted.\n\nWhen unspecified (empty string), this will reference the entire resource.\nFor the purpose of status, an attachment is considered successful if at\nleast one section in the parent resource accepts it. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment from\nthe referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route, the\nRoute MUST be considered detached from the Gateway.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicyStatusAncestorsConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = types.str;
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "type of condition in CamelCase or in foo.example.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicy" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "Spec defines the desired state of ClientTrafficPolicy.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpec");
        };
        "status" = mkOption {
          description = "Status defines the current status of ClientTrafficPolicy.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicyStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpec" = {

      options = {
        "clientIPDetection" = mkOption {
          description = "ClientIPDetectionSettings provides configuration for determining the original client IP address for requests.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecClientIPDetection")
          );
        };
        "connection" = mkOption {
          description = "Connection includes client connection settings.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecConnection")
          );
        };
        "enableProxyProtocol" = mkOption {
          description = "EnableProxyProtocol interprets the ProxyProtocol header and adds the\nClient Address into the X-Forwarded-For header.\nNote Proxy Protocol must be present when this field is set, else the connection\nis closed.\n\nDeprecated: Use ProxyProtocol instead.";
          type = (types.nullOr types.bool);
        };
        "headers" = mkOption {
          description = "HeaderSettings provides configuration for header management.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeaders"));
        };
        "healthCheck" = mkOption {
          description = "HealthCheck provides configuration for determining whether the HTTP/HTTPS listener is healthy.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHealthCheck")
          );
        };
        "http1" = mkOption {
          description = "HTTP1 provides HTTP/1 configuration on the listener.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHttp1"));
        };
        "http2" = mkOption {
          description = "HTTP2 provides HTTP/2 configuration on the listener.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHttp2"));
        };
        "http3" = mkOption {
          description = "HTTP3 provides HTTP/3 configuration on the listener.";
          type = (types.nullOr types.attrs);
        };
        "path" = mkOption {
          description = "Path enables managing how the incoming path set by clients can be normalized.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecPath"));
        };
        "proxyProtocol" = mkOption {
          description = "ProxyProtocol configures the Proxy Protocol settings. When configured,\nthe Proxy Protocol header will be interpreted and the Client Address\nwill be added into the X-Forwarded-For header.\nIf both EnableProxyProtocol and ProxyProtocol are set, ProxyProtocol takes precedence.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecProxyProtocol")
          );
        };
        "scheme" = mkOption {
          description = "Scheme configures how the :scheme pseudo-header is set for requests forwarded to backends.\n\n- Preserve (default): Preserves the :scheme from the original client request.\n  Use this when backends need to know the original client scheme for URL generation or redirects.\n\n- MatchBackend: Sets the :scheme to match the backend transport protocol.\n  If the backend uses TLS, the scheme is \"https\", otherwise \"http\".\n  Use this when backends require the scheme to match the actual transport protocol,\n  such as strictly HTTPS services that validate the :scheme header.";
          type = (types.nullOr types.str);
        };
        "targetRef" = mkOption {
          description = "TargetRef is the name of the resource this policy is being attached to.\nThis policy and the TargetRef MUST be in the same namespace for this\nPolicy to have effect\n\nDeprecated: use targetRefs/targetSelectors instead";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTargetRef")
          );
        };
        "targetRefs" = mkOption {
          description = "TargetRefs are the names of the Gateway resources this policy\nis being attached to.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTargetRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "targetSelectors" = mkOption {
          description = "TargetSelectors allow targeting resources for this policy based on labels";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTargetSelectors")
            )
          );
        };
        "tcpKeepalive" = mkOption {
          description = "TcpKeepalive settings associated with the downstream client connection.\nIf defined, sets SO_KEEPALIVE on the listener socket to enable TCP Keepalives.\nDisabled by default.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTcpKeepalive")
          );
        };
        "timeout" = mkOption {
          description = "Timeout settings for the client connections.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTimeout"));
        };
        "tls" = mkOption {
          description = "TLS settings configure TLS termination settings with the downstream client.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTls"));
        };
      };

      config = {
        "clientIPDetection" = mkOverride 1002 null;
        "connection" = mkOverride 1002 null;
        "enableProxyProtocol" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "healthCheck" = mkOverride 1002 null;
        "http1" = mkOverride 1002 null;
        "http2" = mkOverride 1002 null;
        "http3" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
        "proxyProtocol" = mkOverride 1002 null;
        "scheme" = mkOverride 1002 null;
        "targetRef" = mkOverride 1002 null;
        "targetRefs" = mkOverride 1002 null;
        "targetSelectors" = mkOverride 1002 null;
        "tcpKeepalive" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
        "tls" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecClientIPDetection" = {

      options = {
        "customHeader" = mkOption {
          description = "CustomHeader provides configuration for determining the client IP address for a request based on\na trusted custom HTTP header. This uses the custom_header original IP detection extension.\nRefer to https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/http/original_ip_detection/custom_header/v3/custom_header.proto\nfor more details.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecClientIPDetectionCustomHeader"
            )
          );
        };
        "xForwardedFor" = mkOption {
          description = "XForwardedForSettings provides configuration for using X-Forwarded-For headers for determining the client IP address.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecClientIPDetectionXForwardedFor"
            )
          );
        };
      };

      config = {
        "customHeader" = mkOverride 1002 null;
        "xForwardedFor" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecClientIPDetectionCustomHeader" = {

      options = {
        "failClosed" = mkOption {
          description = "FailClosed is a switch used to control the flow of traffic when client IP detection\nfails. If set to true, the listener will respond with 403 Forbidden when the client\nIP address cannot be determined.";
          type = (types.nullOr types.bool);
        };
        "name" = mkOption {
          description = "Name of the header containing the original downstream remote address, if present.";
          type = types.str;
        };
      };

      config = {
        "failClosed" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecClientIPDetectionXForwardedFor" = {

      options = {
        "numTrustedHops" = mkOption {
          description = "NumTrustedHops specifies how many trusted hops to count from the rightmost side of\nthe X-Forwarded-For (XFF) header when determining the original client’s IP address.\n\nIf NumTrustedHops is set to N, the client IP is taken from the Nth address from the\nright end of the XFF header.\n\nExample:\n  XFF = \"203.0.113.128, 203.0.113.10, 203.0.113.1\"\n  NumTrustedHops = 2\n  → Trusted client address = 203.0.113.10\n\nOnly one of NumTrustedHops or TrustedCIDRs should be configured.";
          type = (types.nullOr types.int);
        };
        "trustedCIDRs" = mkOption {
          description = "TrustedCIDRs is a list of CIDR ranges to trust when evaluating\nthe remote IP address to determine the original client’s IP address.\nWhen the remote IP address matches a trusted CIDR and the x-forwarded-for header was sent,\neach entry in the x-forwarded-for header is evaluated from right to left\nand the first public non-trusted address is used as the original client address.\nIf all addresses in x-forwarded-for are within the trusted list, the first (leftmost) entry is used.\nOnly one of NumTrustedHops and TrustedCIDRs must be set.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "numTrustedHops" = mkOverride 1002 null;
        "trustedCIDRs" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecConnection" = {

      options = {
        "bufferLimit" = mkOption {
          description = "BufferLimit provides configuration for the maximum buffer size in bytes for each incoming connection.\nBufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote that when the suffix is not provided, the value is interpreted as bytes.\nDefault: 32768 bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "connectionLimit" = mkOption {
          description = "ConnectionLimit defines limits related to connections";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecConnectionConnectionLimit"
            )
          );
        };
        "maxAcceptPerSocketEvent" = mkOption {
          description = "MaxAcceptPerSocketEvent provides configuration for the maximum number of connections to accept from the kernel\nper socket event. If there are more than MaxAcceptPerSocketEvent connections pending accept, connections over\nthis threshold will be accepted in later event loop iterations.\nDefaults to 1 and can be disabled by setting to 0 for allowing unlimited accepted connections.";
          type = (types.nullOr types.int);
        };
        "socketBufferLimit" = mkOption {
          description = "SocketBufferLimit provides configuration for the maximum buffer size in bytes for each incoming socket.\nSocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote that when the suffix is not provided, the value is interpreted as bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "bufferLimit" = mkOverride 1002 null;
        "connectionLimit" = mkOverride 1002 null;
        "maxAcceptPerSocketEvent" = mkOverride 1002 null;
        "socketBufferLimit" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecConnectionConnectionLimit" = {

      options = {
        "closeDelay" = mkOption {
          description = "CloseDelay defines the delay to use before closing connections that are rejected\nonce the limit value is reached.\nDefault: none.";
          type = (types.nullOr types.str);
        };
        "maxConnectionDuration" = mkOption {
          description = "MaxConnectionDuration is the maximum amount of time a connection can remain established\n(usually via TCP/HTTP Keepalive packets) before being drained and/or closed.\nIf not specified, there is no limit.";
          type = (types.nullOr types.str);
        };
        "maxRequestsPerConnection" = mkOption {
          description = "MaxRequestsPerConnection defines the maximum number of requests allowed over a single connection.\nIf not specified, there is no limit. Setting this parameter to 1 will effectively disable keep alive.";
          type = (types.nullOr types.int);
        };
        "maxStreamDuration" = mkOption {
          description = "MaxStreamDuration is the maximum amount of time to keep alive an http stream. When the limit is reached\nthe stream will be reset independent of any other timeouts. If not specified, no value is set.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value of the maximum concurrent connections limit.\nWhen the limit is reached, incoming connections will be closed after the CloseDelay duration.";
          type = types.int;
        };
      };

      config = {
        "closeDelay" = mkOverride 1002 null;
        "maxConnectionDuration" = mkOverride 1002 null;
        "maxRequestsPerConnection" = mkOverride 1002 null;
        "maxStreamDuration" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeaders" = {

      options = {
        "disableRateLimitHeaders" = mkOption {
          description = "DisableRateLimitHeaders configures Envoy Proxy to omit the \"X-RateLimit-\" response headers\nwhen rate limiting is enabled.";
          type = (types.nullOr types.bool);
        };
        "earlyRequestHeaders" = mkOption {
          description = "EarlyRequestHeaders defines settings for early request header modification, before envoy performs\nrouting, tracing and built-in header manipulation.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeaders"
            )
          );
        };
        "enableEnvoyHeaders" = mkOption {
          description = "EnableEnvoyHeaders configures Envoy Proxy to add the \"X-Envoy-\" headers to requests\nand responses.";
          type = (types.nullOr types.bool);
        };
        "lateResponseHeaders" = mkOption {
          description = "LateResponseHeaders defines settings for global response header modification.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersLateResponseHeaders"
            )
          );
        };
        "preserveXRequestID" = mkOption {
          description = "PreserveXRequestID configures Envoy to keep the X-Request-ID header if passed for a request that is edge\n(Edge request is the request from external clients to front Envoy) and not reset it, which is the current Envoy behaviour.\nDefaults to false and cannot be combined with RequestID.\nDeprecated: use RequestID=PreserveOrGenerate instead";
          type = (types.nullOr types.bool);
        };
        "requestID" = mkOption {
          description = "RequestID configures Envoy's behavior for handling the `X-Request-ID` header.\nWhen omitted default behavior is `Generate` which builds the `X-Request-ID` for every request\n and ignores pre-existing values from the edge.\n(An \"edge request\" refers to a request from an external client to the Envoy entrypoint.)";
          type = (types.nullOr types.str);
        };
        "withUnderscoresAction" = mkOption {
          description = "WithUnderscoresAction configures the action to take when an HTTP header with underscores\nis encountered. The default action is to reject the request.";
          type = (types.nullOr types.str);
        };
        "xForwardedClientCert" = mkOption {
          description = "XForwardedClientCert configures how Envoy Proxy handle the x-forwarded-client-cert (XFCC) HTTP header.\n\nx-forwarded-client-cert (XFCC) is an HTTP header used to forward the certificate\ninformation of part or all of the clients or proxies that a request has flowed through,\non its way from the client to the server.\n\nEnvoy proxy may choose to sanitize/append/forward the XFCC header before proxying the request.\n\nIf not set, the default behavior is sanitizing the XFCC header.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersXForwardedClientCert"
            )
          );
        };
      };

      config = {
        "disableRateLimitHeaders" = mkOverride 1002 null;
        "earlyRequestHeaders" = mkOverride 1002 null;
        "enableEnvoyHeaders" = mkOverride 1002 null;
        "lateResponseHeaders" = mkOverride 1002 null;
        "preserveXRequestID" = mkOverride 1002 null;
        "requestID" = mkOverride 1002 null;
        "withUnderscoresAction" = mkOverride 1002 null;
        "xForwardedClientCert" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeaders" = {

      options = {
        "add" = mkOption {
          description = "Add adds the given header(s) (name, value) to the request\nbefore the action. It appends to any existing values associated\nwith the header name.\n\nInput:\n  GET /foo HTTP/1.1\n  my-header: foo\n\nConfig:\n  add:\n  - name: \"my-header\"\n    value: \"bar,baz\"\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header: foo,bar,baz";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeadersAdd"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "addIfAbsent" = mkOption {
          description = "AddIfAbsent adds the given header(s) (name, value) to the request/response\nonly if the header does not already exist. Unlike Add which appends to\nexisting values, this is a no-op if the header is already present.\n\nInput:\n  GET /foo HTTP/1.1\n  my-header: foo\n\nConfig:\n  addIfAbsent:\n  - name: \"my-header\"\n    value: \"bar\"\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header: foo";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeadersAddIfAbsent"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "remove" = mkOption {
          description = "Remove the given header(s) from the HTTP request before the action. The\nvalue of Remove is a list of HTTP header names. Note that the header\nnames are case-insensitive (see\nhttps://datatracker.ietf.org/doc/html/rfc2616#section-4.2).\n\nInput:\n  GET /foo HTTP/1.1\n  my-header1: foo\n  my-header2: bar\n  my-header3: baz\n\nConfig:\n  remove: [\"my-header1\", \"my-header3\"]\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header2: bar";
          type = (types.nullOr (types.listOf types.str));
        };
        "removeOnMatch" = mkOption {
          description = "RemoveOnMatch removes headers whose names match the specified string matchers.\nMatching is performed on the header name (case-insensitive).";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeadersRemoveOnMatch"
              )
            )
          );
        };
        "set" = mkOption {
          description = "Set overwrites the request with the given header (name, value)\nbefore the action.\n\nInput:\n  GET /foo HTTP/1.1\n  my-header: foo\n\nConfig:\n  set:\n  - name: \"my-header\"\n    value: \"bar\"\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header: bar";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeadersSet"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "add" = mkOverride 1002 null;
        "addIfAbsent" = mkOverride 1002 null;
        "remove" = mkOverride 1002 null;
        "removeOnMatch" = mkOverride 1002 null;
        "set" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeadersAdd" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the HTTP Header to be matched. Name matching MUST be\ncase-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).\n\nIf multiple entries specify equivalent header names, the first entry with\nan equivalent name MUST be considered for a match. Subsequent entries\nwith an equivalent header name MUST be ignored. Due to the\ncase-insensitivity of header names, \"foo\" and \"Foo\" are considered\nequivalent.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value is the value of HTTP Header to be matched.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeadersAddIfAbsent" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the HTTP Header to be matched. Name matching MUST be\ncase-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).\n\nIf multiple entries specify equivalent header names, the first entry with\nan equivalent name MUST be considered for a match. Subsequent entries\nwith an equivalent header name MUST be ignored. Due to the\ncase-insensitivity of header names, \"foo\" and \"Foo\" are considered\nequivalent.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value is the value of HTTP Header to be matched.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeadersRemoveOnMatch" = {

      options = {
        "type" = mkOption {
          description = "Type specifies how to match against a string.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value specifies the string value that the match must have.";
          type = types.str;
        };
      };

      config = {
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeadersSet" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the HTTP Header to be matched. Name matching MUST be\ncase-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).\n\nIf multiple entries specify equivalent header names, the first entry with\nan equivalent name MUST be considered for a match. Subsequent entries\nwith an equivalent header name MUST be ignored. Due to the\ncase-insensitivity of header names, \"foo\" and \"Foo\" are considered\nequivalent.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value is the value of HTTP Header to be matched.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersLateResponseHeaders" = {

      options = {
        "add" = mkOption {
          description = "Add adds the given header(s) (name, value) to the request\nbefore the action. It appends to any existing values associated\nwith the header name.\n\nInput:\n  GET /foo HTTP/1.1\n  my-header: foo\n\nConfig:\n  add:\n  - name: \"my-header\"\n    value: \"bar,baz\"\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header: foo,bar,baz";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersLateResponseHeadersAdd"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "addIfAbsent" = mkOption {
          description = "AddIfAbsent adds the given header(s) (name, value) to the request/response\nonly if the header does not already exist. Unlike Add which appends to\nexisting values, this is a no-op if the header is already present.\n\nInput:\n  GET /foo HTTP/1.1\n  my-header: foo\n\nConfig:\n  addIfAbsent:\n  - name: \"my-header\"\n    value: \"bar\"\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header: foo";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersLateResponseHeadersAddIfAbsent"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "remove" = mkOption {
          description = "Remove the given header(s) from the HTTP request before the action. The\nvalue of Remove is a list of HTTP header names. Note that the header\nnames are case-insensitive (see\nhttps://datatracker.ietf.org/doc/html/rfc2616#section-4.2).\n\nInput:\n  GET /foo HTTP/1.1\n  my-header1: foo\n  my-header2: bar\n  my-header3: baz\n\nConfig:\n  remove: [\"my-header1\", \"my-header3\"]\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header2: bar";
          type = (types.nullOr (types.listOf types.str));
        };
        "removeOnMatch" = mkOption {
          description = "RemoveOnMatch removes headers whose names match the specified string matchers.\nMatching is performed on the header name (case-insensitive).";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersLateResponseHeadersRemoveOnMatch"
              )
            )
          );
        };
        "set" = mkOption {
          description = "Set overwrites the request with the given header (name, value)\nbefore the action.\n\nInput:\n  GET /foo HTTP/1.1\n  my-header: foo\n\nConfig:\n  set:\n  - name: \"my-header\"\n    value: \"bar\"\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header: bar";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersLateResponseHeadersSet"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "add" = mkOverride 1002 null;
        "addIfAbsent" = mkOverride 1002 null;
        "remove" = mkOverride 1002 null;
        "removeOnMatch" = mkOverride 1002 null;
        "set" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersLateResponseHeadersAdd" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the HTTP Header to be matched. Name matching MUST be\ncase-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).\n\nIf multiple entries specify equivalent header names, the first entry with\nan equivalent name MUST be considered for a match. Subsequent entries\nwith an equivalent header name MUST be ignored. Due to the\ncase-insensitivity of header names, \"foo\" and \"Foo\" are considered\nequivalent.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value is the value of HTTP Header to be matched.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersLateResponseHeadersAddIfAbsent" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the HTTP Header to be matched. Name matching MUST be\ncase-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).\n\nIf multiple entries specify equivalent header names, the first entry with\nan equivalent name MUST be considered for a match. Subsequent entries\nwith an equivalent header name MUST be ignored. Due to the\ncase-insensitivity of header names, \"foo\" and \"Foo\" are considered\nequivalent.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value is the value of HTTP Header to be matched.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersLateResponseHeadersRemoveOnMatch" = {

      options = {
        "type" = mkOption {
          description = "Type specifies how to match against a string.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value specifies the string value that the match must have.";
          type = types.str;
        };
      };

      config = {
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersLateResponseHeadersSet" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the HTTP Header to be matched. Name matching MUST be\ncase-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).\n\nIf multiple entries specify equivalent header names, the first entry with\nan equivalent name MUST be considered for a match. Subsequent entries\nwith an equivalent header name MUST be ignored. Due to the\ncase-insensitivity of header names, \"foo\" and \"Foo\" are considered\nequivalent.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value is the value of HTTP Header to be matched.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHeadersXForwardedClientCert" = {

      options = {
        "certDetailsToAdd" = mkOption {
          description = "CertDetailsToAdd specifies the fields in the client certificate to be forwarded in the XFCC header.\n\nHash(the SHA 256 digest of the current client certificate) and By(the Subject Alternative Name)\nare always included if the client certificate is forwarded.\n\nThis field is only applicable when the mode is set to `AppendForward` or\n`SanitizeSet` and the client connection is mTLS.";
          type = (types.nullOr (types.listOf types.str));
        };
        "mode" = mkOption {
          description = "Mode defines how XFCC header is handled by Envoy Proxy.\nIf not set, the default mode is `Sanitize`.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "certDetailsToAdd" = mkOverride 1002 null;
        "mode" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHealthCheck" = {

      options = {
        "path" = mkOption {
          description = "Path specifies the HTTP path to match on for health check requests.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHttp1" = {

      options = {
        "disableSafeMaxConnectionDuration" = mkOption {
          description = "DisableSafeMaxConnectionDuration controls the close behavior for HTTP/1 connections.\nBy default, connection closure is delayed until the next request arrives after maxConnectionDuration is exceeded.\nIt then adds a Connection: close header and gracefully closes the connection after the response completes.\nWhen set to true (disabled), Envoy uses its default drain behavior, closing the connection shortly after maxConnectionDuration elapses.\nHas no effect unless maxConnectionDuration is set.";
          type = (types.nullOr types.bool);
        };
        "enableTrailers" = mkOption {
          description = "EnableTrailers defines if HTTP/1 trailers should be proxied by Envoy.";
          type = (types.nullOr types.bool);
        };
        "http10" = mkOption {
          description = "HTTP10 turns on support for HTTP/1.0 and HTTP/0.9 requests.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHttp1Http10")
          );
        };
        "preserveHeaderCase" = mkOption {
          description = "PreserveHeaderCase defines if Envoy should preserve the letter case of headers.\nBy default, Envoy will lowercase all the headers.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "disableSafeMaxConnectionDuration" = mkOverride 1002 null;
        "enableTrailers" = mkOverride 1002 null;
        "http10" = mkOverride 1002 null;
        "preserveHeaderCase" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHttp1Http10" = {

      options = {
        "useDefaultHost" = mkOption {
          description = "UseDefaultHost specifies whether a default Host header should be injected\ninto HTTP/1.0 requests that do not include one.\n\nWhen set to true, Envoy Gateway injects the hostname associated with the\nlistener or route into the request, in the following order:\n\n  1. If the targeted listener has a non-wildcard hostname, use that hostname.\n  2. If there is exactly one HTTPRoute with a non-wildcard hostname under\n     the targeted listener, use that hostname.\n\n Note: Setting this field to true without a non-wildcard hostname makes the\nClientTrafficPolicy invalid.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "useDefaultHost" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecHttp2" = {

      options = {
        "initialConnectionWindowSize" = mkOption {
          description = "InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.\nIf not set, the default value is 1 MiB.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "initialStreamWindowSize" = mkOption {
          description = "InitialStreamWindowSize sets the initial window size for HTTP/2 streams.\nIf not set, the default value is 64 KiB(64*1024).";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxConcurrentStreams" = mkOption {
          description = "MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.\nIf not set, the default value is 100.";
          type = (types.nullOr types.int);
        };
        "onInvalidMessage" = mkOption {
          description = "OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error\nIt's recommended for L2 Envoy deployments to set this value to TerminateStream.\nhttps://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two\nDefault: TerminateConnection";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "initialConnectionWindowSize" = mkOverride 1002 null;
        "initialStreamWindowSize" = mkOverride 1002 null;
        "maxConcurrentStreams" = mkOverride 1002 null;
        "onInvalidMessage" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecPath" = {

      options = {
        "disableMergeSlashes" = mkOption {
          description = "DisableMergeSlashes allows disabling the default configuration of merging adjacent\nslashes in the path.\nNote that slash merging is not part of the HTTP spec and is provided for convenience.";
          type = (types.nullOr types.bool);
        };
        "escapedSlashesAction" = mkOption {
          description = "EscapedSlashesAction determines how %2f, %2F, %5c, or %5C sequences in the path URI\nshould be handled.\nThe default is UnescapeAndRedirect.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "disableMergeSlashes" = mkOverride 1002 null;
        "escapedSlashesAction" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecProxyProtocol" = {

      options = {
        "optional" = mkOption {
          description = "Optional allows requests without a Proxy Protocol header to be proxied.\nIf set to true, the listener will accept requests without a Proxy Protocol header.\nIf set to false, the listener will reject requests without a Proxy Protocol header.\nIf not set, the default behavior is to reject requests without a Proxy Protocol header.\nWarning: Optional breaks conformance with the specification. Only enable if ALL traffic to the listener comes from a trusted source.\nFor more information on security implications, see haproxy.org/download/2.1/doc/proxy-protocol.txt";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "optional" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTargetRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the target resource.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the target resource.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the target resource.";
          type = types.str;
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. When\nunspecified, this targetRef targets the entire resource. In the following\nresources, SectionName is interpreted as the following:\n\n* Gateway: Listener name\n* HTTPRoute: HTTPRouteRule name\n* Service: Port name\n\nIf a SectionName is specified, but does not exist on the targeted object,\nthe Policy must fail to attach, and the policy implementation should record\na `ResolvedRefs` or similar Condition in the Policy's status.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTargetRefs" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the target resource.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the target resource.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the target resource.";
          type = types.str;
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. When\nunspecified, this targetRef targets the entire resource. In the following\nresources, SectionName is interpreted as the following:\n\n* Gateway: Listener name\n* HTTPRoute: HTTPRouteRule name\n* Service: Port name\n\nIf a SectionName is specified, but does not exist on the targeted object,\nthe Policy must fail to attach, and the policy implementation should record\na `ResolvedRefs` or similar Condition in the Policy's status.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTargetSelectors" = {

      options = {
        "group" = mkOption {
          description = "Group is the group that this selector targets. Defaults to gateway.networking.k8s.io";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the resource kind that this selector targets.";
          type = types.str;
        };
        "matchExpressions" = mkOption {
          description = "MatchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTargetSelectorsMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "MatchLabels are the set of label selectors for identifying the targeted resource";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTargetSelectorsMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTcpKeepalive" = {

      options = {
        "idleTime" = mkOption {
          description = "The duration a connection needs to be idle before keep-alive\nprobes start being sent.\nThe duration format is\nDefaults to `7200s`.";
          type = (types.nullOr types.str);
        };
        "interval" = mkOption {
          description = "The duration between keep-alive probes.\nDefaults to `75s`.";
          type = (types.nullOr types.str);
        };
        "probes" = mkOption {
          description = "The total number of unacknowledged probes to send before deciding\nthe connection is dead.\nDefaults to 9.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "idleTime" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "probes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTimeout" = {

      options = {
        "http" = mkOption {
          description = "Timeout settings for HTTP.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTimeoutHttp")
          );
        };
        "tcp" = mkOption {
          description = "Timeout settings for TCP.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTimeoutTcp")
          );
        };
      };

      config = {
        "http" = mkOverride 1002 null;
        "tcp" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTimeoutHttp" = {

      options = {
        "idleTimeout" = mkOption {
          description = "IdleTimeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.\nDefault: 1 hour.";
          type = (types.nullOr types.str);
        };
        "requestReceivedTimeout" = mkOption {
          description = "RequestReceivedTimeout is the duration envoy waits for the complete request reception. This timer starts upon request\ninitiation and stops when either the last byte of the request is sent upstream or when the response begins.";
          type = (types.nullOr types.str);
        };
        "streamIdleTimeout" = mkOption {
          description = " The stream idle timeout defines the amount of time a stream can exist without any upstream or downstream activity.\n Default: 5 minutes.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "idleTimeout" = mkOverride 1002 null;
        "requestReceivedTimeout" = mkOverride 1002 null;
        "streamIdleTimeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTimeoutTcp" = {

      options = {
        "idleTimeout" = mkOption {
          description = "IdleTimeout for a TCP connection. Idle time is defined as a period in which there are no\nbytes sent or received on either the upstream or downstream connection.\nDefault: 1 hour.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "idleTimeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTls" = {

      options = {
        "alpnProtocols" = mkOption {
          description = "ALPNProtocols supplies the list of ALPN protocols that should be\nexposed by the listener or used by the proxy to connect to the backend.\nDefaults:\n1. HTTPS Routes: h2 and http/1.1 are enabled in listener context.\n2. Other Routes: ALPN is disabled.\n3. Backends: proxy uses the appropriate ALPN options for the backend protocol.\nWhen an empty list is provided, the ALPN TLS extension is disabled.\n\nDefaults to [h2, http/1.1] if not specified.\n\nTypical Supported values are:\n- http/1.0\n- http/1.1\n- h2";
          type = (types.nullOr (types.listOf types.str));
        };
        "ciphers" = mkOption {
          description = "Ciphers specifies the set of cipher suites supported when\nnegotiating TLS 1.0 - 1.2. This setting has no effect for TLS 1.3.\nIn non-FIPS Envoy Proxy builds the default cipher list is:\n- [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]\n- [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]\n- ECDHE-ECDSA-AES256-GCM-SHA384\n- ECDHE-RSA-AES256-GCM-SHA384\nIn builds using BoringSSL FIPS the default cipher list is:\n- ECDHE-ECDSA-AES128-GCM-SHA256\n- ECDHE-RSA-AES128-GCM-SHA256\n- ECDHE-ECDSA-AES256-GCM-SHA384\n- ECDHE-RSA-AES256-GCM-SHA384";
          type = (types.nullOr (types.listOf types.str));
        };
        "clientValidation" = mkOption {
          description = "ClientValidation specifies the configuration to validate the client\ninitiating the TLS connection to the Gateway listener.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidation"
            )
          );
        };
        "ecdhCurves" = mkOption {
          description = "ECDHCurves specifies the set of supported ECDH curves.\nIn non-FIPS Envoy Proxy builds the default curves are:\n- X25519\n- P-256\nIn builds using BoringSSL FIPS the default curve is:\n- P-256";
          type = (types.nullOr (types.listOf types.str));
        };
        "maxVersion" = mkOption {
          description = "Max specifies the maximal TLS protocol version to allow\nThe default is TLS 1.3 if this is not specified.";
          type = (types.nullOr types.str);
        };
        "minVersion" = mkOption {
          description = "Min specifies the minimal TLS protocol version to allow.\nThe default is TLS 1.2 if this is not specified.";
          type = (types.nullOr types.str);
        };
        "session" = mkOption {
          description = "Session defines settings related to TLS session management.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsSession")
          );
        };
        "signatureAlgorithms" = mkOption {
          description = "SignatureAlgorithms specifies which signature algorithms the listener should\nsupport.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "alpnProtocols" = mkOverride 1002 null;
        "ciphers" = mkOverride 1002 null;
        "clientValidation" = mkOverride 1002 null;
        "ecdhCurves" = mkOverride 1002 null;
        "maxVersion" = mkOverride 1002 null;
        "minVersion" = mkOverride 1002 null;
        "session" = mkOverride 1002 null;
        "signatureAlgorithms" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidation" = {

      options = {
        "caCertificateRefs" = mkOption {
          description = "CACertificateRefs contains one or more references to\nKubernetes objects that contain TLS certificates of\nthe Certificate Authorities that can be used\nas a trust anchor to validate the certificates presented by the client.\n\nA single reference to a Kubernetes ConfigMap or a Kubernetes Secret,\nwith the CA certificate in a key named `ca.crt` is currently supported.\n\nReferences to a resource in different namespace are invalid UNLESS there\nis a ReferenceGrant in the target namespace that allows the certificate\nto be attached.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "certificateHashes" = mkOption {
          description = "An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will\nverify that the SHA-256 of the DER-encoded presented certificate matches\none of the specified values.";
          type = (types.nullOr (types.listOf types.str));
        };
        "crl" = mkOption {
          description = "Crl specifies the crl configuration that can be used to validate the client initiating the TLS connection";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationCrl"
            )
          );
        };
        "optional" = mkOption {
          description = "Optional set to true accepts connections even when a client doesn't present a certificate.\nDefaults to false, which rejects connections without a valid client certificate.";
          type = (types.nullOr types.bool);
        };
        "spkiHashes" = mkOption {
          description = "An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will\nverify that the SHA-256 of the DER-encoded Subject Public Key Information\n(SPKI) of the presented certificate matches one of the specified values.";
          type = (types.nullOr (types.listOf types.str));
        };
        "subjectAltNames" = mkOption {
          description = "An optional list of Subject Alternative name matchers. If specified, Envoy\nwill verify that the Subject Alternative Name of the presented certificate\nmatches one of the specified matchers";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNames"
            )
          );
        };
      };

      config = {
        "caCertificateRefs" = mkOverride 1002 null;
        "certificateHashes" = mkOverride 1002 null;
        "crl" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
        "spkiHashes" = mkOverride 1002 null;
        "subjectAltNames" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"Secret\".";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referenced object. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationCrl" = {

      options = {
        "onlyVerifyLeafCertificate" = mkOption {
          description = "If this option is set to true,  Envoy will only verify the certificate at the end of the certificate chain against the CRL.\nDefaults to false, which will verify the entire certificate chain against the CRL.";
          type = (types.nullOr types.bool);
        };
        "refs" = mkOption {
          description = "Refs contains one or more references to a Kubernetes ConfigMap or a Kubernetes Secret,\ncontaining the certificate revocation list in PEM format\nExpects the content in a key named `ca.crl`.\n\nReferences to a resource in different namespace are invalid UNLESS there\nis a ReferenceGrant in the target namespace that allows the crl\nto be attached.";
          type = (
            coerceAttrsOfSubmodulesToListByKey
              "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationCrlRefs"
              "name"
              [ ]
          );
          apply = attrsToList;
        };
      };

      config = {
        "onlyVerifyLeafCertificate" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationCrlRefs" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"Secret\".";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referenced object. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNames" = {

      options = {
        "dnsNames" = mkOption {
          description = "DNS names matchers";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNames"
              )
            )
          );
        };
        "emailAddresses" = mkOption {
          description = "Email addresses matchers";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddresses"
              )
            )
          );
        };
        "ipAddresses" = mkOption {
          description = "IP addresses matchers";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddresses"
              )
            )
          );
        };
        "otherNames" = mkOption {
          description = "Other names matchers";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames"
              )
            )
          );
        };
        "uris" = mkOption {
          description = "URIs matchers";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUris"
              )
            )
          );
        };
      };

      config = {
        "dnsNames" = mkOverride 1002 null;
        "emailAddresses" = mkOverride 1002 null;
        "ipAddresses" = mkOverride 1002 null;
        "otherNames" = mkOverride 1002 null;
        "uris" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNames" =
      {

        options = {
          "type" = mkOption {
            description = "Type specifies how to match against a string.";
            type = (types.nullOr types.str);
          };
          "value" = mkOption {
            description = "Value specifies the string value that the match must have.";
            type = types.str;
          };
        };

        config = {
          "type" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddresses" =
      {

        options = {
          "type" = mkOption {
            description = "Type specifies how to match against a string.";
            type = (types.nullOr types.str);
          };
          "value" = mkOption {
            description = "Value specifies the string value that the match must have.";
            type = types.str;
          };
        };

        config = {
          "type" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddresses" =
      {

        options = {
          "type" = mkOption {
            description = "Type specifies how to match against a string.";
            type = (types.nullOr types.str);
          };
          "value" = mkOption {
            description = "Value specifies the string value that the match must have.";
            type = types.str;
          };
        };

        config = {
          "type" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames" =
      {

        options = {
          "oid" = mkOption {
            description = "OID Value";
            type = types.str;
          };
          "type" = mkOption {
            description = "Type specifies how to match against a string.";
            type = (types.nullOr types.str);
          };
          "value" = mkOption {
            description = "Value specifies the string value that the match must have.";
            type = types.str;
          };
        };

        config = {
          "type" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUris" = {

      options = {
        "type" = mkOption {
          description = "Type specifies how to match against a string.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value specifies the string value that the match must have.";
          type = types.str;
        };
      };

      config = {
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsSession" = {

      options = {
        "resumption" = mkOption {
          description = "Resumption determines the proxy's supported TLS session resumption option.\nBy default, Envoy Gateway does not enable session resumption. Use sessionResumption to\nenable stateful and stateless session resumption. Users should consider security impacts\nof different resumption methods. Performance gains from resumption are diminished when\nEnvoy proxy is deployed with more than one replica.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsSessionResumption"
            )
          );
        };
      };

      config = {
        "resumption" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicySpecTlsSessionResumption" = {

      options = {
        "stateful" = mkOption {
          description = "Stateful defines setting for stateful (session-id based) session resumption";
          type = (types.nullOr types.attrs);
        };
        "stateless" = mkOption {
          description = "Stateless defines setting for stateless (session-ticket based) session resumption";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "stateful" = mkOverride 1002 null;
        "stateless" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicyStatus" = {

      options = {
        "ancestors" = mkOption {
          description = "Ancestors is a list of ancestor resources (usually Gateways) that are\nassociated with the policy, and the status of the policy with respect to\neach ancestor. When this policy attaches to a parent, the controller that\nmanages the parent and the ancestors MUST add an entry to this list when\nthe controller first sees the policy and SHOULD update the entry as\nappropriate when the relevant ancestor is modified.\n\nNote that choosing the relevant ancestor is left to the Policy designers;\nan important part of Policy design is designing the right object level at\nwhich to namespace this status.\n\nNote also that implementations MUST ONLY populate ancestor status for\nthe Ancestor resources they are responsible for. Implementations MUST\nuse the ControllerName field to uniquely identify the entries in this list\nthat they are responsible for.\n\nNote that to achieve this, the list of PolicyAncestorStatus structs\nMUST be treated as a map with a composite key, made up of the AncestorRef\nand ControllerName fields combined.\n\nA maximum of 16 ancestors will be represented in this list. An empty list\nmeans the Policy is not relevant for any ancestors.\n\nIf this slice is full, implementations MUST NOT add further entries.\nInstead they MUST consider the policy unimplementable and signal that\non any related resources such as the ancestor that would be referenced\nhere. For example, if this list was full on BackendTLSPolicy, no\nadditional Gateways would be able to reference the Service targeted by\nthe BackendTLSPolicy.";
          type = (
            types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicyStatusAncestors")
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicyStatusAncestors" = {

      options = {
        "ancestorRef" = mkOption {
          description = "AncestorRef corresponds with a ParentRef in the spec that this\nPolicyAncestorStatus struct describes the status of.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicyStatusAncestorsAncestorRef");
        };
        "conditions" = mkOption {
          description = "Conditions describes the status of the Policy with respect to the given Ancestor.\n\n<gateway:util:excludeFromCRD>\n\nNotes for implementors:\n\nConditions are a listType `map`, which means that they function like a\nmap with a key of the `type` field _in the k8s apiserver_.\n\nThis means that implementations must obey some rules when updating this\nsection.\n\n* Implementations MUST perform a read-modify-write cycle on this field\n  before modifying it. That is, when modifying this field, implementations\n  must be confident they have fetched the most recent version of this field,\n  and ensure that changes they make are on that recent version.\n* Implementations MUST NOT remove or reorder Conditions that they are not\n  directly responsible for. For example, if an implementation sees a Condition\n  with type `special.io/SomeField`, it MUST NOT remove, change or update that\n  Condition.\n* Implementations MUST always _merge_ changes into Conditions of the same Type,\n  rather than creating more than one Condition of the same Type.\n* Implementations MUST always update the `observedGeneration` field of the\n  Condition to the `metadata.generation` of the Gateway at the time of update creation.\n* If the `observedGeneration` of a Condition is _greater than_ the value the\n  implementation knows about, then it MUST NOT perform the update on that Condition,\n  but must wait for a future reconciliation and status update. (The assumption is that\n  the implementation's copy of the object is stale and an update will be re-triggered\n  if relevant.)\n\n</gateway:util:excludeFromCRD>";
          type = (
            types.listOf (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicyStatusAncestorsConditions"
            )
          );
        };
        "controllerName" = mkOption {
          description = "ControllerName is a domain/path string that indicates the name of the\ncontroller that wrote this status. This corresponds with the\ncontrollerName field on GatewayClass.\n\nExample: \"example.net/gateway-controller\".\n\nThe format of this field is DOMAIN \"/\" PATH, where DOMAIN and PATH are\nvalid Kubernetes names\n(https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\n\nControllers MUST populate this field when writing status. Controllers should ensure that\nentries to status populated with their ControllerName are cleaned up when they are no\nlonger necessary.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicyStatusAncestorsAncestorRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent.\nWhen unspecified, \"gateway.networking.k8s.io\" is inferred.\nTo set the core API group (such as for a \"Service\" kind referent),\nGroup must be explicitly set to \"\" (empty string).\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent.\n\nThere are two kinds of parent resources with \"Core\" support:\n\n* Gateway (Gateway conformance profile)\n* Service (Mesh conformance profile, ClusterIP Services only)\n\nSupport for other resources is Implementation-Specific.";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.\n\nSupport: Core";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referent. When unspecified, this refers\nto the local namespace of the Route.\n\nNote that there are specific rules for ParentRefs which cross namespace\nboundaries. Cross-namespace references are only valid if they are explicitly\nallowed by something in the namespace they are referring to. For example:\nGateway has the AllowedRoutes field, and ReferenceGrant provides a\ngeneric way to enable any other kind of cross-namespace reference.\n\n<gateway:experimental:description>\nParentRefs from a Route to a Service in the same namespace are \"producer\"\nroutes, which apply default routing rules to inbound connections from\nany namespace to the Service.\n\nParentRefs from a Route to a Service in a different namespace are\n\"consumer\" routes, and these routing rules are only applied to outbound\nconnections originating from the same namespace as the Route, for which\nthe intended destination of the connections are a Service targeted as a\nParentRef of the Route.\n</gateway:experimental:description>\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port is the network port this Route targets. It can be interpreted\ndifferently based on the type of parent resource.\n\nWhen the parent resource is a Gateway, this targets all listeners\nlistening on the specified port that also support this kind of Route(and\nselect this Route). It's not recommended to set `Port` unless the\nnetworking behaviors specified in a Route must apply to a specific port\nas opposed to a listener(s) whose port(s) may be changed. When both Port\nand SectionName are specified, the name and port of the selected listener\nmust match both specified values.\n\n<gateway:experimental:description>\nWhen the parent resource is a Service, this targets a specific port in the\nService spec. When both Port (experimental) and SectionName are specified,\nthe name and port of the selected port must match both specified values.\n</gateway:experimental:description>\n\nImplementations MAY choose to support other parent resources.\nImplementations supporting other types of parent resources MUST clearly\ndocument how/if Port is interpreted.\n\nFor the purpose of status, an attachment is considered successful as\nlong as the parent resource accepts it partially. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment\nfrom the referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route,\nthe Route MUST be considered detached from the Gateway.\n\nSupport: Extended";
          type = (types.nullOr types.int);
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. In the\nfollowing resources, SectionName is interpreted as the following:\n\n* Gateway: Listener name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n* Service: Port name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n\nImplementations MAY choose to support attaching Routes to other resources.\nIf that is the case, they MUST clearly document how SectionName is\ninterpreted.\n\nWhen unspecified (empty string), this will reference the entire resource.\nFor the purpose of status, an attachment is considered successful if at\nleast one section in the parent resource accepts it. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment from\nthe referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route, the\nRoute MUST be considered detached from the Gateway.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicyStatusAncestorsConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = types.str;
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "type of condition in CamelCase or in foo.example.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicy" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "Spec defines the desired state of EnvoyExtensionPolicy.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpec");
        };
        "status" = mkOption {
          description = "Status defines the current status of EnvoyExtensionPolicy.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicyStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpec" = {

      options = {
        "extProc" = mkOption {
          description = "ExtProc is an ordered list of external processing filters\nthat should be added to the envoy filter chain";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProc")
            )
          );
        };
        "lua" = mkOption {
          description = "Lua is an ordered list of Lua filters\nthat should be added to the envoy filter chain";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecLua")
            )
          );
        };
        "targetRef" = mkOption {
          description = "TargetRef is the name of the resource this policy is being attached to.\nThis policy and the TargetRef MUST be in the same namespace for this\nPolicy to have effect\n\nDeprecated: use targetRefs/targetSelectors instead";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecTargetRef")
          );
        };
        "targetRefs" = mkOption {
          description = "TargetRefs are the names of the Gateway resources this policy\nis being attached to.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecTargetRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "targetSelectors" = mkOption {
          description = "TargetSelectors allow targeting resources for this policy based on labels";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecTargetSelectors")
            )
          );
        };
        "wasm" = mkOption {
          description = "Wasm is a list of Wasm extensions to be loaded by the Gateway.\nOrder matters, as the extensions will be loaded in the order they are\ndefined in this list.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasm"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "extProc" = mkOverride 1002 null;
        "lua" = mkOverride 1002 null;
        "targetRef" = mkOverride 1002 null;
        "targetRefs" = mkOverride 1002 null;
        "targetSelectors" = mkOverride 1002 null;
        "wasm" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProc" = {

      options = {
        "backendRef" = mkOption {
          description = "BackendRef references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.\n\nDeprecated: Use BackendRefs instead.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendRef"
            )
          );
        };
        "backendRefs" = mkOption {
          description = "BackendRefs references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "backendSettings" = mkOption {
          description = "BackendSettings holds configuration for managing the connection\nto the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettings"
            )
          );
        };
        "failOpen" = mkOption {
          description = "FailOpen is a switch used to control the behavior when failing to call the external processor.\n\nIf FailOpen is set to true, the system bypasses the ExtProc extension and\nallows the traffic to pass through. If it is set to false or\nnot set (defaulting to false), the system blocks the traffic and returns\nan HTTP 5xx error.\n\nIf set to true, the ExtProc extension will also be bypassed if the configuration is invalid.";
          type = (types.nullOr types.bool);
        };
        "messageTimeout" = mkOption {
          description = "MessageTimeout is the timeout for a response to be returned from the external processor\nDefault: 200ms";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Metadata defines options related to the sending and receiving of dynamic metadata.\nThese options define which metadata namespaces would be sent to the processor and which dynamic metadata\nnamespaces the processor would be permitted to emit metadata to.\nUsers can specify custom namespaces or well-known envoy metadata namespace (such as envoy.filters.http.ext_authz)\ndocumented here: https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata#well-known-dynamic-metadata\nDefault: no metadata context is sent or received from the external processor";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcMetadata")
          );
        };
        "processingMode" = mkOption {
          description = "ProcessingMode defines how request and response body is processed\nDefault: header and body are not sent to the external processor";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcProcessingMode"
            )
          );
        };
      };

      config = {
        "backendRef" = mkOverride 1002 null;
        "backendRefs" = mkOverride 1002 null;
        "backendSettings" = mkOverride 1002 null;
        "failOpen" = mkOverride 1002 null;
        "messageTimeout" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "processingMode" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendRefs" = {

      options = {
        "fallback" = mkOption {
          description = "Fallback indicates whether the backend is designated as a fallback.\nMultiple fallback backends can be configured.\nIt is highly recommended to configure active or passive health checks to ensure that failover can be detected\nwhen the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.\nThe overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when\nthe health of the active backends falls below 72%.";
          type = (types.nullOr types.bool);
        };
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
        "weight" = mkOption {
          description = "Weight specifies the proportion of requests forwarded to the referenced\nbackend. This is computed as weight/(sum of all weights in this\nBackendRefs list). For non-zero values, there may be some epsilon from\nthe exact proportion defined here depending on the precision an\nimplementation supports. Weight is not a percentage and the sum of\nweights does not need to equal 100.\n\nIf only one backend is specified and it has a weight greater than 0, 100%\nof the traffic is forwarded to that backend. If weight is set to 0, no\ntraffic should be forwarded for this entry. If unspecified, weight\ndefaults to 1.\n\nSupport for this field varies based on the context where used.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "fallback" = mkOverride 1002 null;
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "weight" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettings" = {

      options = {
        "circuitBreaker" = mkOption {
          description = "Circuit Breaker settings for the upstream connections and requests.\nIf not set, circuit breakers will be enabled with the default thresholds";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker"
            )
          );
        };
        "connection" = mkOption {
          description = "Connection includes backend connection settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsConnection"
            )
          );
        };
        "dns" = mkOption {
          description = "DNS includes dns resolution settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsDns"
            )
          );
        };
        "healthCheck" = mkOption {
          description = "HealthCheck allows gateway to perform active health checking on backends.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck"
            )
          );
        };
        "http2" = mkOption {
          description = "HTTP2 provides HTTP/2 configuration for backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2"
            )
          );
        };
        "loadBalancer" = mkOption {
          description = "LoadBalancer policy to apply when routing traffic from the gateway to\nthe backend endpoints. Defaults to `LeastRequest`.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer"
            )
          );
        };
        "proxyProtocol" = mkOption {
          description = "ProxyProtocol enables the Proxy Protocol when communicating with the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocol"
            )
          );
        };
        "retry" = mkOption {
          description = "Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.\nIf not set, retry will be disabled.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetry"
            )
          );
        };
        "tcpKeepalive" = mkOption {
          description = "TcpKeepalive settings associated with the upstream client connection.\nDisabled by default.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout settings for the backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTimeout"
            )
          );
        };
      };

      config = {
        "circuitBreaker" = mkOverride 1002 null;
        "connection" = mkOverride 1002 null;
        "dns" = mkOverride 1002 null;
        "healthCheck" = mkOverride 1002 null;
        "http2" = mkOverride 1002 null;
        "loadBalancer" = mkOverride 1002 null;
        "proxyProtocol" = mkOverride 1002 null;
        "retry" = mkOverride 1002 null;
        "tcpKeepalive" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker" = {

      options = {
        "maxConnections" = mkOption {
          description = "The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxParallelRequests" = mkOption {
          description = "The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxParallelRetries" = mkOption {
          description = "The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxPendingRequests" = mkOption {
          description = "The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxRequestsPerConnection" = mkOption {
          description = "The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.\nDefault: unlimited.";
          type = (types.nullOr types.int);
        };
        "perEndpoint" = mkOption {
          description = "PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpoint"
            )
          );
        };
      };

      config = {
        "maxConnections" = mkOverride 1002 null;
        "maxParallelRequests" = mkOverride 1002 null;
        "maxParallelRetries" = mkOverride 1002 null;
        "maxPendingRequests" = mkOverride 1002 null;
        "maxRequestsPerConnection" = mkOverride 1002 null;
        "perEndpoint" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpoint" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsConnection" = {

      options = {
        "bufferLimit" = mkOption {
          description = "BufferLimit Soft limit on size of the cluster’s connections read and write buffers.\nBufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.\nIf unspecified, an implementation defined default is applied (32768 bytes).\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote: that when the suffix is not provided, the value is interpreted as bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "preconnect" = mkOption {
          description = "Preconnect configures proactive upstream connections to reduce latency by establishing\nconnections before they’re needed and avoiding connection establishment overhead.\n\nIf unset, Envoy will fetch connections as needed to serve in-flight requests.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionPreconnect"
            )
          );
        };
        "socketBufferLimit" = mkOption {
          description = "SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket\nto backend.\nSocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote that when the suffix is not provided, the value is interpreted as bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "bufferLimit" = mkOverride 1002 null;
        "preconnect" = mkOverride 1002 null;
        "socketBufferLimit" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionPreconnect" =
      {

        options = {
          "perEndpointPercent" = mkOption {
            description = "PerEndpointPercent configures how many additional connections to maintain per\nupstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a\npercentage of the connections required by active streams\n(e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).\n\nAllowed value range is between 100-300. When both PerEndpointPercent and\nPredictivePercent are set, Envoy ensures both are satisfied (max of the two).";
            type = (types.nullOr types.int);
          };
          "predictivePercent" = mkOption {
            description = "PredictivePercent configures how many additional connections to maintain\nacross the cluster by anticipating which upstream endpoint the load balancer\nwill select next, useful for low-QPS services. Relies on deterministic\nloadbalancing and is only supported with Random or RoundRobin.\nExpressed as a percentage of the connections required by active streams\n(e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).\n\nMinimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are\nset Envoy ensures both are satisfied per host (max of the two).";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "perEndpointPercent" = mkOverride 1002 null;
          "predictivePercent" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsDns" = {

      options = {
        "dnsRefreshRate" = mkOption {
          description = "DNSRefreshRate specifies the rate at which DNS records should be refreshed.\nDefaults to 30 seconds.";
          type = (types.nullOr types.str);
        };
        "lookupFamily" = mkOption {
          description = "LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).\nIf set, this configuration overrides other defaults.";
          type = (types.nullOr types.str);
        };
        "respectDnsTtl" = mkOption {
          description = "RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.\nIf the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.\nDefaults to true.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "dnsRefreshRate" = mkOverride 1002 null;
        "lookupFamily" = mkOverride 1002 null;
        "respectDnsTtl" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck" = {

      options = {
        "active" = mkOption {
          description = "Active health check configuration";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive"
            )
          );
        };
        "panicThreshold" = mkOption {
          description = "When number of unhealthy endpoints for a backend reaches this threshold\nEnvoy will disregard health status and balance across all endpoints.\nIt's designed to prevent a situation in which host failures cascade throughout the cluster\nas load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.";
          type = (types.nullOr types.int);
        };
        "passive" = mkOption {
          description = "Passive passive check configuration";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive"
            )
          );
        };
      };

      config = {
        "active" = mkOverride 1002 null;
        "panicThreshold" = mkOverride 1002 null;
        "passive" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive" = {

      options = {
        "grpc" = mkOption {
          description = "GRPC defines the configuration of the GRPC health checker.\nIt's optional, and can only be used if the specified type is GRPC.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpc"
            )
          );
        };
        "healthyThreshold" = mkOption {
          description = "HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.";
          type = (types.nullOr types.int);
        };
        "http" = mkOption {
          description = "HTTP defines the configuration of http health checker.\nIt's required while the health checker type is HTTP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp"
            )
          );
        };
        "initialJitter" = mkOption {
          description = "InitialJitter defines the maximum time Envoy will wait before the first health check.\nEnvoy will randomly select a value between 0 and the initial jitter value.";
          type = (types.nullOr types.str);
        };
        "interval" = mkOption {
          description = "Interval defines the time between active health checks.";
          type = (types.nullOr types.str);
        };
        "tcp" = mkOption {
          description = "TCP defines the configuration of tcp health checker.\nIt's required while the health checker type is TCP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcp"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout defines the time to wait for a health check response.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type defines the type of health checker.";
          type = types.str;
        };
        "unhealthyThreshold" = mkOption {
          description = "UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "grpc" = mkOverride 1002 null;
        "healthyThreshold" = mkOverride 1002 null;
        "http" = mkOverride 1002 null;
        "initialJitter" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "tcp" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
        "unhealthyThreshold" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpc" =
      {

        options = {
          "service" = mkOption {
            description = "Service to send in the health check request.\nIf this is not specified, then the health check request applies to the entire\nserver and not to a specific service.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "service" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp" =
      {

        options = {
          "expectedResponse" = mkOption {
            description = "ExpectedResponse defines a list of HTTP expected responses to match.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse"
              )
            );
          };
          "expectedStatuses" = mkOption {
            description = "ExpectedStatuses defines a list of HTTP response statuses considered healthy.\nDefaults to 200 only";
            type = (types.nullOr (types.listOf types.int));
          };
          "hostname" = mkOption {
            description = "Hostname defines the HTTP host that will be requested during health checking.\nDefault: HTTPRoute or GRPCRoute hostname.";
            type = (types.nullOr types.str);
          };
          "method" = mkOption {
            description = "Method defines the HTTP method used for health checking.\nDefaults to GET";
            type = (types.nullOr types.str);
          };
          "path" = mkOption {
            description = "Path defines the HTTP path that will be requested during health checking.";
            type = types.str;
          };
        };

        config = {
          "expectedResponse" = mkOverride 1002 null;
          "expectedStatuses" = mkOverride 1002 null;
          "hostname" = mkOverride 1002 null;
          "method" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcp" =
      {

        options = {
          "receive" = mkOption {
            description = "Receive defines the expected response payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive"
              )
            );
          };
          "send" = mkOption {
            description = "Send defines the request payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend"
              )
            );
          };
        };

        config = {
          "receive" = mkOverride 1002 null;
          "send" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive" =
      {

        options = {
          "baseEjectionTime" = mkOption {
            description = "BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.";
            type = (types.nullOr types.str);
          };
          "consecutive5XxErrors" = mkOption {
            description = "Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.";
            type = (types.nullOr types.int);
          };
          "consecutiveGatewayErrors" = mkOption {
            description = "ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.";
            type = (types.nullOr types.int);
          };
          "consecutiveLocalOriginFailures" = mkOption {
            description = "ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.\nParameter takes effect only when split_external_local_origin_errors is set to true.";
            type = (types.nullOr types.int);
          };
          "failurePercentageThreshold" = mkOption {
            description = "FailurePercentageThreshold sets the failure percentage threshold for outlier detection.\nIf the failure percentage of a given host is greater than or equal to this value, it will be ejected.\nDefaults to 85.";
            type = (types.nullOr types.int);
          };
          "interval" = mkOption {
            description = "Interval defines the time between passive health checks.";
            type = (types.nullOr types.str);
          };
          "maxEjectionPercent" = mkOption {
            description = "MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.";
            type = (types.nullOr types.int);
          };
          "splitExternalLocalOriginErrors" = mkOption {
            description = "SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "baseEjectionTime" = mkOverride 1002 null;
          "consecutive5XxErrors" = mkOverride 1002 null;
          "consecutiveGatewayErrors" = mkOverride 1002 null;
          "consecutiveLocalOriginFailures" = mkOverride 1002 null;
          "failurePercentageThreshold" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "maxEjectionPercent" = mkOverride 1002 null;
          "splitExternalLocalOriginErrors" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2" = {

      options = {
        "initialConnectionWindowSize" = mkOption {
          description = "InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.\nIf not set, the default value is 1 MiB.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "initialStreamWindowSize" = mkOption {
          description = "InitialStreamWindowSize sets the initial window size for HTTP/2 streams.\nIf not set, the default value is 64 KiB(64*1024).";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxConcurrentStreams" = mkOption {
          description = "MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.\nIf not set, the default value is 100.";
          type = (types.nullOr types.int);
        };
        "onInvalidMessage" = mkOption {
          description = "OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error\nIt's recommended for L2 Envoy deployments to set this value to TerminateStream.\nhttps://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two\nDefault: TerminateConnection";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "initialConnectionWindowSize" = mkOverride 1002 null;
        "initialStreamWindowSize" = mkOverride 1002 null;
        "maxConcurrentStreams" = mkOverride 1002 null;
        "onInvalidMessage" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer" = {

      options = {
        "consistentHash" = mkOption {
          description = "ConsistentHash defines the configuration when the load balancer type is\nset to ConsistentHash";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash"
            )
          );
        };
        "endpointOverride" = mkOption {
          description = "EndpointOverride defines the configuration for endpoint override.\nWhen specified, the load balancer will attempt to route requests to endpoints\nbased on the override information extracted from request headers or metadata.\n If the override endpoints are not available, the configured load balancer policy will be used as fallback.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverride"
            )
          );
        };
        "slowStart" = mkOption {
          description = "SlowStart defines the configuration related to the slow start load balancer policy.\nIf set, during slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently this is only supported for RoundRobin and LeastRequest load balancers";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStart"
            )
          );
        };
        "type" = mkOption {
          description = "Type decides the type of Load Balancer policy.\nValid LoadBalancerType values are\n\"ConsistentHash\",\n\"LeastRequest\",\n\"Random\",\n\"RoundRobin\".";
          type = types.str;
        };
        "zoneAware" = mkOption {
          description = "ZoneAware defines the configuration related to the distribution of requests between locality zones.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAware"
            )
          );
        };
      };

      config = {
        "consistentHash" = mkOverride 1002 null;
        "endpointOverride" = mkOverride 1002 null;
        "slowStart" = mkOverride 1002 null;
        "zoneAware" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash" =
      {

        options = {
          "cookie" = mkOption {
            description = "Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie"
              )
            );
          };
          "header" = mkOption {
            description = "Header configures the header hash policy when the consistent hash type is set to Header.\n\nDeprecated: use Headers instead";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeader"
              )
            );
          };
          "headers" = mkOption {
            description = "Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "queryParams" = mkOption {
            description = "QueryParams configures the query parameter hash policy when the consistent hash type is set to QueryParams.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashQueryParams"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "tableSize" = mkOption {
            description = "The table size for consistent hashing, must be prime number limited to 5000011.";
            type = (types.nullOr types.int);
          };
          "type" = mkOption {
            description = "ConsistentHashType defines the type of input to hash on. Valid Type values are\n\"SourceIP\",\n\"Header\",\n\"Headers\",\n\"Cookie\".\n\"QueryParams\".";
            type = types.str;
          };
        };

        config = {
          "cookie" = mkOverride 1002 null;
          "header" = mkOverride 1002 null;
          "headers" = mkOverride 1002 null;
          "queryParams" = mkOverride 1002 null;
          "tableSize" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie" =
      {

        options = {
          "attributes" = mkOption {
            description = "Additional Attributes to set for the generated cookie.";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "name" = mkOption {
            description = "Name of the cookie to hash.\nIf this cookie does not exist in the request, Envoy will generate a cookie and set\nthe TTL on the response back to the client based on Layer 4\nattributes of the backend endpoint, to ensure that these future requests\ngo to the same backend endpoint. Make sure to set the TTL field for this case.";
            type = types.str;
          };
          "ttl" = mkOption {
            description = "TTL of the generated cookie if the cookie is not present. This value sets the\nMax-Age attribute value.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "attributes" = mkOverride 1002 null;
          "ttl" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeader" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashQueryParams" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the query param to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverride" =
      {

        options = {
          "extractFrom" = mkOption {
            description = "ExtractFrom defines the sources to extract endpoint override information from.";
            type = (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFrom"
              )
            );
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFrom" =
      {

        options = {
          "header" = mkOption {
            description = "Header defines the header to get the override endpoint addresses.\nThe header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.\nFor example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.\nThe IPv6 address is enclosed in square brackets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "header" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStart" =
      {

        options = {
          "window" = mkOption {
            description = "Window defines the duration of the warm up period for newly added host.\nDuring slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently only supports linear growth of traffic. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAware" =
      {

        options = {
          "preferLocal" = mkOption {
            description = "PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal"
              )
            );
          };
        };

        config = {
          "preferLocal" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal" =
      {

        options = {
          "force" = mkOption {
            description = "ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior\nwhich maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForce"
              )
            );
          };
          "minEndpointsThreshold" = mkOption {
            description = "MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.";
            type = (types.nullOr types.int);
          };
          "percentageEnabled" = mkOption {
            description = "Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "force" = mkOverride 1002 null;
          "minEndpointsThreshold" = mkOverride 1002 null;
          "percentageEnabled" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForce" =
      {

        options = {
          "minEndpointsInZoneThreshold" = mkOption {
            description = "MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone\noverride. This is useful for protecting zones with fewer endpoints.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "minEndpointsInZoneThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocol" = {

      options = {
        "version" = mkOption {
          description = "Version of ProxyProtol\nValid ProxyProtocolVersion values are\n\"V1\"\n\"V2\"";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetry" = {

      options = {
        "numAttemptsPerPriority" = mkOption {
          description = "NumAttemptsPerPriority defines the number of requests (initial attempt + retries)\nthat should be sent to the same priority before switching to a different one.\nIf not specified or set to 0, all requests are sent to the highest priority that is healthy.";
          type = (types.nullOr types.int);
        };
        "numRetries" = mkOption {
          description = "NumRetries is the number of retries to be attempted. Defaults to 2.";
          type = (types.nullOr types.int);
        };
        "perRetry" = mkOption {
          description = "PerRetry is the retry policy to be applied per retry attempt.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetry"
            )
          );
        };
        "retryOn" = mkOption {
          description = "RetryOn specifies the retry trigger condition.\n\nIf not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOn"
            )
          );
        };
      };

      config = {
        "numAttemptsPerPriority" = mkOverride 1002 null;
        "numRetries" = mkOverride 1002 null;
        "perRetry" = mkOverride 1002 null;
        "retryOn" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetry" = {

      options = {
        "backOff" = mkOption {
          description = "Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential\nback-off algorithm for retries. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOff"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout is the timeout per retry attempt.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "backOff" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOff" =
      {

        options = {
          "baseInterval" = mkOption {
            description = "BaseInterval is the base interval between retries.";
            type = (types.nullOr types.str);
          };
          "maxInterval" = mkOption {
            description = "MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.\nThe default is 10 times the base_interval";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "baseInterval" = mkOverride 1002 null;
          "maxInterval" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOn" = {

      options = {
        "httpStatusCodes" = mkOption {
          description = "HttpStatusCodes specifies the http status codes to be retried.\nThe retriable-status-codes trigger must also be configured for these status codes to trigger a retry.";
          type = (types.nullOr (types.listOf types.int));
        };
        "triggers" = mkOption {
          description = "Triggers specifies the retry trigger condition(Http/Grpc).";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "httpStatusCodes" = mkOverride 1002 null;
        "triggers" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive" = {

      options = {
        "idleTime" = mkOption {
          description = "The duration a connection needs to be idle before keep-alive\nprobes start being sent.\nThe duration format is\nDefaults to `7200s`.";
          type = (types.nullOr types.str);
        };
        "interval" = mkOption {
          description = "The duration between keep-alive probes.\nDefaults to `75s`.";
          type = (types.nullOr types.str);
        };
        "probes" = mkOption {
          description = "The total number of unacknowledged probes to send before deciding\nthe connection is dead.\nDefaults to 9.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "idleTime" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "probes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTimeout" = {

      options = {
        "http" = mkOption {
          description = "Timeout settings for HTTP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp"
            )
          );
        };
        "tcp" = mkOption {
          description = "Timeout settings for TCP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcp"
            )
          );
        };
      };

      config = {
        "http" = mkOverride 1002 null;
        "tcp" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp" = {

      options = {
        "connectionIdleTimeout" = mkOption {
          description = "The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.\nDefault: 1 hour.";
          type = (types.nullOr types.str);
        };
        "maxConnectionDuration" = mkOption {
          description = "The maximum duration of an HTTP connection.\nDefault: unlimited.";
          type = (types.nullOr types.str);
        };
        "maxStreamDuration" = mkOption {
          description = "MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time\nfrom when the request is sent until the response stream is fully consumed and does not apply to\nnon-streaming requests.\nWhen set to \"0s\", no max duration is applied and streams can run indefinitely.";
          type = (types.nullOr types.str);
        };
        "requestTimeout" = mkOption {
          description = "RequestTimeout is the time until which entire response is received from the upstream.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "connectionIdleTimeout" = mkOverride 1002 null;
        "maxConnectionDuration" = mkOverride 1002 null;
        "maxStreamDuration" = mkOverride 1002 null;
        "requestTimeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcp" = {

      options = {
        "connectTimeout" = mkOption {
          description = "The timeout for network connection establishment, including TCP and TLS handshakes.\nDefault: 10 seconds.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "connectTimeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcMetadata" = {

      options = {
        "accessibleNamespaces" = mkOption {
          description = "AccessibleNamespaces are metadata namespaces that are sent to the external processor as context";
          type = (types.nullOr (types.listOf types.str));
        };
        "writableNamespaces" = mkOption {
          description = "WritableNamespaces are metadata namespaces that the external processor can write to";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "accessibleNamespaces" = mkOverride 1002 null;
        "writableNamespaces" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcProcessingMode" = {

      options = {
        "allowModeOverride" = mkOption {
          description = "AllowModeOverride allows the external processor to override the processing mode set via the\n`mode_override` field in the gRPC response message. This defaults to false.";
          type = (types.nullOr types.bool);
        };
        "request" = mkOption {
          description = "Defines processing mode for requests. If present, request headers are sent. Request body is processed according\nto the specified mode.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcProcessingModeRequest"
            )
          );
        };
        "response" = mkOption {
          description = "Defines processing mode for responses. If present, response headers are sent. Response body is processed according\nto the specified mode.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcProcessingModeResponse"
            )
          );
        };
      };

      config = {
        "allowModeOverride" = mkOverride 1002 null;
        "request" = mkOverride 1002 null;
        "response" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcProcessingModeRequest" = {

      options = {
        "attributes" = mkOption {
          description = "Defines which attributes are sent to the external processor. Envoy Gateway currently\nsupports only the following attribute prefixes: connection, source, destination,\nrequest, response, upstream and xds.route.\nhttps://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes";
          type = (types.nullOr (types.listOf types.str));
        };
        "body" = mkOption {
          description = "Defines body processing mode";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "attributes" = mkOverride 1002 null;
        "body" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecExtProcProcessingModeResponse" = {

      options = {
        "attributes" = mkOption {
          description = "Defines which attributes are sent to the external processor. Envoy Gateway currently\nsupports only the following attribute prefixes: connection, source, destination,\nrequest, response, upstream and xds.route.\nhttps://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes";
          type = (types.nullOr (types.listOf types.str));
        };
        "body" = mkOption {
          description = "Defines body processing mode";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "attributes" = mkOverride 1002 null;
        "body" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecLua" = {

      options = {
        "inline" = mkOption {
          description = "Inline contains the source code as an inline string.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type is the type of method to use to read the Lua value.\nValid values are Inline and ValueRef, default is Inline.";
          type = types.str;
        };
        "valueRef" = mkOption {
          description = "ValueRef has the source code specified as a local object reference.\nOnly a reference to ConfigMap is supported.\nThe value of key `lua` in the ConfigMap will be used.\nIf the key is not found, the first value in the ConfigMap will be used.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecLuaValueRef")
          );
        };
      };

      config = {
        "inline" = mkOverride 1002 null;
        "valueRef" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecLuaValueRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"HTTPRoute\" or \"Service\".";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecTargetRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the target resource.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the target resource.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the target resource.";
          type = types.str;
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. When\nunspecified, this targetRef targets the entire resource. In the following\nresources, SectionName is interpreted as the following:\n\n* Gateway: Listener name\n* HTTPRoute: HTTPRouteRule name\n* Service: Port name\n\nIf a SectionName is specified, but does not exist on the targeted object,\nthe Policy must fail to attach, and the policy implementation should record\na `ResolvedRefs` or similar Condition in the Policy's status.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecTargetRefs" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the target resource.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the target resource.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the target resource.";
          type = types.str;
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. When\nunspecified, this targetRef targets the entire resource. In the following\nresources, SectionName is interpreted as the following:\n\n* Gateway: Listener name\n* HTTPRoute: HTTPRouteRule name\n* Service: Port name\n\nIf a SectionName is specified, but does not exist on the targeted object,\nthe Policy must fail to attach, and the policy implementation should record\na `ResolvedRefs` or similar Condition in the Policy's status.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecTargetSelectors" = {

      options = {
        "group" = mkOption {
          description = "Group is the group that this selector targets. Defaults to gateway.networking.k8s.io";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the resource kind that this selector targets.";
          type = types.str;
        };
        "matchExpressions" = mkOption {
          description = "MatchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "MatchLabels are the set of label selectors for identifying the targeted resource";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasm" = {

      options = {
        "code" = mkOption {
          description = "Code is the Wasm code for the extension.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCode");
        };
        "config" = mkOption {
          description = "Config is the configuration for the Wasm extension.\nThis configuration will be passed as a JSON string to the Wasm extension.";
          type = (types.nullOr types.unspecified);
        };
        "env" = mkOption {
          description = "Env configures the environment for the Wasm extension";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmEnv")
          );
        };
        "failOpen" = mkOption {
          description = "FailOpen is a switch used to control the behavior when a fatal error occurs\nduring the initialization or the execution of the Wasm extension.\n\nIf FailOpen is set to true, the system bypasses the Wasm extension and\nallows the traffic to pass through. If it is set to false or\nnot set (defaulting to false), the system blocks the traffic and returns\nan HTTP 5xx error.\n\nIf set to true, the Wasm extension will also be bypassed if the configuration is invalid.";
          type = (types.nullOr types.bool);
        };
        "name" = mkOption {
          description = "Name is a unique name for this Wasm extension. It is used to identify the\nWasm extension if multiple extensions are handled by the same vm_id and root_id.\nIt's also used for logging/debugging.\nIf not specified, EG will generate a unique name for the Wasm extension.";
          type = (types.nullOr types.str);
        };
        "rootID" = mkOption {
          description = "RootID is a unique ID for a set of extensions in a VM which will share a\nRootContext and Contexts if applicable (e.g., an Wasm HttpFilter and an Wasm AccessLog).\nIf left blank, all extensions with a blank root_id with the same vm_id will share Context(s).\n\nNote: RootID must match the root_id parameter used to register the Context in the Wasm code.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "config" = mkOverride 1002 null;
        "env" = mkOverride 1002 null;
        "failOpen" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
        "rootID" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCode" = {

      options = {
        "http" = mkOption {
          description = "HTTP is the HTTP URL containing the Wasm code.\n\nNote that the HTTP server must be accessible from the Envoy proxy.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeHttp")
          );
        };
        "image" = mkOption {
          description = "Image is the OCI image containing the Wasm code.\n\nNote that the image must be accessible from the Envoy Gateway.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImage")
          );
        };
        "pullPolicy" = mkOption {
          description = "PullPolicy is the policy to use when pulling the Wasm module by either the HTTP or Image source.\nThis field is only applicable when the SHA256 field is not set.\n\nIf not specified, the default policy is IfNotPresent except for OCI images whose tag is latest.\n\nNote: EG does not update the Wasm module every time an Envoy proxy requests\nthe Wasm module even if the pull policy is set to Always.\nIt only updates the Wasm module when the EnvoyExtension resource version changes.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type is the type of the source of the Wasm code.\nValid WasmCodeSourceType values are \"HTTP\" or \"Image\".";
          type = types.str;
        };
      };

      config = {
        "http" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "pullPolicy" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeHttp" = {

      options = {
        "sha256" = mkOption {
          description = "SHA256 checksum that will be used to verify the Wasm code.\n\nIf not specified, Envoy Gateway will not verify the downloaded Wasm code.\nkubebuilder:validation:Pattern=`^[a-f0-9]{64}$`";
          type = (types.nullOr types.str);
        };
        "tls" = mkOption {
          description = "TLS configuration when connecting to the Wasm code source.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeHttpTls")
          );
        };
        "url" = mkOption {
          description = "URL is the URL containing the Wasm code.";
          type = types.str;
        };
      };

      config = {
        "sha256" = mkOverride 1002 null;
        "tls" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeHttpTls" = {

      options = {
        "caCertificateRef" = mkOption {
          description = "CACertificateRef contains a references to\nKubernetes objects that contain TLS certificates of\nthe Certificate Authorities that can be used\nas a trust anchor to validate the certificates presented by the Wasm code source.\n\nKubernetes ConfigMap and Kubernetes Secret are supported.\nNote: The ConfigMap or Secret must be in the same namespace as the EnvoyExtensionPolicy.";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef"
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"Secret\".";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referenced object. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImage" = {

      options = {
        "pullSecretRef" = mkOption {
          description = "PullSecretRef is a reference to the secret containing the credentials to pull the image.\nOnly support Kubernetes Secret resource from the same namespace.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef"
            )
          );
        };
        "sha256" = mkOption {
          description = "SHA256 checksum that will be used to verify the OCI image.\n\nIt must match the digest of the OCI image.\n\nIf not specified, Envoy Gateway will not verify the downloaded OCI image.\nkubebuilder:validation:Pattern=`^[a-f0-9]{64}$`";
          type = (types.nullOr types.str);
        };
        "tls" = mkOption {
          description = "TLS configuration when connecting to the Wasm code source.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImageTls")
          );
        };
        "url" = mkOption {
          description = "URL is the URL of the OCI image.\nURL can be in the format of `registry/image:tag` or `registry/image@sha256:digest`.";
          type = types.str;
        };
      };

      config = {
        "pullSecretRef" = mkOverride 1002 null;
        "sha256" = mkOverride 1002 null;
        "tls" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"Secret\".";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referenced object. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImageTls" = {

      options = {
        "caCertificateRef" = mkOption {
          description = "CACertificateRef contains a references to\nKubernetes objects that contain TLS certificates of\nthe Certificate Authorities that can be used\nas a trust anchor to validate the certificates presented by the Wasm code source.\n\nKubernetes ConfigMap and Kubernetes Secret are supported.\nNote: The ConfigMap or Secret must be in the same namespace as the EnvoyExtensionPolicy.";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef"
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"Secret\".";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referenced object. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicySpecWasmEnv" = {

      options = {
        "hostKeys" = mkOption {
          description = "HostKeys is a list of keys for environment variables from the host envoy process\nthat should be passed into the Wasm VM. This is useful for passing secrets to to Wasm extensions.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "hostKeys" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicyStatus" = {

      options = {
        "ancestors" = mkOption {
          description = "Ancestors is a list of ancestor resources (usually Gateways) that are\nassociated with the policy, and the status of the policy with respect to\neach ancestor. When this policy attaches to a parent, the controller that\nmanages the parent and the ancestors MUST add an entry to this list when\nthe controller first sees the policy and SHOULD update the entry as\nappropriate when the relevant ancestor is modified.\n\nNote that choosing the relevant ancestor is left to the Policy designers;\nan important part of Policy design is designing the right object level at\nwhich to namespace this status.\n\nNote also that implementations MUST ONLY populate ancestor status for\nthe Ancestor resources they are responsible for. Implementations MUST\nuse the ControllerName field to uniquely identify the entries in this list\nthat they are responsible for.\n\nNote that to achieve this, the list of PolicyAncestorStatus structs\nMUST be treated as a map with a composite key, made up of the AncestorRef\nand ControllerName fields combined.\n\nA maximum of 16 ancestors will be represented in this list. An empty list\nmeans the Policy is not relevant for any ancestors.\n\nIf this slice is full, implementations MUST NOT add further entries.\nInstead they MUST consider the policy unimplementable and signal that\non any related resources such as the ancestor that would be referenced\nhere. For example, if this list was full on BackendTLSPolicy, no\nadditional Gateways would be able to reference the Service targeted by\nthe BackendTLSPolicy.";
          type = (
            types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicyStatusAncestors")
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicyStatusAncestors" = {

      options = {
        "ancestorRef" = mkOption {
          description = "AncestorRef corresponds with a ParentRef in the spec that this\nPolicyAncestorStatus struct describes the status of.";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicyStatusAncestorsAncestorRef"
          );
        };
        "conditions" = mkOption {
          description = "Conditions describes the status of the Policy with respect to the given Ancestor.\n\n<gateway:util:excludeFromCRD>\n\nNotes for implementors:\n\nConditions are a listType `map`, which means that they function like a\nmap with a key of the `type` field _in the k8s apiserver_.\n\nThis means that implementations must obey some rules when updating this\nsection.\n\n* Implementations MUST perform a read-modify-write cycle on this field\n  before modifying it. That is, when modifying this field, implementations\n  must be confident they have fetched the most recent version of this field,\n  and ensure that changes they make are on that recent version.\n* Implementations MUST NOT remove or reorder Conditions that they are not\n  directly responsible for. For example, if an implementation sees a Condition\n  with type `special.io/SomeField`, it MUST NOT remove, change or update that\n  Condition.\n* Implementations MUST always _merge_ changes into Conditions of the same Type,\n  rather than creating more than one Condition of the same Type.\n* Implementations MUST always update the `observedGeneration` field of the\n  Condition to the `metadata.generation` of the Gateway at the time of update creation.\n* If the `observedGeneration` of a Condition is _greater than_ the value the\n  implementation knows about, then it MUST NOT perform the update on that Condition,\n  but must wait for a future reconciliation and status update. (The assumption is that\n  the implementation's copy of the object is stale and an update will be re-triggered\n  if relevant.)\n\n</gateway:util:excludeFromCRD>";
          type = (
            types.listOf (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicyStatusAncestorsConditions"
            )
          );
        };
        "controllerName" = mkOption {
          description = "ControllerName is a domain/path string that indicates the name of the\ncontroller that wrote this status. This corresponds with the\ncontrollerName field on GatewayClass.\n\nExample: \"example.net/gateway-controller\".\n\nThe format of this field is DOMAIN \"/\" PATH, where DOMAIN and PATH are\nvalid Kubernetes names\n(https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\n\nControllers MUST populate this field when writing status. Controllers should ensure that\nentries to status populated with their ControllerName are cleaned up when they are no\nlonger necessary.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicyStatusAncestorsAncestorRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent.\nWhen unspecified, \"gateway.networking.k8s.io\" is inferred.\nTo set the core API group (such as for a \"Service\" kind referent),\nGroup must be explicitly set to \"\" (empty string).\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent.\n\nThere are two kinds of parent resources with \"Core\" support:\n\n* Gateway (Gateway conformance profile)\n* Service (Mesh conformance profile, ClusterIP Services only)\n\nSupport for other resources is Implementation-Specific.";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.\n\nSupport: Core";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referent. When unspecified, this refers\nto the local namespace of the Route.\n\nNote that there are specific rules for ParentRefs which cross namespace\nboundaries. Cross-namespace references are only valid if they are explicitly\nallowed by something in the namespace they are referring to. For example:\nGateway has the AllowedRoutes field, and ReferenceGrant provides a\ngeneric way to enable any other kind of cross-namespace reference.\n\n<gateway:experimental:description>\nParentRefs from a Route to a Service in the same namespace are \"producer\"\nroutes, which apply default routing rules to inbound connections from\nany namespace to the Service.\n\nParentRefs from a Route to a Service in a different namespace are\n\"consumer\" routes, and these routing rules are only applied to outbound\nconnections originating from the same namespace as the Route, for which\nthe intended destination of the connections are a Service targeted as a\nParentRef of the Route.\n</gateway:experimental:description>\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port is the network port this Route targets. It can be interpreted\ndifferently based on the type of parent resource.\n\nWhen the parent resource is a Gateway, this targets all listeners\nlistening on the specified port that also support this kind of Route(and\nselect this Route). It's not recommended to set `Port` unless the\nnetworking behaviors specified in a Route must apply to a specific port\nas opposed to a listener(s) whose port(s) may be changed. When both Port\nand SectionName are specified, the name and port of the selected listener\nmust match both specified values.\n\n<gateway:experimental:description>\nWhen the parent resource is a Service, this targets a specific port in the\nService spec. When both Port (experimental) and SectionName are specified,\nthe name and port of the selected port must match both specified values.\n</gateway:experimental:description>\n\nImplementations MAY choose to support other parent resources.\nImplementations supporting other types of parent resources MUST clearly\ndocument how/if Port is interpreted.\n\nFor the purpose of status, an attachment is considered successful as\nlong as the parent resource accepts it partially. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment\nfrom the referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route,\nthe Route MUST be considered detached from the Gateway.\n\nSupport: Extended";
          type = (types.nullOr types.int);
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. In the\nfollowing resources, SectionName is interpreted as the following:\n\n* Gateway: Listener name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n* Service: Port name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n\nImplementations MAY choose to support attaching Routes to other resources.\nIf that is the case, they MUST clearly document how SectionName is\ninterpreted.\n\nWhen unspecified (empty string), this will reference the entire resource.\nFor the purpose of status, an attachment is considered successful if at\nleast one section in the parent resource accepts it. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment from\nthe referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route, the\nRoute MUST be considered detached from the Gateway.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicyStatusAncestorsConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = types.str;
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "type of condition in CamelCase or in foo.example.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicy" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "Spec defines the desired state of EnvoyPatchPolicy.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicySpec");
        };
        "status" = mkOption {
          description = "Status defines the current status of EnvoyPatchPolicy.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicyStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicySpec" = {

      options = {
        "jsonPatches" = mkOption {
          description = "JSONPatch defines the JSONPatch configuration.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicySpecJsonPatches"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "priority" = mkOption {
          description = "Priority of the EnvoyPatchPolicy.\nIf multiple EnvoyPatchPolicies are applied to the same\nTargetRef, they will be applied in the ascending order of\nthe priority i.e. int32.min has the highest priority and\nint32.max has the lowest priority.\nDefaults to 0.";
          type = (types.nullOr types.int);
        };
        "targetRef" = mkOption {
          description = "TargetRef is the name of the Gateway API resource this policy\nis being attached to.\nBy default, attaching to Gateway is supported and\nwhen mergeGateways is enabled it should attach to GatewayClass.\nThis Policy and the TargetRef MUST be in the same namespace\nfor this Policy to have effect and be applied to the Gateway\nTargetRef";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicySpecTargetRef");
        };
        "type" = mkOption {
          description = "Type decides the type of patch.\nValid EnvoyPatchType values are \"JSONPatch\".";
          type = types.str;
        };
      };

      config = {
        "jsonPatches" = mkOverride 1002 null;
        "priority" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicySpecJsonPatches" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the resource";
          type = types.str;
        };
        "operation" = mkOption {
          description = "Patch defines the JSON Patch Operation";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicySpecJsonPatchesOperation");
        };
        "type" = mkOption {
          description = "Type is the typed URL of the Envoy xDS Resource";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicySpecJsonPatchesOperation" = {

      options = {
        "from" = mkOption {
          description = "From is the source location of the value to be copied or moved. Only valid\nfor move or copy operations\nRefer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.";
          type = (types.nullOr types.str);
        };
        "jsonPath" = mkOption {
          description = "JSONPath is a JSONPath expression. Refer to https://datatracker.ietf.org/doc/rfc9535/ for more details.\nIt produces one or more JSONPointer expressions based on the given JSON document.\nIf no JSONPointer is found, it will result in an error.\nIf the 'Path' property is also set, it will be appended to the resulting JSONPointer expressions from the JSONPath evaluation.\nThis is useful when creating a property that does not yet exist in the JSON document.\nThe final JSONPointer expressions specifies the locations in the target document/field where the operation will be applied.";
          type = (types.nullOr types.str);
        };
        "op" = mkOption {
          description = "Op is the type of operation to perform";
          type = types.str;
        };
        "path" = mkOption {
          description = "Path is a JSONPointer expression. Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.\nIt specifies the location of the target document/field where the operation will be performed";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is the new value of the path location. The value is only used by\nthe `add` and `replace` operations.";
          type = (types.nullOr types.unspecified);
        };
      };

      config = {
        "from" = mkOverride 1002 null;
        "jsonPath" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicySpecTargetRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the target resource.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the target resource.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the target resource.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicyStatus" = {

      options = {
        "ancestors" = mkOption {
          description = "Ancestors is a list of ancestor resources (usually Gateways) that are\nassociated with the policy, and the status of the policy with respect to\neach ancestor. When this policy attaches to a parent, the controller that\nmanages the parent and the ancestors MUST add an entry to this list when\nthe controller first sees the policy and SHOULD update the entry as\nappropriate when the relevant ancestor is modified.\n\nNote that choosing the relevant ancestor is left to the Policy designers;\nan important part of Policy design is designing the right object level at\nwhich to namespace this status.\n\nNote also that implementations MUST ONLY populate ancestor status for\nthe Ancestor resources they are responsible for. Implementations MUST\nuse the ControllerName field to uniquely identify the entries in this list\nthat they are responsible for.\n\nNote that to achieve this, the list of PolicyAncestorStatus structs\nMUST be treated as a map with a composite key, made up of the AncestorRef\nand ControllerName fields combined.\n\nA maximum of 16 ancestors will be represented in this list. An empty list\nmeans the Policy is not relevant for any ancestors.\n\nIf this slice is full, implementations MUST NOT add further entries.\nInstead they MUST consider the policy unimplementable and signal that\non any related resources such as the ancestor that would be referenced\nhere. For example, if this list was full on BackendTLSPolicy, no\nadditional Gateways would be able to reference the Service targeted by\nthe BackendTLSPolicy.";
          type = (
            types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicyStatusAncestors")
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicyStatusAncestors" = {

      options = {
        "ancestorRef" = mkOption {
          description = "AncestorRef corresponds with a ParentRef in the spec that this\nPolicyAncestorStatus struct describes the status of.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicyStatusAncestorsAncestorRef");
        };
        "conditions" = mkOption {
          description = "Conditions describes the status of the Policy with respect to the given Ancestor.\n\n<gateway:util:excludeFromCRD>\n\nNotes for implementors:\n\nConditions are a listType `map`, which means that they function like a\nmap with a key of the `type` field _in the k8s apiserver_.\n\nThis means that implementations must obey some rules when updating this\nsection.\n\n* Implementations MUST perform a read-modify-write cycle on this field\n  before modifying it. That is, when modifying this field, implementations\n  must be confident they have fetched the most recent version of this field,\n  and ensure that changes they make are on that recent version.\n* Implementations MUST NOT remove or reorder Conditions that they are not\n  directly responsible for. For example, if an implementation sees a Condition\n  with type `special.io/SomeField`, it MUST NOT remove, change or update that\n  Condition.\n* Implementations MUST always _merge_ changes into Conditions of the same Type,\n  rather than creating more than one Condition of the same Type.\n* Implementations MUST always update the `observedGeneration` field of the\n  Condition to the `metadata.generation` of the Gateway at the time of update creation.\n* If the `observedGeneration` of a Condition is _greater than_ the value the\n  implementation knows about, then it MUST NOT perform the update on that Condition,\n  but must wait for a future reconciliation and status update. (The assumption is that\n  the implementation's copy of the object is stale and an update will be re-triggered\n  if relevant.)\n\n</gateway:util:excludeFromCRD>";
          type = (
            types.listOf (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicyStatusAncestorsConditions"
            )
          );
        };
        "controllerName" = mkOption {
          description = "ControllerName is a domain/path string that indicates the name of the\ncontroller that wrote this status. This corresponds with the\ncontrollerName field on GatewayClass.\n\nExample: \"example.net/gateway-controller\".\n\nThe format of this field is DOMAIN \"/\" PATH, where DOMAIN and PATH are\nvalid Kubernetes names\n(https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\n\nControllers MUST populate this field when writing status. Controllers should ensure that\nentries to status populated with their ControllerName are cleaned up when they are no\nlonger necessary.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicyStatusAncestorsAncestorRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent.\nWhen unspecified, \"gateway.networking.k8s.io\" is inferred.\nTo set the core API group (such as for a \"Service\" kind referent),\nGroup must be explicitly set to \"\" (empty string).\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent.\n\nThere are two kinds of parent resources with \"Core\" support:\n\n* Gateway (Gateway conformance profile)\n* Service (Mesh conformance profile, ClusterIP Services only)\n\nSupport for other resources is Implementation-Specific.";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.\n\nSupport: Core";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referent. When unspecified, this refers\nto the local namespace of the Route.\n\nNote that there are specific rules for ParentRefs which cross namespace\nboundaries. Cross-namespace references are only valid if they are explicitly\nallowed by something in the namespace they are referring to. For example:\nGateway has the AllowedRoutes field, and ReferenceGrant provides a\ngeneric way to enable any other kind of cross-namespace reference.\n\n<gateway:experimental:description>\nParentRefs from a Route to a Service in the same namespace are \"producer\"\nroutes, which apply default routing rules to inbound connections from\nany namespace to the Service.\n\nParentRefs from a Route to a Service in a different namespace are\n\"consumer\" routes, and these routing rules are only applied to outbound\nconnections originating from the same namespace as the Route, for which\nthe intended destination of the connections are a Service targeted as a\nParentRef of the Route.\n</gateway:experimental:description>\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port is the network port this Route targets. It can be interpreted\ndifferently based on the type of parent resource.\n\nWhen the parent resource is a Gateway, this targets all listeners\nlistening on the specified port that also support this kind of Route(and\nselect this Route). It's not recommended to set `Port` unless the\nnetworking behaviors specified in a Route must apply to a specific port\nas opposed to a listener(s) whose port(s) may be changed. When both Port\nand SectionName are specified, the name and port of the selected listener\nmust match both specified values.\n\n<gateway:experimental:description>\nWhen the parent resource is a Service, this targets a specific port in the\nService spec. When both Port (experimental) and SectionName are specified,\nthe name and port of the selected port must match both specified values.\n</gateway:experimental:description>\n\nImplementations MAY choose to support other parent resources.\nImplementations supporting other types of parent resources MUST clearly\ndocument how/if Port is interpreted.\n\nFor the purpose of status, an attachment is considered successful as\nlong as the parent resource accepts it partially. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment\nfrom the referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route,\nthe Route MUST be considered detached from the Gateway.\n\nSupport: Extended";
          type = (types.nullOr types.int);
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. In the\nfollowing resources, SectionName is interpreted as the following:\n\n* Gateway: Listener name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n* Service: Port name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n\nImplementations MAY choose to support attaching Routes to other resources.\nIf that is the case, they MUST clearly document how SectionName is\ninterpreted.\n\nWhen unspecified (empty string), this will reference the entire resource.\nFor the purpose of status, an attachment is considered successful if at\nleast one section in the parent resource accepts it. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment from\nthe referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route, the\nRoute MUST be considered detached from the Gateway.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicyStatusAncestorsConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = types.str;
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "type of condition in CamelCase or in foo.example.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxy" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "EnvoyProxySpec defines the desired state of EnvoyProxy.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpec");
        };
        "status" = mkOption {
          description = "EnvoyProxyStatus defines the actual state of EnvoyProxy.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxyStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpec" = {

      options = {
        "backendTLS" = mkOption {
          description = "BackendTLS is the TLS configuration for the Envoy proxy to use when connecting to backends.\nThese settings are applied on backends for which TLS policies are specified.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecBackendTLS"));
        };
        "bootstrap" = mkOption {
          description = "Bootstrap defines the Envoy Bootstrap as a YAML string.\nVisit https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/bootstrap/v3/bootstrap.proto#envoy-v3-api-msg-config-bootstrap-v3-bootstrap\nto learn more about the syntax.\nIf set, this is the Bootstrap configuration used for the managed Envoy Proxy fleet instead of the default Bootstrap configuration\nset by Envoy Gateway.\nSome fields within the Bootstrap that are required to communicate with the xDS Server (Envoy Gateway) and receive xDS resources\nfrom it are not configurable and will result in the `EnvoyProxy` resource being rejected.\nBackward compatibility across minor versions is not guaranteed.\nWe strongly recommend using `egctl x translate` to generate a `EnvoyProxy` resource with the `Bootstrap` field set to the default\nBootstrap configuration used. You can edit this configuration, and rerun `egctl x translate` to ensure there are no validation errors.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecBootstrap"));
        };
        "concurrency" = mkOption {
          description = "Concurrency defines the number of worker threads to run. If unset, it defaults to\nthe number of cpuset threads on the platform.";
          type = (types.nullOr types.int);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs defines additional command line options that are provided to Envoy.\nMore info: https://www.envoyproxy.io/docs/envoy/latest/operations/cli#command-line-options\nNote: some command line options are used internally(e.g. --log-level) so they cannot be provided here.";
          type = (types.nullOr (types.listOf types.str));
        };
        "filterOrder" = mkOption {
          description = "FilterOrder defines the order of filters in the Envoy proxy's HTTP filter chain.\nThe FilterPosition in the list will be applied in the order they are defined.\nIf unspecified, the default filter order is applied.\nDefault filter order is:\n\n- envoy.filters.http.custom_response\n\n- envoy.filters.http.health_check\n\n- envoy.filters.http.fault\n\n- envoy.filters.http.cors\n\n- envoy.filters.http.header_mutation\n\n- envoy.filters.http.ext_authz\n\n- envoy.filters.http.api_key_auth\n\n- envoy.filters.http.basic_auth\n\n- envoy.filters.http.oauth2\n\n- envoy.filters.http.jwt_authn\n\n- envoy.filters.http.stateful_session\n\n- envoy.filters.http.buffer\n\n- envoy.filters.http.lua\n\n- envoy.filters.http.ext_proc\n\n- envoy.filters.http.wasm\n\n- envoy.filters.http.rbac\n\n- envoy.filters.http.local_ratelimit\n\n- envoy.filters.http.ratelimit\n\n- envoy.filters.http.grpc_web\n\n- envoy.filters.http.grpc_stats\n\n- envoy.filters.http.credential_injector\n\n- envoy.filters.http.compressor\n\n- envoy.filters.http.dynamic_forward_proxy\n\n- envoy.filters.http.router\n\nNote: \"envoy.filters.http.router\" cannot be reordered, it's always the last filter in the chain.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecFilterOrder" "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "ipFamily" = mkOption {
          description = "IPFamily specifies the IP family for the EnvoyProxy fleet.\nThis setting only affects the Gateway listener port and does not impact\nother aspects of the Envoy proxy configuration.\nIf not specified, the system will operate as follows:\n- It defaults to IPv4 only.\n- IPv6 and dual-stack environments are not supported in this default configuration.\nNote: To enable IPv6 or dual-stack functionality, explicit configuration is required.";
          type = (types.nullOr types.str);
        };
        "logging" = mkOption {
          description = "Logging defines logging parameters for managed proxies.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecLogging"));
        };
        "luaValidation" = mkOption {
          description = "LuaValidation determines strictness of the Lua script validation for Lua EnvoyExtensionPolicies\nDefault: Strict";
          type = (types.nullOr types.str);
        };
        "mergeGateways" = mkOption {
          description = "MergeGateways defines if Gateway resources should be merged onto the same Envoy Proxy Infrastructure.\nSetting this field to true would merge all Gateway Listeners under the parent Gateway Class.\nThis means that the port, protocol and hostname tuple must be unique for every listener.\nIf a duplicate listener is detected, the newer listener (based on timestamp) will be rejected and its status will be updated with a \"Accepted=False\" condition.";
          type = (types.nullOr types.bool);
        };
        "preserveRouteOrder" = mkOption {
          description = "PreserveRouteOrder determines if the order of matching for HTTPRoutes is determined by Gateway-API\nspecification (https://gateway-api.sigs.k8s.io/reference/1.4/spec/#httprouterule)\nor preserves the order defined by users in the HTTPRoute's HTTPRouteRule list.\nDefault: False";
          type = (types.nullOr types.bool);
        };
        "provider" = mkOption {
          description = "Provider defines the desired resource provider and provider-specific configuration.\nIf unspecified, the \"Kubernetes\" resource provider is used with default configuration\nparameters.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProvider"));
        };
        "routingType" = mkOption {
          description = "RoutingType can be set to \"Service\" to use the Service Cluster IP for routing to the backend,\nor it can be set to \"Endpoint\" to use Endpoint routing. The default is \"Endpoint\".";
          type = (types.nullOr types.str);
        };
        "shutdown" = mkOption {
          description = "Shutdown defines configuration for graceful envoy shutdown process.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecShutdown"));
        };
        "telemetry" = mkOption {
          description = "Telemetry defines telemetry parameters for managed proxies.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetry"));
        };
      };

      config = {
        "backendTLS" = mkOverride 1002 null;
        "bootstrap" = mkOverride 1002 null;
        "concurrency" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "filterOrder" = mkOverride 1002 null;
        "ipFamily" = mkOverride 1002 null;
        "logging" = mkOverride 1002 null;
        "luaValidation" = mkOverride 1002 null;
        "mergeGateways" = mkOverride 1002 null;
        "preserveRouteOrder" = mkOverride 1002 null;
        "provider" = mkOverride 1002 null;
        "routingType" = mkOverride 1002 null;
        "shutdown" = mkOverride 1002 null;
        "telemetry" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecBackendTLS" = {

      options = {
        "alpnProtocols" = mkOption {
          description = "ALPNProtocols supplies the list of ALPN protocols that should be\nexposed by the listener or used by the proxy to connect to the backend.\nDefaults:\n1. HTTPS Routes: h2 and http/1.1 are enabled in listener context.\n2. Other Routes: ALPN is disabled.\n3. Backends: proxy uses the appropriate ALPN options for the backend protocol.\nWhen an empty list is provided, the ALPN TLS extension is disabled.\n\nDefaults to [h2, http/1.1] if not specified.\n\nTypical Supported values are:\n- http/1.0\n- http/1.1\n- h2";
          type = (types.nullOr (types.listOf types.str));
        };
        "ciphers" = mkOption {
          description = "Ciphers specifies the set of cipher suites supported when\nnegotiating TLS 1.0 - 1.2. This setting has no effect for TLS 1.3.\nIn non-FIPS Envoy Proxy builds the default cipher list is:\n- [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]\n- [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]\n- ECDHE-ECDSA-AES256-GCM-SHA384\n- ECDHE-RSA-AES256-GCM-SHA384\nIn builds using BoringSSL FIPS the default cipher list is:\n- ECDHE-ECDSA-AES128-GCM-SHA256\n- ECDHE-RSA-AES128-GCM-SHA256\n- ECDHE-ECDSA-AES256-GCM-SHA384\n- ECDHE-RSA-AES256-GCM-SHA384";
          type = (types.nullOr (types.listOf types.str));
        };
        "clientCertificateRef" = mkOption {
          description = "ClientCertificateRef defines the reference to a Kubernetes Secret that contains\nthe client certificate and private key for Envoy to use when connecting to\nbackend services and external services, such as ExtAuth, ALS, OpenTelemetry, etc.\nThis secret should be located within the same namespace as the Envoy proxy resource that references it.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecBackendTLSClientCertificateRef"
            )
          );
        };
        "ecdhCurves" = mkOption {
          description = "ECDHCurves specifies the set of supported ECDH curves.\nIn non-FIPS Envoy Proxy builds the default curves are:\n- X25519\n- P-256\nIn builds using BoringSSL FIPS the default curve is:\n- P-256";
          type = (types.nullOr (types.listOf types.str));
        };
        "maxVersion" = mkOption {
          description = "Max specifies the maximal TLS protocol version to allow\nThe default is TLS 1.3 if this is not specified.";
          type = (types.nullOr types.str);
        };
        "minVersion" = mkOption {
          description = "Min specifies the minimal TLS protocol version to allow.\nThe default is TLS 1.2 if this is not specified.";
          type = (types.nullOr types.str);
        };
        "signatureAlgorithms" = mkOption {
          description = "SignatureAlgorithms specifies which signature algorithms the listener should\nsupport.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "alpnProtocols" = mkOverride 1002 null;
        "ciphers" = mkOverride 1002 null;
        "clientCertificateRef" = mkOverride 1002 null;
        "ecdhCurves" = mkOverride 1002 null;
        "maxVersion" = mkOverride 1002 null;
        "minVersion" = mkOverride 1002 null;
        "signatureAlgorithms" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecBackendTLSClientCertificateRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"Secret\".";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referenced object. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecBootstrap" = {

      options = {
        "jsonPatches" = mkOption {
          description = "JSONPatches is an array of JSONPatches to be applied to the default bootstrap. Patches are\napplied in the order in which they are defined.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecBootstrapJsonPatches")
            )
          );
        };
        "type" = mkOption {
          description = "Type is the type of the bootstrap configuration, it should be either **Replace**,  **Merge**, or **JSONPatch**.\nIf unspecified, it defaults to Replace.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is a YAML string of the bootstrap.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "jsonPatches" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecBootstrapJsonPatches" = {

      options = {
        "from" = mkOption {
          description = "From is the source location of the value to be copied or moved. Only valid\nfor move or copy operations\nRefer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.";
          type = (types.nullOr types.str);
        };
        "jsonPath" = mkOption {
          description = "JSONPath is a JSONPath expression. Refer to https://datatracker.ietf.org/doc/rfc9535/ for more details.\nIt produces one or more JSONPointer expressions based on the given JSON document.\nIf no JSONPointer is found, it will result in an error.\nIf the 'Path' property is also set, it will be appended to the resulting JSONPointer expressions from the JSONPath evaluation.\nThis is useful when creating a property that does not yet exist in the JSON document.\nThe final JSONPointer expressions specifies the locations in the target document/field where the operation will be applied.";
          type = (types.nullOr types.str);
        };
        "op" = mkOption {
          description = "Op is the type of operation to perform";
          type = types.str;
        };
        "path" = mkOption {
          description = "Path is a JSONPointer expression. Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.\nIt specifies the location of the target document/field where the operation will be performed";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is the new value of the path location. The value is only used by\nthe `add` and `replace` operations.";
          type = (types.nullOr types.unspecified);
        };
      };

      config = {
        "from" = mkOverride 1002 null;
        "jsonPath" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecFilterOrder" = {

      options = {
        "after" = mkOption {
          description = "After defines the filter that should come after the filter.\nOnly one of Before or After must be set.";
          type = (types.nullOr types.str);
        };
        "before" = mkOption {
          description = "Before defines the filter that should come before the filter.\nOnly one of Before or After must be set.";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name of the filter.";
          type = types.str;
        };
      };

      config = {
        "after" = mkOverride 1002 null;
        "before" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecLogging" = {

      options = {
        "level" = mkOption {
          description = "Level is a map of logging level per component, where the component is the key\nand the log level is the value. If unspecified, defaults to \"default: warn\".";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "level" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProvider" = {

      options = {
        "host" = mkOption {
          description = "Host provides runtime deployment of the data plane as a child process on the\nhost environment.\nIf unspecified and type is \"Host\", default settings for the custom provider\nare applied.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderHost"));
        };
        "kubernetes" = mkOption {
          description = "Kubernetes defines the desired state of the Kubernetes resource provider.\nKubernetes provides infrastructure resources for running the data plane,\ne.g. Envoy proxy. If unspecified and type is \"Kubernetes\", default settings\nfor managed Kubernetes resources are applied.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetes")
          );
        };
        "type" = mkOption {
          description = "Type is the type of resource provider to use. A resource provider provides\ninfrastructure resources for running the data plane, e.g. Envoy proxy, and\noptional auxiliary control planes. Supported types are \"Kubernetes\"and \"Host\".";
          type = types.str;
        };
      };

      config = {
        "host" = mkOverride 1002 null;
        "kubernetes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderHost" = {

      options = {
        "envoyVersion" = mkOption {
          description = "EnvoyVersion is the version of Envoy to use. If unspecified, the version\nagainst which Envoy Gateway is built will be used.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "envoyVersion" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetes" = {

      options = {
        "envoyDaemonSet" = mkOption {
          description = "EnvoyDaemonSet defines the desired state of the Envoy daemonset resource.\nDisabled by default, a deployment resource is used instead to provision the Envoy Proxy fleet";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSet"
            )
          );
        };
        "envoyDeployment" = mkOption {
          description = "EnvoyDeployment defines the desired state of the Envoy deployment resource.\nIf unspecified, default settings for the managed Envoy deployment resource\nare applied.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeployment"
            )
          );
        };
        "envoyHpa" = mkOption {
          description = "EnvoyHpa defines the Horizontal Pod Autoscaler settings for Envoy Proxy Deployment.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpa")
          );
        };
        "envoyPDB" = mkOption {
          description = "EnvoyPDB allows to control the pod disruption budget of an Envoy Proxy.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyPDB")
          );
        };
        "envoyService" = mkOption {
          description = "EnvoyService defines the desired state of the Envoy service resource.\nIf unspecified, default settings for the managed Envoy service resource\nare applied.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyService"
            )
          );
        };
        "envoyServiceAccount" = mkOption {
          description = "EnvoyServiceAccount defines the desired state of the Envoy service account resource.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyServiceAccount"
            )
          );
        };
        "useListenerPortAsContainerPort" = mkOption {
          description = "UseListenerPortAsContainerPort disables the port shifting feature in the Envoy Proxy.\nWhen set to false (default value), if the service port is a privileged port (1-1023), add a constant to the value converting it into an ephemeral port.\nThis allows the container to bind to the port without needing a CAP_NET_BIND_SERVICE capability.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "envoyDaemonSet" = mkOverride 1002 null;
        "envoyDeployment" = mkOverride 1002 null;
        "envoyHpa" = mkOverride 1002 null;
        "envoyPDB" = mkOverride 1002 null;
        "envoyService" = mkOverride 1002 null;
        "envoyServiceAccount" = mkOverride 1002 null;
        "useListenerPortAsContainerPort" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSet" = {

      options = {
        "container" = mkOption {
          description = "Container defines the desired specification of main container.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer"
            )
          );
        };
        "name" = mkOption {
          description = "Name of the daemonSet.\nWhen unset, this defaults to an autogenerated name.";
          type = (types.nullOr types.str);
        };
        "patch" = mkOption {
          description = "Patch defines how to perform the patch operation to daemonset";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch"
            )
          );
        };
        "pod" = mkOption {
          description = "Pod defines the desired specification of pod.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod"
            )
          );
        };
        "strategy" = mkOption {
          description = "The daemonset strategy to use to replace existing pods with new ones.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategy"
            )
          );
        };
      };

      config = {
        "container" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
        "patch" = mkOverride 1002 null;
        "pod" = mkOverride 1002 null;
        "strategy" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer" = {

      options = {
        "env" = mkOption {
          description = "List of environment variables to set in the container.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "image" = mkOption {
          description = "Image specifies the EnvoyProxy container image to be used including a tag, instead of the default image.\nThis field is mutually exclusive with ImageRepository.";
          type = (types.nullOr types.str);
        };
        "imageRepository" = mkOption {
          description = "ImageRepository specifies the container image repository to be used without specifying a tag.\nThe default tag will be used.\nThis field is mutually exclusive with Image.";
          type = (types.nullOr types.str);
        };
        "resources" = mkOption {
          description = "Resources required by this container.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources"
            )
          );
        };
        "securityContext" = mkOption {
          description = "SecurityContext defines the security options the container should be run with.\nIf set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.\nMore info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext"
            )
          );
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts are volumes to mount into the container's filesystem.\nCannot be updated.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "env" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imageRepository" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
        "valueFrom" = mkOption {
          description = "Source for the environment variable's value. Cannot be used if value is not empty.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom"
            )
          );
        };
      };

      config = {
        "value" = mkOverride 1002 null;
        "valueFrom" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom" =
      {

        options = {
          "configMapKeyRef" = mkOption {
            description = "Selects a key of a ConfigMap.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef"
              )
            );
          };
          "fieldRef" = mkOption {
            description = "Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,\nspec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFieldRef"
              )
            );
          };
          "fileKeyRef" = mkOption {
            description = "FileKeyRef selects a key of the env file.\nRequires the EnvFiles feature gate to be enabled.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFileKeyRef"
              )
            );
          };
          "resourceFieldRef" = mkOption {
            description = "Selects a resource of the container: only resources limits and requests\n(limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef"
              )
            );
          };
          "secretKeyRef" = mkOption {
            description = "Selects a key of a secret in the pod's namespace";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef"
              )
            );
          };
        };

        config = {
          "configMapKeyRef" = mkOverride 1002 null;
          "fieldRef" = mkOverride 1002 null;
          "fileKeyRef" = mkOverride 1002 null;
          "resourceFieldRef" = mkOverride 1002 null;
          "secretKeyRef" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFieldRef" =
      {

        options = {
          "apiVersion" = mkOption {
            description = "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".";
            type = (types.nullOr types.str);
          };
          "fieldPath" = mkOption {
            description = "Path of the field to select in the specified API version.";
            type = types.str;
          };
        };

        config = {
          "apiVersion" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFileKeyRef" =
      {

        options = {
          "key" = mkOption {
            description = "The key within the env file. An invalid key will prevent the pod from starting.\nThe keys defined within a source may consist of any printable ASCII characters except '='.\nDuring Alpha stage of the EnvFiles feature gate, the key size is limited to 128 characters.";
            type = types.str;
          };
          "optional" = mkOption {
            description = "Specify whether the file or its key must be defined. If the file or key\ndoes not exist, then the env var is not published.\nIf optional is set to true and the specified key does not exist,\nthe environment variable will not be set in the Pod's containers.\n\nIf optional is set to false and the specified key does not exist,\nan error will be returned during Pod creation.";
            type = (types.nullOr types.bool);
          };
          "path" = mkOption {
            description = "The path within the volume from which to select the file.\nMust be relative and may not contain the '..' path or start with '..'.";
            type = types.str;
          };
          "volumeName" = mkOption {
            description = "The name of the volume mount containing the env file.";
            type = types.str;
          };
        };

        config = {
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef" =
      {

        options = {
          "containerName" = mkOption {
            description = "Container name: required for volumes, optional for env vars";
            type = (types.nullOr types.str);
          };
          "divisor" = mkOption {
            description = "Specifies the output format of the exposed resources, defaults to \"1\"";
            type = (types.nullOr (types.either types.int types.str));
          };
          "resource" = mkOption {
            description = "Required: resource to select";
            type = types.str;
          };
        };

        config = {
          "containerName" = mkOverride 1002 null;
          "divisor" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources" =
      {

        options = {
          "claims" = mkOption {
            description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesClaims"
                  "name"
                  [ "name" ]
              )
            );
            apply = attrsToList;
          };
          "limits" = mkOption {
            description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
          "requests" = mkOption {
            description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
        };

        config = {
          "claims" = mkOverride 1002 null;
          "limits" = mkOverride 1002 null;
          "requests" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesClaims" =
      {

        options = {
          "name" = mkOption {
            description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
            type = types.str;
          };
          "request" = mkOption {
            description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "request" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext" =
      {

        options = {
          "allowPrivilegeEscalation" = mkOption {
            description = "AllowPrivilegeEscalation controls whether a process can gain more\nprivileges than its parent process. This bool directly controls if\nthe no_new_privs flag will be set on the container process.\nAllowPrivilegeEscalation is true always when the container is:\n1) run as Privileged\n2) has CAP_SYS_ADMIN\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.bool);
          };
          "appArmorProfile" = mkOption {
            description = "appArmorProfile is the AppArmor options to use by this container. If set, this profile\noverrides the pod's appArmorProfile.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextAppArmorProfile"
              )
            );
          };
          "capabilities" = mkOption {
            description = "The capabilities to add/drop when running containers.\nDefaults to the default set of capabilities granted by the container runtime.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextCapabilities"
              )
            );
          };
          "privileged" = mkOption {
            description = "Run container in privileged mode.\nProcesses in privileged containers are essentially equivalent to root on the host.\nDefaults to false.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.bool);
          };
          "procMount" = mkOption {
            description = "procMount denotes the type of proc mount to use for the containers.\nThe default value is Default which uses the container runtime defaults for\nreadonly paths and masked paths.\nThis requires the ProcMountType feature flag to be enabled.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.str);
          };
          "readOnlyRootFilesystem" = mkOption {
            description = "Whether this container has a read-only root filesystem.\nDefault is false.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.bool);
          };
          "runAsGroup" = mkOption {
            description = "The GID to run the entrypoint of the container process.\nUses runtime default if unset.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.int);
          };
          "runAsNonRoot" = mkOption {
            description = "Indicates that the container must run as a non-root user.\nIf true, the Kubelet will validate the image at runtime to ensure that it\ndoes not run as UID 0 (root) and fail to start the container if it does.\nIf unset or false, no such validation will be performed.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.";
            type = (types.nullOr types.bool);
          };
          "runAsUser" = mkOption {
            description = "The UID to run the entrypoint of the container process.\nDefaults to user specified in image metadata if unspecified.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.int);
          };
          "seLinuxOptions" = mkOption {
            description = "The SELinux context to be applied to the container.\nIf unspecified, the container runtime will allocate a random SELinux context for each\ncontainer.  May also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions"
              )
            );
          };
          "seccompProfile" = mkOption {
            description = "The seccomp options to use by this container. If seccomp options are\nprovided at both the pod & container level, the container options\noverride the pod options.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeccompProfile"
              )
            );
          };
          "windowsOptions" = mkOption {
            description = "The Windows specific settings applied to all containers.\nIf unspecified, the options from the PodSecurityContext will be used.\nIf set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is linux.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions"
              )
            );
          };
        };

        config = {
          "allowPrivilegeEscalation" = mkOverride 1002 null;
          "appArmorProfile" = mkOverride 1002 null;
          "capabilities" = mkOverride 1002 null;
          "privileged" = mkOverride 1002 null;
          "procMount" = mkOverride 1002 null;
          "readOnlyRootFilesystem" = mkOverride 1002 null;
          "runAsGroup" = mkOverride 1002 null;
          "runAsNonRoot" = mkOverride 1002 null;
          "runAsUser" = mkOverride 1002 null;
          "seLinuxOptions" = mkOverride 1002 null;
          "seccompProfile" = mkOverride 1002 null;
          "windowsOptions" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextAppArmorProfile" =
      {

        options = {
          "localhostProfile" = mkOption {
            description = "localhostProfile indicates a profile loaded on the node that should be used.\nThe profile must be preconfigured on the node to work.\nMust match the loaded name of the profile.\nMust be set if and only if type is \"Localhost\".";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "type indicates which kind of AppArmor profile will be applied.\nValid options are:\n  Localhost - a profile pre-loaded on the node.\n  RuntimeDefault - the container runtime's default profile.\n  Unconfined - no AppArmor enforcement.";
            type = types.str;
          };
        };

        config = {
          "localhostProfile" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextCapabilities" =
      {

        options = {
          "add" = mkOption {
            description = "Added capabilities";
            type = (types.nullOr (types.listOf types.str));
          };
          "drop" = mkOption {
            description = "Removed capabilities";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "add" = mkOverride 1002 null;
          "drop" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions" =
      {

        options = {
          "level" = mkOption {
            description = "Level is SELinux level label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "role" = mkOption {
            description = "Role is a SELinux role label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type is a SELinux type label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "user" = mkOption {
            description = "User is a SELinux user label that applies to the container.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "level" = mkOverride 1002 null;
          "role" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
          "user" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeccompProfile" =
      {

        options = {
          "localhostProfile" = mkOption {
            description = "localhostProfile indicates a profile defined in a file on the node should be used.\nThe profile must be preconfigured on the node to work.\nMust be a descending path, relative to the kubelet's configured seccomp profile location.\nMust be set if type is \"Localhost\". Must NOT be set for any other type.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "type indicates which kind of seccomp profile will be applied.\nValid options are:\n\nLocalhost - a profile defined in a file on the node should be used.\nRuntimeDefault - the container runtime default profile should be used.\nUnconfined - no profile should be applied.";
            type = types.str;
          };
        };

        config = {
          "localhostProfile" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions" =
      {

        options = {
          "gmsaCredentialSpec" = mkOption {
            description = "GMSACredentialSpec is where the GMSA admission webhook\n(https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the\nGMSA credential spec named by the GMSACredentialSpecName field.";
            type = (types.nullOr types.str);
          };
          "gmsaCredentialSpecName" = mkOption {
            description = "GMSACredentialSpecName is the name of the GMSA credential spec to use.";
            type = (types.nullOr types.str);
          };
          "hostProcess" = mkOption {
            description = "HostProcess determines if a container should be run as a 'Host Process' container.\nAll of a Pod's containers must have the same effective HostProcess value\n(it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).\nIn addition, if HostProcess is true then HostNetwork must also be set to true.";
            type = (types.nullOr types.bool);
          };
          "runAsUserName" = mkOption {
            description = "The UserName in Windows to run the entrypoint of the container process.\nDefaults to the user specified in image metadata if unspecified.\nMay also be set in PodSecurityContext. If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "gmsaCredentialSpec" = mkOverride 1002 null;
          "gmsaCredentialSpecName" = mkOverride 1002 null;
          "hostProcess" = mkOverride 1002 null;
          "runAsUserName" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts" =
      {

        options = {
          "mountPath" = mkOption {
            description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
            type = types.str;
          };
          "mountPropagation" = mkOption {
            description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
            type = (types.nullOr types.str);
          };
          "name" = mkOption {
            description = "This must match the Name of a Volume.";
            type = types.str;
          };
          "readOnly" = mkOption {
            description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
            type = (types.nullOr types.bool);
          };
          "recursiveReadOnly" = mkOption {
            description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
            type = (types.nullOr types.str);
          };
          "subPath" = mkOption {
            description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
            type = (types.nullOr types.str);
          };
          "subPathExpr" = mkOption {
            description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "mountPropagation" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
          "recursiveReadOnly" = mkOverride 1002 null;
          "subPath" = mkOverride 1002 null;
          "subPathExpr" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch" = {

      options = {
        "type" = mkOption {
          description = "Type is the type of merge operation to perform\n\nBy default, StrategicMerge is used as the patch type.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Object contains the raw configuration for merged object";
          type = types.unspecified;
        };
      };

      config = {
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod" = {

      options = {
        "affinity" = mkOption {
          description = "If specified, the pod's scheduling constraints.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity"
            )
          );
        };
        "annotations" = mkOption {
          description = "Annotations are the annotations that should be appended to the pods.\nBy default, no pod annotations are appended.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets is an optional list of references to secrets\nin the same namespace to use for pulling any of the images used by this PodSpec.\nIf specified, these secrets will be passed to individual puller implementations for them to use.\nMore info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "labels" = mkOption {
          description = "Labels are the additional labels that should be tagged to the pods.\nBy default, no additional pod labels are tagged.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector is a selector which must be true for the pod to fit on a node.\nSelector which must match a node's labels for the pod to be scheduled on that node.\nMore info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName indicates the importance of a Pod relative to other Pods.\nIf a PriorityClassName is not specified, the pod priority will be default or zero if there is no default.\nMore info: https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/";
          type = (types.nullOr types.str);
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nOptional: Defaults to empty.  See type description for default values of each field.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext"
            )
          );
        };
        "tolerations" = mkOption {
          description = "If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations"
              )
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints describes how a group of pods ought to spread across topology\ndomains. Scheduler will schedule pods in a way which abides by the constraints.\nAll topologySpreadConstraints are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints"
              )
            )
          );
        };
        "volumes" = mkOption {
          description = "Volumes that can be mounted by containers belonging to the pod.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "annotations" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity" = {

      options = {
        "nodeAffinity" = mkOption {
          description = "Describes node affinity scheduling rules for the pod.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinity"
            )
          );
        };
        "podAffinity" = mkOption {
          description = "Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinity"
            )
          );
        };
        "podAntiAffinity" = mkOption {
          description = "Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinity"
            )
          );
        };
      };

      config = {
        "nodeAffinity" = mkOverride 1002 null;
        "podAffinity" = mkOverride 1002 null;
        "podAntiAffinity" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinity" =
      {

        options = {
          "preferredDuringSchedulingIgnoredDuringExecution" = mkOption {
            description = "The scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions specified by this field, but it may choose\na node that violates one or more of the expressions. The node that is\nmost preferred is the one with the greatest sum of weights, i.e.\nfor each node that meets all of the scheduling requirements (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\" to the sum if the node matches the corresponding matchExpressions; the\nnode(s) with the highest sum are the most preferred.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"
                )
              )
            );
          };
          "requiredDuringSchedulingIgnoredDuringExecution" = mkOption {
            description = "If the affinity requirements specified by this field are not met at\nscheduling time, the pod will not be scheduled onto the node.\nIf the affinity requirements specified by this field cease to be met\nat some point during pod execution (e.g. due to an update), the system\nmay or may not try to eventually evict the pod from its node.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"
              )
            );
          };
        };

        config = {
          "preferredDuringSchedulingIgnoredDuringExecution" = mkOverride 1002 null;
          "requiredDuringSchedulingIgnoredDuringExecution" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution" =
      {

        options = {
          "preference" = mkOption {
            description = "A node selector term, associated with the corresponding weight.";
            type = (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference"
            );
          };
          "weight" = mkOption {
            description = "Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.";
            type = types.int;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "A list of node selector requirements by node's labels.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"
                )
              )
            );
          };
          "matchFields" = mkOption {
            description = "A list of node selector requirements by node's fields.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"
                )
              )
            );
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchFields" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "The label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.";
            type = types.str;
          };
          "values" = mkOption {
            description = "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields" =
      {

        options = {
          "key" = mkOption {
            description = "The label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.";
            type = types.str;
          };
          "values" = mkOption {
            description = "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution" =
      {

        options = {
          "nodeSelectorTerms" = mkOption {
            description = "Required. A list of node selector terms. The terms are ORed.";
            type = (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"
              )
            );
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "A list of node selector requirements by node's labels.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"
                )
              )
            );
          };
          "matchFields" = mkOption {
            description = "A list of node selector requirements by node's fields.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"
                )
              )
            );
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchFields" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "The label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.";
            type = types.str;
          };
          "values" = mkOption {
            description = "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields" =
      {

        options = {
          "key" = mkOption {
            description = "The label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.";
            type = types.str;
          };
          "values" = mkOption {
            description = "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinity" =
      {

        options = {
          "preferredDuringSchedulingIgnoredDuringExecution" = mkOption {
            description = "The scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions specified by this field, but it may choose\na node that violates one or more of the expressions. The node that is\nmost preferred is the one with the greatest sum of weights, i.e.\nfor each node that meets all of the scheduling requirements (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the\nnode(s) with the highest sum are the most preferred.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"
                )
              )
            );
          };
          "requiredDuringSchedulingIgnoredDuringExecution" = mkOption {
            description = "If the affinity requirements specified by this field are not met at\nscheduling time, the pod will not be scheduled onto the node.\nIf the affinity requirements specified by this field cease to be met\nat some point during pod execution (e.g. due to a pod label update), the\nsystem may or may not try to eventually evict the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"
                )
              )
            );
          };
        };

        config = {
          "preferredDuringSchedulingIgnoredDuringExecution" = mkOverride 1002 null;
          "requiredDuringSchedulingIgnoredDuringExecution" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution" =
      {

        options = {
          "podAffinityTerm" = mkOption {
            description = "Required. A pod affinity term, associated with the corresponding weight.";
            type = (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm"
            );
          };
          "weight" = mkOption {
            description = "weight associated with matching the corresponding podAffinityTerm,\nin the range 1-100.";
            type = types.int;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm" =
      {

        options = {
          "labelSelector" = mkOption {
            description = "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"
              )
            );
          };
          "matchLabelKeys" = mkOption {
            description = "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "mismatchLabelKeys" = mkOption {
            description = "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "namespaceSelector" = mkOption {
            description = "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"
              )
            );
          };
          "namespaces" = mkOption {
            description = "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".";
            type = (types.nullOr (types.listOf types.str));
          };
          "topologyKey" = mkOption {
            description = "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.";
            type = types.str;
          };
        };

        config = {
          "labelSelector" = mkOverride 1002 null;
          "matchLabelKeys" = mkOverride 1002 null;
          "mismatchLabelKeys" = mkOverride 1002 null;
          "namespaceSelector" = mkOverride 1002 null;
          "namespaces" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution" =
      {

        options = {
          "labelSelector" = mkOption {
            description = "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"
              )
            );
          };
          "matchLabelKeys" = mkOption {
            description = "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "mismatchLabelKeys" = mkOption {
            description = "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "namespaceSelector" = mkOption {
            description = "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"
              )
            );
          };
          "namespaces" = mkOption {
            description = "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".";
            type = (types.nullOr (types.listOf types.str));
          };
          "topologyKey" = mkOption {
            description = "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.";
            type = types.str;
          };
        };

        config = {
          "labelSelector" = mkOverride 1002 null;
          "matchLabelKeys" = mkOverride 1002 null;
          "mismatchLabelKeys" = mkOverride 1002 null;
          "namespaceSelector" = mkOverride 1002 null;
          "namespaces" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinity" =
      {

        options = {
          "preferredDuringSchedulingIgnoredDuringExecution" = mkOption {
            description = "The scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity expressions specified by this field, but it may choose\na node that violates one or more of the expressions. The node that is\nmost preferred is the one with the greatest sum of weights, i.e.\nfor each node that meets all of the scheduling requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions, etc.),\ncompute a sum by iterating through the elements of this field and subtracting\n\"weight\" from the sum if the node has pods which matches the corresponding podAffinityTerm; the\nnode(s) with the highest sum are the most preferred.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"
                )
              )
            );
          };
          "requiredDuringSchedulingIgnoredDuringExecution" = mkOption {
            description = "If the anti-affinity requirements specified by this field are not met at\nscheduling time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements specified by this field cease to be met\nat some point during pod execution (e.g. due to a pod label update), the\nsystem may or may not try to eventually evict the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"
                )
              )
            );
          };
        };

        config = {
          "preferredDuringSchedulingIgnoredDuringExecution" = mkOverride 1002 null;
          "requiredDuringSchedulingIgnoredDuringExecution" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution" =
      {

        options = {
          "podAffinityTerm" = mkOption {
            description = "Required. A pod affinity term, associated with the corresponding weight.";
            type = (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm"
            );
          };
          "weight" = mkOption {
            description = "weight associated with matching the corresponding podAffinityTerm,\nin the range 1-100.";
            type = types.int;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm" =
      {

        options = {
          "labelSelector" = mkOption {
            description = "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"
              )
            );
          };
          "matchLabelKeys" = mkOption {
            description = "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "mismatchLabelKeys" = mkOption {
            description = "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "namespaceSelector" = mkOption {
            description = "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"
              )
            );
          };
          "namespaces" = mkOption {
            description = "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".";
            type = (types.nullOr (types.listOf types.str));
          };
          "topologyKey" = mkOption {
            description = "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.";
            type = types.str;
          };
        };

        config = {
          "labelSelector" = mkOverride 1002 null;
          "matchLabelKeys" = mkOverride 1002 null;
          "mismatchLabelKeys" = mkOverride 1002 null;
          "namespaceSelector" = mkOverride 1002 null;
          "namespaces" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution" =
      {

        options = {
          "labelSelector" = mkOption {
            description = "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"
              )
            );
          };
          "matchLabelKeys" = mkOption {
            description = "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "mismatchLabelKeys" = mkOption {
            description = "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "namespaceSelector" = mkOption {
            description = "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"
              )
            );
          };
          "namespaces" = mkOption {
            description = "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".";
            type = (types.nullOr (types.listOf types.str));
          };
          "topologyKey" = mkOption {
            description = "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.";
            type = types.str;
          };
        };

        config = {
          "labelSelector" = mkOverride 1002 null;
          "matchLabelKeys" = mkOverride 1002 null;
          "mismatchLabelKeys" = mkOverride 1002 null;
          "namespaceSelector" = mkOverride 1002 null;
          "namespaces" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodImagePullSecrets" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext" =
      {

        options = {
          "appArmorProfile" = mkOption {
            description = "appArmorProfile is the AppArmor options to use by the containers in this pod.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextAppArmorProfile"
              )
            );
          };
          "fsGroup" = mkOption {
            description = "A special supplemental group that applies to all containers in a pod.\nSome volume types allow the Kubelet to change the ownership of that volume\nto be owned by the pod:\n\n1. The owning GID will be the FSGroup\n2. The setgid bit is set (new files created in the volume will be owned by FSGroup)\n3. The permission bits are OR'd with rw-rw----\n\nIf unset, the Kubelet will not modify the ownership and permissions of any volume.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.int);
          };
          "fsGroupChangePolicy" = mkOption {
            description = "fsGroupChangePolicy defines behavior of changing ownership and permission of the volume\nbefore being exposed inside Pod. This field will only apply to\nvolume types which support fsGroup based ownership(and permissions).\nIt will have no effect on ephemeral volume types such as: secret, configmaps\nand emptydir.\nValid values are \"OnRootMismatch\" and \"Always\". If not specified, \"Always\" is used.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.str);
          };
          "runAsGroup" = mkOption {
            description = "The GID to run the entrypoint of the container process.\nUses runtime default if unset.\nMay also be set in SecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence\nfor that container.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.int);
          };
          "runAsNonRoot" = mkOption {
            description = "Indicates that the container must run as a non-root user.\nIf true, the Kubelet will validate the image at runtime to ensure that it\ndoes not run as UID 0 (root) and fail to start the container if it does.\nIf unset or false, no such validation will be performed.\nMay also be set in SecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.";
            type = (types.nullOr types.bool);
          };
          "runAsUser" = mkOption {
            description = "The UID to run the entrypoint of the container process.\nDefaults to user specified in image metadata if unspecified.\nMay also be set in SecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence\nfor that container.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.int);
          };
          "seLinuxChangePolicy" = mkOption {
            description = "seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.\nIt has no effect on nodes that do not support SELinux or to volumes does not support SELinux.\nValid values are \"MountOption\" and \"Recursive\".\n\n\"Recursive\" means relabeling of all files on all Pod volumes by the container runtime.\nThis may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.\n\n\"MountOption\" mounts all eligible Pod volumes with `-o context` mount option.\nThis requires all Pods that share the same volume to use the same SELinux label.\nIt is not possible to share the same volume among privileged and unprivileged Pods.\nEligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes\nwhose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their\nCSIDriver instance. Other volumes are always re-labelled recursively.\n\"MountOption\" value is allowed only when SELinuxMount feature gate is enabled.\n\nIf not specified and SELinuxMount feature gate is enabled, \"MountOption\" is used.\nIf not specified and SELinuxMount feature gate is disabled, \"MountOption\" is used for ReadWriteOncePod volumes\nand \"Recursive\" for all other volumes.\n\nThis field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.\n\nAll Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.str);
          };
          "seLinuxOptions" = mkOption {
            description = "The SELinux context to be applied to all containers.\nIf unspecified, the container runtime will allocate a random SELinux context for each\ncontainer.  May also be set in SecurityContext.  If set in\nboth SecurityContext and PodSecurityContext, the value specified in SecurityContext\ntakes precedence for that container.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions"
              )
            );
          };
          "seccompProfile" = mkOption {
            description = "The seccomp options to use by the containers in this pod.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeccompProfile"
              )
            );
          };
          "supplementalGroups" = mkOption {
            description = "A list of groups applied to the first process run in each container, in\naddition to the container's primary GID and fsGroup (if specified).  If\nthe SupplementalGroupsPolicy feature is enabled, the\nsupplementalGroupsPolicy field determines whether these are in addition\nto or instead of any group memberships defined in the container image.\nIf unspecified, no additional groups are added, though group memberships\ndefined in the container image may still be used, depending on the\nsupplementalGroupsPolicy field.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr (types.listOf types.int));
          };
          "supplementalGroupsPolicy" = mkOption {
            description = "Defines how supplemental groups of the first container processes are calculated.\nValid values are \"Merge\" and \"Strict\". If not specified, \"Merge\" is used.\n(Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled\nand the container runtime must implement support for this feature.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.str);
          };
          "sysctls" = mkOption {
            description = "Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported\nsysctls (by the container runtime) might fail to launch.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSysctls"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "windowsOptions" = mkOption {
            description = "The Windows specific settings applied to all containers.\nIf unspecified, the options within a container's SecurityContext will be used.\nIf set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is linux.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions"
              )
            );
          };
        };

        config = {
          "appArmorProfile" = mkOverride 1002 null;
          "fsGroup" = mkOverride 1002 null;
          "fsGroupChangePolicy" = mkOverride 1002 null;
          "runAsGroup" = mkOverride 1002 null;
          "runAsNonRoot" = mkOverride 1002 null;
          "runAsUser" = mkOverride 1002 null;
          "seLinuxChangePolicy" = mkOverride 1002 null;
          "seLinuxOptions" = mkOverride 1002 null;
          "seccompProfile" = mkOverride 1002 null;
          "supplementalGroups" = mkOverride 1002 null;
          "supplementalGroupsPolicy" = mkOverride 1002 null;
          "sysctls" = mkOverride 1002 null;
          "windowsOptions" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextAppArmorProfile" =
      {

        options = {
          "localhostProfile" = mkOption {
            description = "localhostProfile indicates a profile loaded on the node that should be used.\nThe profile must be preconfigured on the node to work.\nMust match the loaded name of the profile.\nMust be set if and only if type is \"Localhost\".";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "type indicates which kind of AppArmor profile will be applied.\nValid options are:\n  Localhost - a profile pre-loaded on the node.\n  RuntimeDefault - the container runtime's default profile.\n  Unconfined - no AppArmor enforcement.";
            type = types.str;
          };
        };

        config = {
          "localhostProfile" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions" =
      {

        options = {
          "level" = mkOption {
            description = "Level is SELinux level label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "role" = mkOption {
            description = "Role is a SELinux role label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type is a SELinux type label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "user" = mkOption {
            description = "User is a SELinux user label that applies to the container.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "level" = mkOverride 1002 null;
          "role" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
          "user" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeccompProfile" =
      {

        options = {
          "localhostProfile" = mkOption {
            description = "localhostProfile indicates a profile defined in a file on the node should be used.\nThe profile must be preconfigured on the node to work.\nMust be a descending path, relative to the kubelet's configured seccomp profile location.\nMust be set if type is \"Localhost\". Must NOT be set for any other type.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "type indicates which kind of seccomp profile will be applied.\nValid options are:\n\nLocalhost - a profile defined in a file on the node should be used.\nRuntimeDefault - the container runtime default profile should be used.\nUnconfined - no profile should be applied.";
            type = types.str;
          };
        };

        config = {
          "localhostProfile" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSysctls" =
      {

        options = {
          "name" = mkOption {
            description = "Name of a property to set";
            type = types.str;
          };
          "value" = mkOption {
            description = "Value of a property to set";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions" =
      {

        options = {
          "gmsaCredentialSpec" = mkOption {
            description = "GMSACredentialSpec is where the GMSA admission webhook\n(https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the\nGMSA credential spec named by the GMSACredentialSpecName field.";
            type = (types.nullOr types.str);
          };
          "gmsaCredentialSpecName" = mkOption {
            description = "GMSACredentialSpecName is the name of the GMSA credential spec to use.";
            type = (types.nullOr types.str);
          };
          "hostProcess" = mkOption {
            description = "HostProcess determines if a container should be run as a 'Host Process' container.\nAll of a Pod's containers must have the same effective HostProcess value\n(it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).\nIn addition, if HostProcess is true then HostNetwork must also be set to true.";
            type = (types.nullOr types.bool);
          };
          "runAsUserName" = mkOption {
            description = "The UserName in Windows to run the entrypoint of the container process.\nDefaults to the user specified in image metadata if unspecified.\nMay also be set in PodSecurityContext. If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "gmsaCredentialSpec" = mkOverride 1002 null;
          "gmsaCredentialSpecName" = mkOverride 1002 null;
          "hostProcess" = mkOverride 1002 null;
          "runAsUserName" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists, Equal, Lt, and Gt. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.\nLt and Gt perform numeric comparisons (requires feature gate TaintTolerationComparisonOperators).";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints" =
      {

        options = {
          "labelSelector" = mkOption {
            description = "LabelSelector is used to find matching pods.\nPods that match this label selector are counted to determine the number of pods\nin their corresponding topology domain.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelector"
              )
            );
          };
          "matchLabelKeys" = mkOption {
            description = "MatchLabelKeys is a set of pod label keys to select the pods over which\nspreading will be calculated. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are ANDed with labelSelector\nto select the group of existing pods over which spreading will be calculated\nfor the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.\nMatchLabelKeys cannot be set when LabelSelector isn't set.\nKeys that don't exist in the incoming pod labels will\nbe ignored. A null or empty list means only match against labelSelector.\n\nThis is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).";
            type = (types.nullOr (types.listOf types.str));
          };
          "maxSkew" = mkOption {
            description = "MaxSkew describes the degree to which pods may be unevenly distributed.\nWhen `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference\nbetween the number of matching pods in the target topology and the global minimum.\nThe global minimum is the minimum number of matching pods in an eligible domain\nor zero if the number of eligible domains is less than MinDomains.\nFor example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same\nlabelSelector spread as 2/2/1:\nIn this case, the global minimum is 1.\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |   P   |\n- if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;\nscheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)\nviolate MaxSkew(1).\n- if MaxSkew is 2, incoming pod can be scheduled onto any zone.\nWhen `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence\nto topologies that satisfy it.\nIt's a required field. Default value is 1 and 0 is not allowed.";
            type = types.int;
          };
          "minDomains" = mkOption {
            description = "MinDomains indicates a minimum number of eligible domains.\nWhen the number of eligible domains with matching topology keys is less than minDomains,\nPod Topology Spread treats \"global minimum\" as 0, and then the calculation of Skew is performed.\nAnd when the number of eligible domains with matching topology keys equals or greater than minDomains,\nthis value has no effect on scheduling.\nAs a result, when the number of eligible domains is less than minDomains,\nscheduler won't schedule more than maxSkew Pods to those domains.\nIf value is nil, the constraint behaves as if MinDomains is equal to 1.\nValid values are integers greater than 0.\nWhen value is not nil, WhenUnsatisfiable must be DoNotSchedule.\n\nFor example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same\nlabelSelector spread as 2/2/2:\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |  P P  |\nThe number of domains is less than 5(MinDomains), so \"global minimum\" is treated as 0.\nIn this situation, new pod with the same labelSelector cannot be scheduled,\nbecause computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,\nit will violate MaxSkew.";
            type = (types.nullOr types.int);
          };
          "nodeAffinityPolicy" = mkOption {
            description = "NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector\nwhen calculating pod topology spread skew. Options are:\n- Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.\n- Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.\n\nIf this value is nil, the behavior is equivalent to the Honor policy.";
            type = (types.nullOr types.str);
          };
          "nodeTaintsPolicy" = mkOption {
            description = "NodeTaintsPolicy indicates how we will treat node taints when calculating\npod topology spread skew. Options are:\n- Honor: nodes without taints, along with tainted nodes for which the incoming pod\nhas a toleration, are included.\n- Ignore: node taints are ignored. All nodes are included.\n\nIf this value is nil, the behavior is equivalent to the Ignore policy.";
            type = (types.nullOr types.str);
          };
          "topologyKey" = mkOption {
            description = "TopologyKey is the key of node labels. Nodes that have a label with this key\nand identical values are considered to be in the same topology.\nWe consider each <key, value> as a \"bucket\", and try to put balanced number\nof pods into each bucket.\nWe define a domain as a particular instance of a topology.\nAlso, we define an eligible domain as a domain whose nodes meet the requirements of\nnodeAffinityPolicy and nodeTaintsPolicy.\ne.g. If TopologyKey is \"kubernetes.io/hostname\", each Node is a domain of that topology.\nAnd, if TopologyKey is \"topology.kubernetes.io/zone\", each zone is a domain of that topology.\nIt's a required field.";
            type = types.str;
          };
          "whenUnsatisfiable" = mkOption {
            description = "WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy\nthe spread constraint.\n- DoNotSchedule (default) tells the scheduler not to schedule it.\n- ScheduleAnyway tells the scheduler to schedule the pod in any location,\n  but giving higher precedence to topologies that would help reduce the\n  skew.\nA constraint is considered \"Unsatisfiable\" for an incoming pod\nif and only if every possible node assignment for that pod would violate\n\"MaxSkew\" on some topology.\nFor example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same\nlabelSelector spread as 3/1/1:\n| zone1 | zone2 | zone3 |\n| P P P |   P   |   P   |\nIf WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled\nto zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies\nMaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler\nwon't make it *more* imbalanced.\nIt's a required field.";
            type = types.str;
          };
        };

        config = {
          "labelSelector" = mkOverride 1002 null;
          "matchLabelKeys" = mkOverride 1002 null;
          "minDomains" = mkOverride 1002 null;
          "nodeAffinityPolicy" = mkOverride 1002 null;
          "nodeTaintsPolicy" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes" = {

      options = {
        "awsElasticBlockStore" = mkOption {
          description = "awsElasticBlockStore represents an AWS Disk resource that is attached to a\nkubelet's host machine and then exposed to the pod.\nDeprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree\nawsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore"
            )
          );
        };
        "azureDisk" = mkOption {
          description = "azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.\nDeprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type\nare redirected to the disk.csi.azure.com CSI driver.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk"
            )
          );
        };
        "azureFile" = mkOption {
          description = "azureFile represents an Azure File Service mount on the host and bind mount to the pod.\nDeprecated: AzureFile is deprecated. All operations for the in-tree azureFile type\nare redirected to the file.csi.azure.com CSI driver.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile"
            )
          );
        };
        "cephfs" = mkOption {
          description = "cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.\nDeprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs"
            )
          );
        };
        "cinder" = mkOption {
          description = "cinder represents a cinder volume attached and mounted on kubelets host machine.\nDeprecated: Cinder is deprecated. All operations for the in-tree cinder type\nare redirected to the cinder.csi.openstack.org CSI driver.\nMore info: https://examples.k8s.io/mysql-cinder-pd/README.md";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder"
            )
          );
        };
        "configMap" = mkOption {
          description = "configMap represents a configMap that should populate this volume";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap"
            )
          );
        };
        "csi" = mkOption {
          description = "csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi"
            )
          );
        };
        "downwardAPI" = mkOption {
          description = "downwardAPI represents downward API about the pod that should populate this volume";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPI"
            )
          );
        };
        "emptyDir" = mkOption {
          description = "emptyDir represents a temporary directory that shares a pod's lifetime.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDir"
            )
          );
        };
        "ephemeral" = mkOption {
          description = "ephemeral represents a volume that is handled by a cluster storage driver.\nThe volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,\nand deleted when the pod is removed.\n\nUse this if:\na) the volume is only needed while the pod runs,\nb) features of normal volumes like restoring from snapshot or capacity\n   tracking are needed,\nc) the storage driver is specified through a storage class, and\nd) the storage driver supports dynamic volume provisioning through\n   a PersistentVolumeClaim (see EphemeralVolumeSource for more\n   information on the connection between this volume type\n   and PersistentVolumeClaim).\n\nUse PersistentVolumeClaim or one of the vendor-specific\nAPIs for volumes that persist for longer than the lifecycle\nof an individual pod.\n\nUse CSI for light-weight local ephemeral volumes if the CSI driver is meant to\nbe used that way - see the documentation of the driver for\nmore information.\n\nA pod can use both types of ephemeral volumes and\npersistent volumes at the same time.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeral"
            )
          );
        };
        "fc" = mkOption {
          description = "fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc"
            )
          );
        };
        "flexVolume" = mkOption {
          description = "flexVolume represents a generic volume resource that is\nprovisioned/attached using an exec based plugin.\nDeprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume"
            )
          );
        };
        "flocker" = mkOption {
          description = "flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.\nDeprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlocker"
            )
          );
        };
        "gcePersistentDisk" = mkOption {
          description = "gcePersistentDisk represents a GCE Disk resource that is attached to a\nkubelet's host machine and then exposed to the pod.\nDeprecated: GCEPersistentDisk is deprecated. All operations for the in-tree\ngcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk"
            )
          );
        };
        "gitRepo" = mkOption {
          description = "gitRepo represents a git repository at a particular revision.\nDeprecated: GitRepo is deprecated. To provision a container with a git repo, mount an\nEmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir\ninto the Pod's container.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo"
            )
          );
        };
        "glusterfs" = mkOption {
          description = "glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.\nDeprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs"
            )
          );
        };
        "hostPath" = mkOption {
          description = "hostPath represents a pre-existing file or directory on the host\nmachine that is directly exposed to the container. This is generally\nused for system agents or other privileged things that are allowed\nto see the host machine. Most containers will NOT need this.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesHostPath"
            )
          );
        };
        "image" = mkOption {
          description = "image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.\nThe volume is resolved at pod startup depending on which PullPolicy value is provided:\n\n- Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.\n- Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.\n- IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\n\nThe volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.\nA failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.\nThe types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.\nThe OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.\nThe volume will be mounted read-only (ro) and non-executable files (noexec).\nSub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.\nThe field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesImage"
            )
          );
        };
        "iscsi" = mkOption {
          description = "iscsi represents an ISCSI Disk resource that is attached to a\nkubelet's host machine and then exposed to the pod.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes/#iscsi";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi"
            )
          );
        };
        "name" = mkOption {
          description = "name of the volume.\nMust be a DNS_LABEL and unique within the pod.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = types.str;
        };
        "nfs" = mkOption {
          description = "nfs represents an NFS mount on the host that shares a pod's lifetime\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#nfs";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs"
            )
          );
        };
        "persistentVolumeClaim" = mkOption {
          description = "persistentVolumeClaimVolumeSource represents a reference to a\nPersistentVolumeClaim in the same namespace.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPersistentVolumeClaim"
            )
          );
        };
        "photonPersistentDisk" = mkOption {
          description = "photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.\nDeprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPhotonPersistentDisk"
            )
          );
        };
        "portworxVolume" = mkOption {
          description = "portworxVolume represents a portworx volume attached and mounted on kubelets host machine.\nDeprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type\nare redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate\nis on.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume"
            )
          );
        };
        "projected" = mkOption {
          description = "projected items for all in one resources secrets, configmaps, and downward API";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjected"
            )
          );
        };
        "quobyte" = mkOption {
          description = "quobyte represents a Quobyte mount on the host that shares a pod's lifetime.\nDeprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte"
            )
          );
        };
        "rbd" = mkOption {
          description = "rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.\nDeprecated: RBD is deprecated and the in-tree rbd type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd"
            )
          );
        };
        "scaleIO" = mkOption {
          description = "scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.\nDeprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIO"
            )
          );
        };
        "secret" = mkOption {
          description = "secret represents a secret that should populate this volume.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#secret";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret"
            )
          );
        };
        "storageos" = mkOption {
          description = "storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.\nDeprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos"
            )
          );
        };
        "vsphereVolume" = mkOption {
          description = "vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.\nDeprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type\nare redirected to the csi.vsphere.vmware.com CSI driver.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume"
            )
          );
        };
      };

      config = {
        "awsElasticBlockStore" = mkOverride 1002 null;
        "azureDisk" = mkOverride 1002 null;
        "azureFile" = mkOverride 1002 null;
        "cephfs" = mkOverride 1002 null;
        "cinder" = mkOverride 1002 null;
        "configMap" = mkOverride 1002 null;
        "csi" = mkOverride 1002 null;
        "downwardAPI" = mkOverride 1002 null;
        "emptyDir" = mkOverride 1002 null;
        "ephemeral" = mkOverride 1002 null;
        "fc" = mkOverride 1002 null;
        "flexVolume" = mkOverride 1002 null;
        "flocker" = mkOverride 1002 null;
        "gcePersistentDisk" = mkOverride 1002 null;
        "gitRepo" = mkOverride 1002 null;
        "glusterfs" = mkOverride 1002 null;
        "hostPath" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "iscsi" = mkOverride 1002 null;
        "nfs" = mkOverride 1002 null;
        "persistentVolumeClaim" = mkOverride 1002 null;
        "photonPersistentDisk" = mkOverride 1002 null;
        "portworxVolume" = mkOverride 1002 null;
        "projected" = mkOverride 1002 null;
        "quobyte" = mkOverride 1002 null;
        "rbd" = mkOverride 1002 null;
        "scaleIO" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
        "storageos" = mkOverride 1002 null;
        "vsphereVolume" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore" =
      {

        options = {
          "fsType" = mkOption {
            description = "fsType is the filesystem type of the volume that you want to mount.\nTip: Ensure that the filesystem type is supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore";
            type = (types.nullOr types.str);
          };
          "partition" = mkOption {
            description = "partition is the partition in the volume that you want to mount.\nIf omitted, the default is to mount by volume name.\nExamples: For volume /dev/sda1, you specify the partition as \"1\".\nSimilarly, the volume partition for /dev/sda is \"0\" (or you can leave the property empty).";
            type = (types.nullOr types.int);
          };
          "readOnly" = mkOption {
            description = "readOnly value true will force the readOnly setting in VolumeMounts.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore";
            type = (types.nullOr types.bool);
          };
          "volumeID" = mkOption {
            description = "volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore";
            type = types.str;
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
          "partition" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk" =
      {

        options = {
          "cachingMode" = mkOption {
            description = "cachingMode is the Host Caching mode: None, Read Only, Read Write.";
            type = (types.nullOr types.str);
          };
          "diskName" = mkOption {
            description = "diskName is the Name of the data disk in the blob storage";
            type = types.str;
          };
          "diskURI" = mkOption {
            description = "diskURI is the URI of data disk in the blob storage";
            type = types.str;
          };
          "fsType" = mkOption {
            description = "fsType is Filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared";
            type = (types.nullOr types.str);
          };
          "readOnly" = mkOption {
            description = "readOnly Defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "cachingMode" = mkOverride 1002 null;
          "fsType" = mkOverride 1002 null;
          "kind" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile" =
      {

        options = {
          "readOnly" = mkOption {
            description = "readOnly defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
            type = (types.nullOr types.bool);
          };
          "secretName" = mkOption {
            description = "secretName is the  name of secret that contains Azure Storage Account Name and Key";
            type = types.str;
          };
          "shareName" = mkOption {
            description = "shareName is the azure share Name";
            type = types.str;
          };
        };

        config = {
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs" = {

      options = {
        "monitors" = mkOption {
          description = "monitors is Required: Monitors is a collection of Ceph monitors\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it";
          type = (types.listOf types.str);
        };
        "path" = mkOption {
          description = "path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /";
          type = (types.nullOr types.str);
        };
        "readOnly" = mkOption {
          description = "readOnly is Optional: Defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it";
          type = (types.nullOr types.bool);
        };
        "secretFile" = mkOption {
          description = "secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfsSecretRef"
            )
          );
        };
        "user" = mkOption {
          description = "user is optional: User is the rados user name, default is admin\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "path" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "secretFile" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
        "user" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfsSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder" = {

      options = {
        "fsType" = mkOption {
          description = "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://examples.k8s.io/mysql-cinder-pd/README.md";
          type = (types.nullOr types.str);
        };
        "readOnly" = mkOption {
          description = "readOnly defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.\nMore info: https://examples.k8s.io/mysql-cinder-pd/README.md";
          type = (types.nullOr types.bool);
        };
        "secretRef" = mkOption {
          description = "secretRef is optional: points to a secret object containing parameters used to connect\nto OpenStack.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinderSecretRef"
            )
          );
        };
        "volumeID" = mkOption {
          description = "volumeID used to identify the volume in cinder.\nMore info: https://examples.k8s.io/mysql-cinder-pd/README.md";
          type = types.str;
        };
      };

      config = {
        "fsType" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinderSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap" =
      {

        options = {
          "defaultMode" = mkOption {
            description = "defaultMode is optional: mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nDefaults to 0644.\nDirectories within the path are not affected by this setting.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "items" = mkOption {
            description = "items if unspecified, each key-value pair in the Data field of the referenced\nConfigMap will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the ConfigMap,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems"
                )
              )
            );
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "optional specify whether the ConfigMap or its keys must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "defaultMode" = mkOverride 1002 null;
          "items" = mkOverride 1002 null;
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems" =
      {

        options = {
          "key" = mkOption {
            description = "key is the key to project.";
            type = types.str;
          };
          "mode" = mkOption {
            description = "mode is Optional: mode bits used to set permissions on this file.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "path is the relative path of the file to map the key to.\nMay not be an absolute path.\nMay not contain the path element '..'.\nMay not start with the string '..'.";
            type = types.str;
          };
        };

        config = {
          "mode" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi" = {

      options = {
        "driver" = mkOption {
          description = "driver is the name of the CSI driver that handles this volume.\nConsult with your admin for the correct name as registered in the cluster.";
          type = types.str;
        };
        "fsType" = mkOption {
          description = "fsType to mount. Ex. \"ext4\", \"xfs\", \"ntfs\".\nIf not provided, the empty value is passed to the associated CSI driver\nwhich will determine the default filesystem to apply.";
          type = (types.nullOr types.str);
        };
        "nodePublishSecretRef" = mkOption {
          description = "nodePublishSecretRef is a reference to the secret object containing\nsensitive information to pass to the CSI driver to complete the CSI\nNodePublishVolume and NodeUnpublishVolume calls.\nThis field is optional, and  may be empty if no secret is required. If the\nsecret object contains more than one secret, all secret references are passed.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsiNodePublishSecretRef"
            )
          );
        };
        "readOnly" = mkOption {
          description = "readOnly specifies a read-only configuration for the volume.\nDefaults to false (read/write).";
          type = (types.nullOr types.bool);
        };
        "volumeAttributes" = mkOption {
          description = "volumeAttributes stores driver-specific properties that are passed to the CSI\ndriver. Consult your driver's documentation for supported values.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "fsType" = mkOverride 1002 null;
        "nodePublishSecretRef" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "volumeAttributes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsiNodePublishSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPI" =
      {

        options = {
          "defaultMode" = mkOption {
            description = "Optional: mode bits to use on created files by default. Must be a\nOptional: mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nDefaults to 0644.\nDirectories within the path are not affected by this setting.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "items" = mkOption {
            description = "Items is a list of downward API volume file";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPIItems"
                )
              )
            );
          };
        };

        config = {
          "defaultMode" = mkOverride 1002 null;
          "items" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPIItems" =
      {

        options = {
          "fieldRef" = mkOption {
            description = "Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPIItemsFieldRef"
              )
            );
          };
          "mode" = mkOption {
            description = "Optional: mode bits used to set permissions on this file, must be an octal value\nbetween 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'";
            type = types.str;
          };
          "resourceFieldRef" = mkOption {
            description = "Selects a resource of the container: only resources limits and requests\n(limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPIItemsResourceFieldRef"
              )
            );
          };
        };

        config = {
          "fieldRef" = mkOverride 1002 null;
          "mode" = mkOverride 1002 null;
          "resourceFieldRef" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPIItemsFieldRef" =
      {

        options = {
          "apiVersion" = mkOption {
            description = "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".";
            type = (types.nullOr types.str);
          };
          "fieldPath" = mkOption {
            description = "Path of the field to select in the specified API version.";
            type = types.str;
          };
        };

        config = {
          "apiVersion" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPIItemsResourceFieldRef" =
      {

        options = {
          "containerName" = mkOption {
            description = "Container name: required for volumes, optional for env vars";
            type = (types.nullOr types.str);
          };
          "divisor" = mkOption {
            description = "Specifies the output format of the exposed resources, defaults to \"1\"";
            type = (types.nullOr (types.either types.int types.str));
          };
          "resource" = mkOption {
            description = "Required: resource to select";
            type = types.str;
          };
        };

        config = {
          "containerName" = mkOverride 1002 null;
          "divisor" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDir" =
      {

        options = {
          "medium" = mkOption {
            description = "medium represents what type of storage medium should back this directory.\nThe default is \"\" which means to use the node's default medium.\nMust be an empty string (default) or Memory.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
            type = (types.nullOr types.str);
          };
          "sizeLimit" = mkOption {
            description = "sizeLimit is the total amount of local storage required for this EmptyDir volume.\nThe size limit is also applicable for memory medium.\nThe maximum usage on memory medium EmptyDir would be the minimum value between\nthe SizeLimit specified here and the sum of memory limits of all containers in a pod.\nThe default is nil which means that the limit is undefined.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
            type = (types.nullOr (types.either types.int types.str));
          };
        };

        config = {
          "medium" = mkOverride 1002 null;
          "sizeLimit" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeral" =
      {

        options = {
          "volumeClaimTemplate" = mkOption {
            description = "Will be used to create a stand-alone PVC to provision the volume.\nThe pod in which this EphemeralVolumeSource is embedded will be the\nowner of the PVC, i.e. the PVC will be deleted together with the\npod.  The name of the PVC will be `<pod name>-<volume name>` where\n`<volume name>` is the name from the `PodSpec.Volumes` array\nentry. Pod validation will reject the pod if the concatenated name\nis not valid for a PVC (for example, too long).\n\nAn existing PVC with that name that is not owned by the pod\nwill *not* be used for the pod to avoid using an unrelated\nvolume by mistake. Starting the pod is then blocked until\nthe unrelated PVC is removed. If such a pre-created PVC is\nmeant to be used by the pod, the PVC has to updated with an\nowner reference to the pod once the pod exists. Normally\nthis should not be necessary, but it may be useful when\nmanually reconstructing a broken cluster.\n\nThis field is read-only and no changes will be made by Kubernetes\nto the PVC after it has been created.\n\nRequired, must not be nil.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplate"
              )
            );
          };
        };

        config = {
          "volumeClaimTemplate" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplate" =
      {

        options = {
          "metadata" = mkOption {
            description = "May contain labels and annotations that will be copied into the PVC\nwhen creating it. No other fields are allowed and will be rejected during\nvalidation.";
            type = (types.nullOr types.attrs);
          };
          "spec" = mkOption {
            description = "The specification for the PersistentVolumeClaim. The entire content is\ncopied unchanged into the PVC that gets created from this\ntemplate. The same fields as in a PersistentVolumeClaim\nare also valid here.";
            type = (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec"
            );
          };
        };

        config = {
          "metadata" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec" =
      {

        options = {
          "accessModes" = mkOption {
            description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
            type = (types.nullOr (types.listOf types.str));
          };
          "dataSource" = mkOption {
            description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource"
              )
            );
          };
          "dataSourceRef" = mkOption {
            description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef"
              )
            );
          };
          "resources" = mkOption {
            description = "resources represents the minimum resources the volume should have.\nUsers are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResources"
              )
            );
          };
          "selector" = mkOption {
            description = "selector is a label query over volumes to consider for binding.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelector"
              )
            );
          };
          "storageClassName" = mkOption {
            description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
            type = (types.nullOr types.str);
          };
          "volumeAttributesClassName" = mkOption {
            description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
            type = (types.nullOr types.str);
          };
          "volumeMode" = mkOption {
            description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
            type = (types.nullOr types.str);
          };
          "volumeName" = mkOption {
            description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "accessModes" = mkOverride 1002 null;
          "dataSource" = mkOverride 1002 null;
          "dataSourceRef" = mkOverride 1002 null;
          "resources" = mkOverride 1002 null;
          "selector" = mkOverride 1002 null;
          "storageClassName" = mkOverride 1002 null;
          "volumeAttributesClassName" = mkOverride 1002 null;
          "volumeMode" = mkOverride 1002 null;
          "volumeName" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource" =
      {

        options = {
          "apiGroup" = mkOption {
            description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "Kind is the type of resource being referenced";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name is the name of resource being referenced";
            type = types.str;
          };
        };

        config = {
          "apiGroup" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef" =
      {

        options = {
          "apiGroup" = mkOption {
            description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "Kind is the type of resource being referenced";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name is the name of resource being referenced";
            type = types.str;
          };
          "namespace" = mkOption {
            description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "apiGroup" = mkOverride 1002 null;
          "namespace" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResources" =
      {

        options = {
          "limits" = mkOption {
            description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
          "requests" = mkOption {
            description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
        };

        config = {
          "limits" = mkOverride 1002 null;
          "requests" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc" = {

      options = {
        "fsType" = mkOption {
          description = "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.";
          type = (types.nullOr types.str);
        };
        "lun" = mkOption {
          description = "lun is Optional: FC target lun number";
          type = (types.nullOr types.int);
        };
        "readOnly" = mkOption {
          description = "readOnly is Optional: Defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
          type = (types.nullOr types.bool);
        };
        "targetWWNs" = mkOption {
          description = "targetWWNs is Optional: FC target worldwide names (WWNs)";
          type = (types.nullOr (types.listOf types.str));
        };
        "wwids" = mkOption {
          description = "wwids Optional: FC volume world wide identifiers (wwids)\nEither wwids or combination of targetWWNs and lun must be set, but not both simultaneously.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "fsType" = mkOverride 1002 null;
        "lun" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "targetWWNs" = mkOverride 1002 null;
        "wwids" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume" =
      {

        options = {
          "driver" = mkOption {
            description = "driver is the name of the driver to use for this volume.";
            type = types.str;
          };
          "fsType" = mkOption {
            description = "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends on FlexVolume script.";
            type = (types.nullOr types.str);
          };
          "options" = mkOption {
            description = "options is Optional: this field holds extra command options if any.";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "readOnly" = mkOption {
            description = "readOnly is Optional: defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
            type = (types.nullOr types.bool);
          };
          "secretRef" = mkOption {
            description = "secretRef is Optional: secretRef is reference to the secret object containing\nsensitive information to pass to the plugin scripts. This may be\nempty if no secret object is specified. If the secret object\ncontains more than one secret, all secrets are passed to the plugin\nscripts.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolumeSecretRef"
              )
            );
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
          "options" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
          "secretRef" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolumeSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlocker" = {

      options = {
        "datasetName" = mkOption {
          description = "datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker\nshould be considered as deprecated";
          type = (types.nullOr types.str);
        };
        "datasetUUID" = mkOption {
          description = "datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "datasetName" = mkOverride 1002 null;
        "datasetUUID" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk" =
      {

        options = {
          "fsType" = mkOption {
            description = "fsType is filesystem type of the volume that you want to mount.\nTip: Ensure that the filesystem type is supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk";
            type = (types.nullOr types.str);
          };
          "partition" = mkOption {
            description = "partition is the partition in the volume that you want to mount.\nIf omitted, the default is to mount by volume name.\nExamples: For volume /dev/sda1, you specify the partition as \"1\".\nSimilarly, the volume partition for /dev/sda is \"0\" (or you can leave the property empty).\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk";
            type = (types.nullOr types.int);
          };
          "pdName" = mkOption {
            description = "pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk";
            type = types.str;
          };
          "readOnly" = mkOption {
            description = "readOnly here will force the ReadOnly setting in VolumeMounts.\nDefaults to false.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
          "partition" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo" = {

      options = {
        "directory" = mkOption {
          description = "directory is the target directory name.\nMust not contain or start with '..'.  If '.' is supplied, the volume directory will be the\ngit repository.  Otherwise, if specified, the volume will contain the git repository in\nthe subdirectory with the given name.";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "repository is the URL";
          type = types.str;
        };
        "revision" = mkOption {
          description = "revision is the commit hash for the specified revision.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "directory" = mkOverride 1002 null;
        "revision" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs" =
      {

        options = {
          "endpoints" = mkOption {
            description = "endpoints is the endpoint name that details Glusterfs topology.";
            type = types.str;
          };
          "path" = mkOption {
            description = "path is the Glusterfs volume path.\nMore info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod";
            type = types.str;
          };
          "readOnly" = mkOption {
            description = "readOnly here will force the Glusterfs volume to be mounted with read-only permissions.\nDefaults to false.\nMore info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesHostPath" =
      {

        options = {
          "path" = mkOption {
            description = "path of the directory on the host.\nIf the path is a symlink, it will follow the link to the real path.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath";
            type = types.str;
          };
          "type" = mkOption {
            description = "type for HostPath Volume\nDefaults to \"\"\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "type" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "Policy for pulling OCI objects. Possible values are:\nAlways: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.\nNever: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.\nIfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\nDefaults to Always if :latest tag is specified, or IfNotPresent otherwise.";
          type = (types.nullOr types.str);
        };
        "reference" = mkOption {
          description = "Required: Image or artifact reference to be used.\nBehaves in the same way as pod.spec.containers[*].image.\nPull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.\nMore info: https://kubernetes.io/docs/concepts/containers/images\nThis field is optional to allow higher level config management to default or override\ncontainer images in workload controllers like Deployments and StatefulSets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "reference" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi" = {

      options = {
        "chapAuthDiscovery" = mkOption {
          description = "chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication";
          type = (types.nullOr types.bool);
        };
        "chapAuthSession" = mkOption {
          description = "chapAuthSession defines whether support iSCSI Session CHAP authentication";
          type = (types.nullOr types.bool);
        };
        "fsType" = mkOption {
          description = "fsType is the filesystem type of the volume that you want to mount.\nTip: Ensure that the filesystem type is supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi";
          type = (types.nullOr types.str);
        };
        "initiatorName" = mkOption {
          description = "initiatorName is the custom iSCSI Initiator Name.\nIf initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface\n<target portal>:<volume name> will be created for the connection.";
          type = (types.nullOr types.str);
        };
        "iqn" = mkOption {
          description = "iqn is the target iSCSI Qualified Name.";
          type = types.str;
        };
        "iscsiInterface" = mkOption {
          description = "iscsiInterface is the interface Name that uses an iSCSI transport.\nDefaults to 'default' (tcp).";
          type = (types.nullOr types.str);
        };
        "lun" = mkOption {
          description = "lun represents iSCSI Target Lun number.";
          type = types.int;
        };
        "portals" = mkOption {
          description = "portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port\nis other than default (typically TCP ports 860 and 3260).";
          type = (types.nullOr (types.listOf types.str));
        };
        "readOnly" = mkOption {
          description = "readOnly here will force the ReadOnly setting in VolumeMounts.\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "secretRef" = mkOption {
          description = "secretRef is the CHAP Secret for iSCSI target and initiator authentication";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsiSecretRef"
            )
          );
        };
        "targetPortal" = mkOption {
          description = "targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port\nis other than default (typically TCP ports 860 and 3260).";
          type = types.str;
        };
      };

      config = {
        "chapAuthDiscovery" = mkOverride 1002 null;
        "chapAuthSession" = mkOverride 1002 null;
        "fsType" = mkOverride 1002 null;
        "initiatorName" = mkOverride 1002 null;
        "iscsiInterface" = mkOverride 1002 null;
        "portals" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsiSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs" = {

      options = {
        "path" = mkOption {
          description = "path that is exported by the NFS server.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#nfs";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "readOnly here will force the NFS export to be mounted with read-only permissions.\nDefaults to false.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#nfs";
          type = (types.nullOr types.bool);
        };
        "server" = mkOption {
          description = "server is the hostname or IP address of the NFS server.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#nfs";
          type = types.str;
        };
      };

      config = {
        "readOnly" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPersistentVolumeClaim" =
      {

        options = {
          "claimName" = mkOption {
            description = "claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
            type = types.str;
          };
          "readOnly" = mkOption {
            description = "readOnly Will force the ReadOnly setting in VolumeMounts.\nDefault false.";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPhotonPersistentDisk" =
      {

        options = {
          "fsType" = mkOption {
            description = "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.";
            type = (types.nullOr types.str);
          };
          "pdID" = mkOption {
            description = "pdID is the ID that identifies Photon Controller persistent disk";
            type = types.str;
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume" =
      {

        options = {
          "fsType" = mkOption {
            description = "fSType represents the filesystem type to mount\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\". Implicitly inferred to be \"ext4\" if unspecified.";
            type = (types.nullOr types.str);
          };
          "readOnly" = mkOption {
            description = "readOnly defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
            type = (types.nullOr types.bool);
          };
          "volumeID" = mkOption {
            description = "volumeID uniquely identifies a Portworx volume";
            type = types.str;
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjected" =
      {

        options = {
          "defaultMode" = mkOption {
            description = "defaultMode are the mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nDirectories within the path are not affected by this setting.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "sources" = mkOption {
            description = "sources is the list of volume projections. Each entry in this list\nhandles one source.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources"
                )
              )
            );
          };
        };

        config = {
          "defaultMode" = mkOverride 1002 null;
          "sources" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources" =
      {

        options = {
          "clusterTrustBundle" = mkOption {
            description = "ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field\nof ClusterTrustBundle objects in an auto-updating file.\n\nAlpha, gated by the ClusterTrustBundleProjection feature gate.\n\nClusterTrustBundle objects can either be selected by name, or by the\ncombination of signer name and a label selector.\n\nKubelet performs aggressive normalization of the PEM contents written\ninto the pod filesystem.  Esoteric PEM features such as inter-block\ncomments and block headers are stripped.  Certificates are deduplicated.\nThe ordering of certificates within the file is arbitrary, and Kubelet\nmay change the order over time.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle"
              )
            );
          };
          "configMap" = mkOption {
            description = "configMap information about the configMap data to project";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap"
              )
            );
          };
          "downwardAPI" = mkOption {
            description = "downwardAPI information about the downwardAPI data to project";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPI"
              )
            );
          };
          "podCertificate" = mkOption {
            description = "Projects an auto-rotating credential bundle (private key and certificate\nchain) that the pod can use either as a TLS client or server.\n\nKubelet generates a private key and uses it to send a\nPodCertificateRequest to the named signer.  Once the signer approves the\nrequest and issues a certificate chain, Kubelet writes the key and\ncertificate chain to the pod filesystem.  The pod does not start until\ncertificates have been issued for each podCertificate projected volume\nsource in its spec.\n\nKubelet will begin trying to rotate the certificate at the time indicated\nby the signer using the PodCertificateRequest.Status.BeginRefreshAt\ntimestamp.\n\nKubelet can write a single file, indicated by the credentialBundlePath\nfield, or separate files, indicated by the keyPath and\ncertificateChainPath fields.\n\nThe credential bundle is a single file in PEM format.  The first PEM\nentry is the private key (in PKCS#8 format), and the remaining PEM\nentries are the certificate chain issued by the signer (typically,\nsigners will return their certificate chain in leaf-to-root order).\n\nPrefer using the credential bundle format, since your application code\ncan read it atomically.  If you use keyPath and certificateChainPath,\nyour application must make two separate file reads. If these coincide\nwith a certificate rotation, it is possible that the private key and leaf\ncertificate you read may not correspond to each other.  Your application\nwill need to check for this condition, and re-read until they are\nconsistent.\n\nThe named signer controls chooses the format of the certificate it\nissues; consult the signer implementation's documentation to learn how to\nuse the certificates it issues.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate"
              )
            );
          };
          "secret" = mkOption {
            description = "secret information about the secret data to project";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret"
              )
            );
          };
          "serviceAccountToken" = mkOption {
            description = "serviceAccountToken is information about the serviceAccountToken data to project";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken"
              )
            );
          };
        };

        config = {
          "clusterTrustBundle" = mkOverride 1002 null;
          "configMap" = mkOverride 1002 null;
          "downwardAPI" = mkOverride 1002 null;
          "podCertificate" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
          "serviceAccountToken" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle" =
      {

        options = {
          "labelSelector" = mkOption {
            description = "Select all ClusterTrustBundles that match this label selector.  Only has\neffect if signerName is set.  Mutually-exclusive with name.  If unset,\ninterpreted as \"match nothing\".  If set but empty, interpreted as \"match\neverything\".";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelector"
              )
            );
          };
          "name" = mkOption {
            description = "Select a single ClusterTrustBundle by object name.  Mutually-exclusive\nwith signerName and labelSelector.";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "If true, don't block pod startup if the referenced ClusterTrustBundle(s)\naren't available.  If using name, then the named ClusterTrustBundle is\nallowed not to exist.  If using signerName, then the combination of\nsignerName and labelSelector is allowed to match zero\nClusterTrustBundles.";
            type = (types.nullOr types.bool);
          };
          "path" = mkOption {
            description = "Relative path from the volume root to write the bundle.";
            type = types.str;
          };
          "signerName" = mkOption {
            description = "Select all ClusterTrustBundles that match this signer name.\nMutually-exclusive with name.  The contents of all selected\nClusterTrustBundles will be unified and deduplicated.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "labelSelector" = mkOverride 1002 null;
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
          "signerName" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap" =
      {

        options = {
          "items" = mkOption {
            description = "items if unspecified, each key-value pair in the Data field of the referenced\nConfigMap will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the ConfigMap,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems"
                )
              )
            );
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "optional specify whether the ConfigMap or its keys must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "items" = mkOverride 1002 null;
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems" =
      {

        options = {
          "key" = mkOption {
            description = "key is the key to project.";
            type = types.str;
          };
          "mode" = mkOption {
            description = "mode is Optional: mode bits used to set permissions on this file.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "path is the relative path of the file to map the key to.\nMay not be an absolute path.\nMay not contain the path element '..'.\nMay not start with the string '..'.";
            type = types.str;
          };
        };

        config = {
          "mode" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPI" =
      {

        options = {
          "items" = mkOption {
            description = "Items is a list of DownwardAPIVolume file";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPIItems"
                )
              )
            );
          };
        };

        config = {
          "items" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPIItems" =
      {

        options = {
          "fieldRef" = mkOption {
            description = "Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPIItemsFieldRef"
              )
            );
          };
          "mode" = mkOption {
            description = "Optional: mode bits used to set permissions on this file, must be an octal value\nbetween 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'";
            type = types.str;
          };
          "resourceFieldRef" = mkOption {
            description = "Selects a resource of the container: only resources limits and requests\n(limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef"
              )
            );
          };
        };

        config = {
          "fieldRef" = mkOverride 1002 null;
          "mode" = mkOverride 1002 null;
          "resourceFieldRef" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPIItemsFieldRef" =
      {

        options = {
          "apiVersion" = mkOption {
            description = "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".";
            type = (types.nullOr types.str);
          };
          "fieldPath" = mkOption {
            description = "Path of the field to select in the specified API version.";
            type = types.str;
          };
        };

        config = {
          "apiVersion" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef" =
      {

        options = {
          "containerName" = mkOption {
            description = "Container name: required for volumes, optional for env vars";
            type = (types.nullOr types.str);
          };
          "divisor" = mkOption {
            description = "Specifies the output format of the exposed resources, defaults to \"1\"";
            type = (types.nullOr (types.either types.int types.str));
          };
          "resource" = mkOption {
            description = "Required: resource to select";
            type = types.str;
          };
        };

        config = {
          "containerName" = mkOverride 1002 null;
          "divisor" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate" =
      {

        options = {
          "certificateChainPath" = mkOption {
            description = "Write the certificate chain at this path in the projected volume.\n\nMost applications should use credentialBundlePath.  When using keyPath\nand certificateChainPath, your application needs to check that the key\nand leaf certificate are consistent, because it is possible to read the\nfiles mid-rotation.";
            type = (types.nullOr types.str);
          };
          "credentialBundlePath" = mkOption {
            description = "Write the credential bundle at this path in the projected volume.\n\nThe credential bundle is a single file that contains multiple PEM blocks.\nThe first PEM block is a PRIVATE KEY block, containing a PKCS#8 private\nkey.\n\nThe remaining blocks are CERTIFICATE blocks, containing the issued\ncertificate chain from the signer (leaf and any intermediates).\n\nUsing credentialBundlePath lets your Pod's application code make a single\natomic read that retrieves a consistent key and certificate chain.  If you\nproject them to separate files, your application code will need to\nadditionally check that the leaf certificate was issued to the key.";
            type = (types.nullOr types.str);
          };
          "keyPath" = mkOption {
            description = "Write the key at this path in the projected volume.\n\nMost applications should use credentialBundlePath.  When using keyPath\nand certificateChainPath, your application needs to check that the key\nand leaf certificate are consistent, because it is possible to read the\nfiles mid-rotation.";
            type = (types.nullOr types.str);
          };
          "keyType" = mkOption {
            description = "The type of keypair Kubelet will generate for the pod.\n\nValid values are \"RSA3072\", \"RSA4096\", \"ECDSAP256\", \"ECDSAP384\",\n\"ECDSAP521\", and \"ED25519\".";
            type = types.str;
          };
          "maxExpirationSeconds" = mkOption {
            description = "maxExpirationSeconds is the maximum lifetime permitted for the\ncertificate.\n\nKubelet copies this value verbatim into the PodCertificateRequests it\ngenerates for this projection.\n\nIf omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver\nwill reject values shorter than 3600 (1 hour).  The maximum allowable\nvalue is 7862400 (91 days).\n\nThe signer implementation is then free to issue a certificate with any\nlifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600\nseconds (1 hour).  This constraint is enforced by kube-apiserver.\n`kubernetes.io` signers will never issue certificates with a lifetime\nlonger than 24 hours.";
            type = (types.nullOr types.int);
          };
          "signerName" = mkOption {
            description = "Kubelet's generated CSRs will be addressed to this signer.";
            type = types.str;
          };
          "userAnnotations" = mkOption {
            description = "userAnnotations allow pod authors to pass additional information to\nthe signer implementation.  Kubernetes does not restrict or validate this\nmetadata in any way.\n\nThese values are copied verbatim into the `spec.unverifiedUserAnnotations` field of\nthe PodCertificateRequest objects that Kubelet creates.\n\nEntries are subject to the same validation as object metadata annotations,\nwith the addition that all keys must be domain-prefixed. No restrictions\nare placed on values, except an overall size limitation on the entire field.\n\nSigners should document the keys and values they support. Signers should\ndeny requests that contain keys they do not recognize.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "certificateChainPath" = mkOverride 1002 null;
          "credentialBundlePath" = mkOverride 1002 null;
          "keyPath" = mkOverride 1002 null;
          "maxExpirationSeconds" = mkOverride 1002 null;
          "userAnnotations" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret" =
      {

        options = {
          "items" = mkOption {
            description = "items if unspecified, each key-value pair in the Data field of the referenced\nSecret will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the Secret,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems"
                )
              )
            );
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "optional field specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "items" = mkOverride 1002 null;
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems" =
      {

        options = {
          "key" = mkOption {
            description = "key is the key to project.";
            type = types.str;
          };
          "mode" = mkOption {
            description = "mode is Optional: mode bits used to set permissions on this file.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "path is the relative path of the file to map the key to.\nMay not be an absolute path.\nMay not contain the path element '..'.\nMay not start with the string '..'.";
            type = types.str;
          };
        };

        config = {
          "mode" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken" =
      {

        options = {
          "audience" = mkOption {
            description = "audience is the intended audience of the token. A recipient of a token\nmust identify itself with an identifier specified in the audience of the\ntoken, and otherwise should reject the token. The audience defaults to the\nidentifier of the apiserver.";
            type = (types.nullOr types.str);
          };
          "expirationSeconds" = mkOption {
            description = "expirationSeconds is the requested duration of validity of the service\naccount token. As the token approaches expiration, the kubelet volume\nplugin will proactively rotate the service account token. The kubelet will\nstart trying to rotate the token if the token is older than 80 percent of\nits time to live or if the token is older than 24 hours.Defaults to 1 hour\nand must be at least 10 minutes.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "path is the path relative to the mount point of the file to project the\ntoken into.";
            type = types.str;
          };
        };

        config = {
          "audience" = mkOverride 1002 null;
          "expirationSeconds" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte" = {

      options = {
        "group" = mkOption {
          description = "group to map volume access to\nDefault is no group";
          type = (types.nullOr types.str);
        };
        "readOnly" = mkOption {
          description = "readOnly here will force the Quobyte volume to be mounted with read-only permissions.\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "registry" = mkOption {
          description = "registry represents a single or multiple Quobyte Registry services\nspecified as a string as host:port pair (multiple entries are separated with commas)\nwhich acts as the central registry for volumes";
          type = types.str;
        };
        "tenant" = mkOption {
          description = "tenant owning the given Quobyte volume in the Backend\nUsed with dynamically provisioned Quobyte volumes, value is set by the plugin";
          type = (types.nullOr types.str);
        };
        "user" = mkOption {
          description = "user to map volume access to\nDefaults to serivceaccount user";
          type = (types.nullOr types.str);
        };
        "volume" = mkOption {
          description = "volume is a string that references an already created Quobyte volume by name.";
          type = types.str;
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "tenant" = mkOverride 1002 null;
        "user" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd" = {

      options = {
        "fsType" = mkOption {
          description = "fsType is the filesystem type of the volume that you want to mount.\nTip: Ensure that the filesystem type is supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#rbd";
          type = (types.nullOr types.str);
        };
        "image" = mkOption {
          description = "image is the rados image name.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = types.str;
        };
        "keyring" = mkOption {
          description = "keyring is the path to key ring for RBDUser.\nDefault is /etc/ceph/keyring.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = (types.nullOr types.str);
        };
        "monitors" = mkOption {
          description = "monitors is a collection of Ceph monitors.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = (types.listOf types.str);
        };
        "pool" = mkOption {
          description = "pool is the rados pool name.\nDefault is rbd.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = (types.nullOr types.str);
        };
        "readOnly" = mkOption {
          description = "readOnly here will force the ReadOnly setting in VolumeMounts.\nDefaults to false.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = (types.nullOr types.bool);
        };
        "secretRef" = mkOption {
          description = "secretRef is name of the authentication secret for RBDUser. If provided\noverrides keyring.\nDefault is nil.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbdSecretRef"
            )
          );
        };
        "user" = mkOption {
          description = "user is the rados user name.\nDefault is admin.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "fsType" = mkOverride 1002 null;
        "keyring" = mkOverride 1002 null;
        "pool" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
        "user" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbdSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIO" = {

      options = {
        "fsType" = mkOption {
          description = "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\".\nDefault is \"xfs\".";
          type = (types.nullOr types.str);
        };
        "gateway" = mkOption {
          description = "gateway is the host address of the ScaleIO API Gateway.";
          type = types.str;
        };
        "protectionDomain" = mkOption {
          description = "protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.";
          type = (types.nullOr types.str);
        };
        "readOnly" = mkOption {
          description = "readOnly Defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
          type = (types.nullOr types.bool);
        };
        "secretRef" = mkOption {
          description = "secretRef references to the secret for ScaleIO user and other\nsensitive information. If this is not provided, Login operation will fail.";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIOSecretRef"
          );
        };
        "sslEnabled" = mkOption {
          description = "sslEnabled Flag enable/disable SSL communication with Gateway, default false";
          type = (types.nullOr types.bool);
        };
        "storageMode" = mkOption {
          description = "storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.\nDefault is ThinProvisioned.";
          type = (types.nullOr types.str);
        };
        "storagePool" = mkOption {
          description = "storagePool is the ScaleIO Storage Pool associated with the protection domain.";
          type = (types.nullOr types.str);
        };
        "system" = mkOption {
          description = "system is the name of the storage system as configured in ScaleIO.";
          type = types.str;
        };
        "volumeName" = mkOption {
          description = "volumeName is the name of a volume already created in the ScaleIO system\nthat is associated with this volume source.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "fsType" = mkOverride 1002 null;
        "protectionDomain" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "sslEnabled" = mkOverride 1002 null;
        "storageMode" = mkOverride 1002 null;
        "storagePool" = mkOverride 1002 null;
        "volumeName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIOSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret" = {

      options = {
        "defaultMode" = mkOption {
          description = "defaultMode is Optional: mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values\nfor mode bits. Defaults to 0644.\nDirectories within the path are not affected by this setting.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
          type = (types.nullOr types.int);
        };
        "items" = mkOption {
          description = "items If unspecified, each key-value pair in the Data field of the referenced\nSecret will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the Secret,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems"
              )
            )
          );
        };
        "optional" = mkOption {
          description = "optional field specify whether the Secret or its keys must be defined";
          type = (types.nullOr types.bool);
        };
        "secretName" = mkOption {
          description = "secretName is the name of the secret in the pod's namespace to use.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#secret";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "defaultMode" = mkOverride 1002 null;
        "items" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
        "secretName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems" =
      {

        options = {
          "key" = mkOption {
            description = "key is the key to project.";
            type = types.str;
          };
          "mode" = mkOption {
            description = "mode is Optional: mode bits used to set permissions on this file.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "path is the relative path of the file to map the key to.\nMay not be an absolute path.\nMay not contain the path element '..'.\nMay not start with the string '..'.";
            type = types.str;
          };
        };

        config = {
          "mode" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos" =
      {

        options = {
          "fsType" = mkOption {
            description = "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.";
            type = (types.nullOr types.str);
          };
          "readOnly" = mkOption {
            description = "readOnly defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
            type = (types.nullOr types.bool);
          };
          "secretRef" = mkOption {
            description = "secretRef specifies the secret to use for obtaining the StorageOS API\ncredentials.  If not specified, default values will be attempted.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageosSecretRef"
              )
            );
          };
          "volumeName" = mkOption {
            description = "volumeName is the human-readable name of the StorageOS volume.  Volume\nnames are only unique within a namespace.";
            type = (types.nullOr types.str);
          };
          "volumeNamespace" = mkOption {
            description = "volumeNamespace specifies the scope of the volume within StorageOS.  If no\nnamespace is specified then the Pod's namespace will be used.  This allows the\nKubernetes name scoping to be mirrored within StorageOS for tighter integration.\nSet VolumeName to any name to override the default behaviour.\nSet to \"default\" if you are not using namespaces within StorageOS.\nNamespaces that do not pre-exist within StorageOS will be created.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
          "secretRef" = mkOverride 1002 null;
          "volumeName" = mkOverride 1002 null;
          "volumeNamespace" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageosSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume" =
      {

        options = {
          "fsType" = mkOption {
            description = "fsType is filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.";
            type = (types.nullOr types.str);
          };
          "storagePolicyID" = mkOption {
            description = "storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.";
            type = (types.nullOr types.str);
          };
          "storagePolicyName" = mkOption {
            description = "storagePolicyName is the storage Policy Based Management (SPBM) profile name.";
            type = (types.nullOr types.str);
          };
          "volumePath" = mkOption {
            description = "volumePath is the path that identifies vSphere volume vmdk";
            type = types.str;
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
          "storagePolicyID" = mkOverride 1002 null;
          "storagePolicyName" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategy" = {

      options = {
        "rollingUpdate" = mkOption {
          description = "Rolling update config params. Present only if type = \"RollingUpdate\".";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdate"
            )
          );
        };
        "type" = mkOption {
          description = "Type of daemon set update. Can be \"RollingUpdate\" or \"OnDelete\". Default is RollingUpdate.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "rollingUpdate" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdate" =
      {

        options = {
          "maxSurge" = mkOption {
            description = "The maximum number of nodes with an existing available DaemonSet pod that\ncan have an updated DaemonSet pod during during an update.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nThis can not be 0 if MaxUnavailable is 0.\nAbsolute number is calculated from percentage by rounding up to a minimum of 1.\nDefault value is 0.\nExample: when this is set to 30%, at most 30% of the total number of nodes\nthat should be running the daemon pod (i.e. status.desiredNumberScheduled)\ncan have their a new pod created before the old pod is marked as deleted.\nThe update starts by launching new pods on 30% of nodes. Once an updated\npod is available (Ready for at least minReadySeconds) the old DaemonSet pod\non that node is marked deleted. If the old pod becomes unavailable for any\nreason (Ready transitions to false, is evicted, or is drained) an updated\npod is immediately created on that node without considering surge limits.\nAllowing surge implies the possibility that the resources consumed by the\ndaemonset on any given node can double if the readiness check fails, and\nso resource intensive daemonsets should take into account that they may\ncause evictions during disruption.";
            type = (types.nullOr (types.either types.int types.str));
          };
          "maxUnavailable" = mkOption {
            description = "The maximum number of DaemonSet pods that can be unavailable during the\nupdate. Value can be an absolute number (ex: 5) or a percentage of total\nnumber of DaemonSet pods at the start of the update (ex: 10%). Absolute\nnumber is calculated from percentage by rounding up.\nThis cannot be 0 if MaxSurge is 0\nDefault value is 1.\nExample: when this is set to 30%, at most 30% of the total number of nodes\nthat should be running the daemon pod (i.e. status.desiredNumberScheduled)\ncan have their pods stopped for an update at any given time. The update\nstarts by stopping at most 30% of those DaemonSet pods and then brings\nup new DaemonSet pods in their place. Once the new pods are available,\nit then proceeds onto other DaemonSet pods, thus ensuring that at least\n70% of original number of DaemonSet pods are available at all times during\nthe update.";
            type = (types.nullOr (types.either types.int types.str));
          };
        };

        config = {
          "maxSurge" = mkOverride 1002 null;
          "maxUnavailable" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeployment" = {

      options = {
        "container" = mkOption {
          description = "Container defines the desired specification of main container.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer"
            )
          );
        };
        "initContainers" = mkOption {
          description = "List of initialization containers belonging to the pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "name" = mkOption {
          description = "Name of the deployment.\nWhen unset, this defaults to an autogenerated name.";
          type = (types.nullOr types.str);
        };
        "patch" = mkOption {
          description = "Patch defines how to perform the patch operation to deployment";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch"
            )
          );
        };
        "pod" = mkOption {
          description = "Pod defines the desired specification of pod.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod"
            )
          );
        };
        "replicas" = mkOption {
          description = "Replicas is the number of desired pods. Defaults to 1.";
          type = (types.nullOr types.int);
        };
        "strategy" = mkOption {
          description = "The deployment strategy to use to replace existing pods with new ones.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategy"
            )
          );
        };
      };

      config = {
        "container" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
        "patch" = mkOverride 1002 null;
        "pod" = mkOverride 1002 null;
        "replicas" = mkOverride 1002 null;
        "strategy" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer" = {

      options = {
        "env" = mkOption {
          description = "List of environment variables to set in the container.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "image" = mkOption {
          description = "Image specifies the EnvoyProxy container image to be used including a tag, instead of the default image.\nThis field is mutually exclusive with ImageRepository.";
          type = (types.nullOr types.str);
        };
        "imageRepository" = mkOption {
          description = "ImageRepository specifies the container image repository to be used without specifying a tag.\nThe default tag will be used.\nThis field is mutually exclusive with Image.";
          type = (types.nullOr types.str);
        };
        "resources" = mkOption {
          description = "Resources required by this container.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources"
            )
          );
        };
        "securityContext" = mkOption {
          description = "SecurityContext defines the security options the container should be run with.\nIf set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.\nMore info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext"
            )
          );
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts are volumes to mount into the container's filesystem.\nCannot be updated.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "env" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imageRepository" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
        "valueFrom" = mkOption {
          description = "Source for the environment variable's value. Cannot be used if value is not empty.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom"
            )
          );
        };
      };

      config = {
        "value" = mkOverride 1002 null;
        "valueFrom" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom" =
      {

        options = {
          "configMapKeyRef" = mkOption {
            description = "Selects a key of a ConfigMap.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef"
              )
            );
          };
          "fieldRef" = mkOption {
            description = "Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,\nspec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFieldRef"
              )
            );
          };
          "fileKeyRef" = mkOption {
            description = "FileKeyRef selects a key of the env file.\nRequires the EnvFiles feature gate to be enabled.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFileKeyRef"
              )
            );
          };
          "resourceFieldRef" = mkOption {
            description = "Selects a resource of the container: only resources limits and requests\n(limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef"
              )
            );
          };
          "secretKeyRef" = mkOption {
            description = "Selects a key of a secret in the pod's namespace";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef"
              )
            );
          };
        };

        config = {
          "configMapKeyRef" = mkOverride 1002 null;
          "fieldRef" = mkOverride 1002 null;
          "fileKeyRef" = mkOverride 1002 null;
          "resourceFieldRef" = mkOverride 1002 null;
          "secretKeyRef" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFieldRef" =
      {

        options = {
          "apiVersion" = mkOption {
            description = "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".";
            type = (types.nullOr types.str);
          };
          "fieldPath" = mkOption {
            description = "Path of the field to select in the specified API version.";
            type = types.str;
          };
        };

        config = {
          "apiVersion" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFileKeyRef" =
      {

        options = {
          "key" = mkOption {
            description = "The key within the env file. An invalid key will prevent the pod from starting.\nThe keys defined within a source may consist of any printable ASCII characters except '='.\nDuring Alpha stage of the EnvFiles feature gate, the key size is limited to 128 characters.";
            type = types.str;
          };
          "optional" = mkOption {
            description = "Specify whether the file or its key must be defined. If the file or key\ndoes not exist, then the env var is not published.\nIf optional is set to true and the specified key does not exist,\nthe environment variable will not be set in the Pod's containers.\n\nIf optional is set to false and the specified key does not exist,\nan error will be returned during Pod creation.";
            type = (types.nullOr types.bool);
          };
          "path" = mkOption {
            description = "The path within the volume from which to select the file.\nMust be relative and may not contain the '..' path or start with '..'.";
            type = types.str;
          };
          "volumeName" = mkOption {
            description = "The name of the volume mount containing the env file.";
            type = types.str;
          };
        };

        config = {
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef" =
      {

        options = {
          "containerName" = mkOption {
            description = "Container name: required for volumes, optional for env vars";
            type = (types.nullOr types.str);
          };
          "divisor" = mkOption {
            description = "Specifies the output format of the exposed resources, defaults to \"1\"";
            type = (types.nullOr (types.either types.int types.str));
          };
          "resource" = mkOption {
            description = "Required: resource to select";
            type = types.str;
          };
        };

        config = {
          "containerName" = mkOverride 1002 null;
          "divisor" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources" =
      {

        options = {
          "claims" = mkOption {
            description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesClaims"
                  "name"
                  [ "name" ]
              )
            );
            apply = attrsToList;
          };
          "limits" = mkOption {
            description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
          "requests" = mkOption {
            description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
        };

        config = {
          "claims" = mkOverride 1002 null;
          "limits" = mkOverride 1002 null;
          "requests" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesClaims" =
      {

        options = {
          "name" = mkOption {
            description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
            type = types.str;
          };
          "request" = mkOption {
            description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "request" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext" =
      {

        options = {
          "allowPrivilegeEscalation" = mkOption {
            description = "AllowPrivilegeEscalation controls whether a process can gain more\nprivileges than its parent process. This bool directly controls if\nthe no_new_privs flag will be set on the container process.\nAllowPrivilegeEscalation is true always when the container is:\n1) run as Privileged\n2) has CAP_SYS_ADMIN\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.bool);
          };
          "appArmorProfile" = mkOption {
            description = "appArmorProfile is the AppArmor options to use by this container. If set, this profile\noverrides the pod's appArmorProfile.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextAppArmorProfile"
              )
            );
          };
          "capabilities" = mkOption {
            description = "The capabilities to add/drop when running containers.\nDefaults to the default set of capabilities granted by the container runtime.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextCapabilities"
              )
            );
          };
          "privileged" = mkOption {
            description = "Run container in privileged mode.\nProcesses in privileged containers are essentially equivalent to root on the host.\nDefaults to false.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.bool);
          };
          "procMount" = mkOption {
            description = "procMount denotes the type of proc mount to use for the containers.\nThe default value is Default which uses the container runtime defaults for\nreadonly paths and masked paths.\nThis requires the ProcMountType feature flag to be enabled.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.str);
          };
          "readOnlyRootFilesystem" = mkOption {
            description = "Whether this container has a read-only root filesystem.\nDefault is false.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.bool);
          };
          "runAsGroup" = mkOption {
            description = "The GID to run the entrypoint of the container process.\nUses runtime default if unset.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.int);
          };
          "runAsNonRoot" = mkOption {
            description = "Indicates that the container must run as a non-root user.\nIf true, the Kubelet will validate the image at runtime to ensure that it\ndoes not run as UID 0 (root) and fail to start the container if it does.\nIf unset or false, no such validation will be performed.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.";
            type = (types.nullOr types.bool);
          };
          "runAsUser" = mkOption {
            description = "The UID to run the entrypoint of the container process.\nDefaults to user specified in image metadata if unspecified.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.int);
          };
          "seLinuxOptions" = mkOption {
            description = "The SELinux context to be applied to the container.\nIf unspecified, the container runtime will allocate a random SELinux context for each\ncontainer.  May also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions"
              )
            );
          };
          "seccompProfile" = mkOption {
            description = "The seccomp options to use by this container. If seccomp options are\nprovided at both the pod & container level, the container options\noverride the pod options.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeccompProfile"
              )
            );
          };
          "windowsOptions" = mkOption {
            description = "The Windows specific settings applied to all containers.\nIf unspecified, the options from the PodSecurityContext will be used.\nIf set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is linux.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions"
              )
            );
          };
        };

        config = {
          "allowPrivilegeEscalation" = mkOverride 1002 null;
          "appArmorProfile" = mkOverride 1002 null;
          "capabilities" = mkOverride 1002 null;
          "privileged" = mkOverride 1002 null;
          "procMount" = mkOverride 1002 null;
          "readOnlyRootFilesystem" = mkOverride 1002 null;
          "runAsGroup" = mkOverride 1002 null;
          "runAsNonRoot" = mkOverride 1002 null;
          "runAsUser" = mkOverride 1002 null;
          "seLinuxOptions" = mkOverride 1002 null;
          "seccompProfile" = mkOverride 1002 null;
          "windowsOptions" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextAppArmorProfile" =
      {

        options = {
          "localhostProfile" = mkOption {
            description = "localhostProfile indicates a profile loaded on the node that should be used.\nThe profile must be preconfigured on the node to work.\nMust match the loaded name of the profile.\nMust be set if and only if type is \"Localhost\".";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "type indicates which kind of AppArmor profile will be applied.\nValid options are:\n  Localhost - a profile pre-loaded on the node.\n  RuntimeDefault - the container runtime's default profile.\n  Unconfined - no AppArmor enforcement.";
            type = types.str;
          };
        };

        config = {
          "localhostProfile" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextCapabilities" =
      {

        options = {
          "add" = mkOption {
            description = "Added capabilities";
            type = (types.nullOr (types.listOf types.str));
          };
          "drop" = mkOption {
            description = "Removed capabilities";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "add" = mkOverride 1002 null;
          "drop" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions" =
      {

        options = {
          "level" = mkOption {
            description = "Level is SELinux level label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "role" = mkOption {
            description = "Role is a SELinux role label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type is a SELinux type label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "user" = mkOption {
            description = "User is a SELinux user label that applies to the container.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "level" = mkOverride 1002 null;
          "role" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
          "user" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeccompProfile" =
      {

        options = {
          "localhostProfile" = mkOption {
            description = "localhostProfile indicates a profile defined in a file on the node should be used.\nThe profile must be preconfigured on the node to work.\nMust be a descending path, relative to the kubelet's configured seccomp profile location.\nMust be set if type is \"Localhost\". Must NOT be set for any other type.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "type indicates which kind of seccomp profile will be applied.\nValid options are:\n\nLocalhost - a profile defined in a file on the node should be used.\nRuntimeDefault - the container runtime default profile should be used.\nUnconfined - no profile should be applied.";
            type = types.str;
          };
        };

        config = {
          "localhostProfile" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions" =
      {

        options = {
          "gmsaCredentialSpec" = mkOption {
            description = "GMSACredentialSpec is where the GMSA admission webhook\n(https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the\nGMSA credential spec named by the GMSACredentialSpecName field.";
            type = (types.nullOr types.str);
          };
          "gmsaCredentialSpecName" = mkOption {
            description = "GMSACredentialSpecName is the name of the GMSA credential spec to use.";
            type = (types.nullOr types.str);
          };
          "hostProcess" = mkOption {
            description = "HostProcess determines if a container should be run as a 'Host Process' container.\nAll of a Pod's containers must have the same effective HostProcess value\n(it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).\nIn addition, if HostProcess is true then HostNetwork must also be set to true.";
            type = (types.nullOr types.bool);
          };
          "runAsUserName" = mkOption {
            description = "The UserName in Windows to run the entrypoint of the container process.\nDefaults to the user specified in image metadata if unspecified.\nMay also be set in PodSecurityContext. If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "gmsaCredentialSpec" = mkOverride 1002 null;
          "gmsaCredentialSpecName" = mkOverride 1002 null;
          "hostProcess" = mkOverride 1002 null;
          "runAsUserName" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts" =
      {

        options = {
          "mountPath" = mkOption {
            description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
            type = types.str;
          };
          "mountPropagation" = mkOption {
            description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
            type = (types.nullOr types.str);
          };
          "name" = mkOption {
            description = "This must match the Name of a Volume.";
            type = types.str;
          };
          "readOnly" = mkOption {
            description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
            type = (types.nullOr types.bool);
          };
          "recursiveReadOnly" = mkOption {
            description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
            type = (types.nullOr types.str);
          };
          "subPath" = mkOption {
            description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
            type = (types.nullOr types.str);
          };
          "subPathExpr" = mkOption {
            description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "mountPropagation" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
          "recursiveReadOnly" = mkOverride 1002 null;
          "subPath" = mkOverride 1002 null;
          "subPathExpr" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers" = {

      options = {
        "args" = mkOption {
          description = "Arguments to the entrypoint.\nThe container image's CMD is used if this is not provided.\nVariable references $(VAR_NAME) are expanded using the container's environment. If a variable\ncannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will\nproduce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless\nof whether the variable exists or not. Cannot be updated.\nMore info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell";
          type = (types.nullOr (types.listOf types.str));
        };
        "command" = mkOption {
          description = "Entrypoint array. Not executed within a shell.\nThe container image's ENTRYPOINT is used if this is not provided.\nVariable references $(VAR_NAME) are expanded using the container's environment. If a variable\ncannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will\nproduce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless\nof whether the variable exists or not. Cannot be updated.\nMore info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell";
          type = (types.nullOr (types.listOf types.str));
        };
        "env" = mkOption {
          description = "List of environment variables to set in the container.\nCannot be updated.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "envFrom" = mkOption {
          description = "List of sources to populate environment variables in the container.\nThe keys defined within a source may consist of any printable ASCII characters except '='.\nWhen a key exists in multiple\nsources, the value associated with the last source will take precedence.\nValues defined by an Env with a duplicate key will take precedence.\nCannot be updated.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom"
              )
            )
          );
        };
        "image" = mkOption {
          description = "Container image name.\nMore info: https://kubernetes.io/docs/concepts/containers/images\nThis field is optional to allow higher level config management to default or override\ncontainer images in workload controllers like Deployments and StatefulSets.";
          type = (types.nullOr types.str);
        };
        "imagePullPolicy" = mkOption {
          description = "Image pull policy.\nOne of Always, Never, IfNotPresent.\nDefaults to Always if :latest tag is specified, or IfNotPresent otherwise.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/containers/images#updating-images";
          type = (types.nullOr types.str);
        };
        "lifecycle" = mkOption {
          description = "Actions that the management system should take in response to container lifecycle events.\nCannot be updated.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle"
            )
          );
        };
        "livenessProbe" = mkOption {
          description = "Periodic probe of container liveness.\nContainer will be restarted if the probe fails.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe"
            )
          );
        };
        "name" = mkOption {
          description = "Name of the container specified as a DNS_LABEL.\nEach container in a pod must have a unique name (DNS_LABEL).\nCannot be updated.";
          type = types.str;
        };
        "ports" = mkOption {
          description = "List of ports to expose from the container. Not specifying a port here\nDOES NOT prevent that port from being exposed. Any port which is\nlistening on the default \"0.0.0.0\" address inside a container will be\naccessible from the network.\nModifying this array with strategic merge patch may corrupt the data.\nFor more information See https://github.com/kubernetes/kubernetes/issues/108255.\nCannot be updated.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts"
                "name"
                [
                  "containerPort"
                  "protocol"
                ]
            )
          );
          apply = attrsToList;
        };
        "readinessProbe" = mkOption {
          description = "Periodic probe of container service readiness.\nContainer will be removed from service endpoints if the probe fails.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe"
            )
          );
        };
        "resizePolicy" = mkOption {
          description = "Resources resize policy for the container.\nThis field cannot be set on ephemeral containers.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResizePolicy"
              )
            )
          );
        };
        "resources" = mkOption {
          description = "Compute Resources required by this container.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources"
            )
          );
        };
        "restartPolicy" = mkOption {
          description = "RestartPolicy defines the restart behavior of individual containers in a pod.\nThis overrides the pod-level restart policy. When this field is not specified,\nthe restart behavior is defined by the Pod's restart policy and the container type.\nAdditionally, setting the RestartPolicy as \"Always\" for the init container will\nhave the following effect:\nthis init container will be continually restarted on\nexit until all regular containers have terminated. Once all regular\ncontainers have completed, all init containers with restartPolicy \"Always\"\nwill be shut down. This lifecycle differs from normal init containers and\nis often referred to as a \"sidecar\" container. Although this init\ncontainer still starts in the init container sequence, it does not wait\nfor the container to complete before proceeding to the next init\ncontainer. Instead, the next init container starts immediately after this\ninit container is started, or after any startupProbe has successfully\ncompleted.";
          type = (types.nullOr types.str);
        };
        "restartPolicyRules" = mkOption {
          description = "Represents a list of rules to be checked to determine if the\ncontainer should be restarted on exit. The rules are evaluated in\norder. Once a rule matches a container exit condition, the remaining\nrules are ignored. If no rule matches the container exit condition,\nthe Container-level restart policy determines the whether the container\nis restarted or not. Constraints on the rules:\n- At most 20 rules are allowed.\n- Rules can have the same action.\n- Identical rules are not forbidden in validations.\nWhen rules are specified, container MUST set RestartPolicy explicitly\neven it if matches the Pod's RestartPolicy.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRules"
              )
            )
          );
        };
        "securityContext" = mkOption {
          description = "SecurityContext defines the security options the container should be run with.\nIf set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.\nMore info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext"
            )
          );
        };
        "startupProbe" = mkOption {
          description = "StartupProbe indicates that the Pod has successfully initialized.\nIf specified, no other probes are executed until this completes successfully.\nIf this probe fails, the Pod will be restarted, just as if the livenessProbe failed.\nThis can be used to provide different probe parameters at the beginning of a Pod's lifecycle,\nwhen it might take a long time to load data or warm a cache, than during steady-state operation.\nThis cannot be updated.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe"
            )
          );
        };
        "stdin" = mkOption {
          description = "Whether this container should allocate a buffer for stdin in the container runtime. If this\nis not set, reads from stdin in the container will always result in EOF.\nDefault is false.";
          type = (types.nullOr types.bool);
        };
        "stdinOnce" = mkOption {
          description = "Whether the container runtime should close the stdin channel after it has been opened by\na single attach. When stdin is true the stdin stream will remain open across multiple attach\nsessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the\nfirst client attaches to stdin, and then remains open and accepts data until the client disconnects,\nat which time stdin is closed and remains closed until the container is restarted. If this\nflag is false, a container processes that reads from stdin will never receive an EOF.\nDefault is false";
          type = (types.nullOr types.bool);
        };
        "terminationMessagePath" = mkOption {
          description = "Optional: Path at which the file to which the container's termination message\nwill be written is mounted into the container's filesystem.\nMessage written is intended to be brief final status, such as an assertion failure message.\nWill be truncated by the node if greater than 4096 bytes. The total message length across\nall containers will be limited to 12kb.\nDefaults to /dev/termination-log.\nCannot be updated.";
          type = (types.nullOr types.str);
        };
        "terminationMessagePolicy" = mkOption {
          description = "Indicate how the termination message should be populated. File will use the contents of\nterminationMessagePath to populate the container status message on both success and failure.\nFallbackToLogsOnError will use the last chunk of container log output if the termination\nmessage file is empty and the container exited with an error.\nThe log output is limited to 2048 bytes or 80 lines, whichever is smaller.\nDefaults to File.\nCannot be updated.";
          type = (types.nullOr types.str);
        };
        "tty" = mkOption {
          description = "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.\nDefault is false.";
          type = (types.nullOr types.bool);
        };
        "volumeDevices" = mkOption {
          description = "volumeDevices is the list of block devices to be used by the container.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeDevices"
                "name"
                [ "devicePath" ]
            )
          );
          apply = attrsToList;
        };
        "volumeMounts" = mkOption {
          description = "Pod volumes to mount into the container's filesystem.\nCannot be updated.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts"
                "name"
                [ "mountPath" ]
            )
          );
          apply = attrsToList;
        };
        "workingDir" = mkOption {
          description = "Container's working directory.\nIf not specified, the container runtime's default will be used, which\nmight be configured in the container image.\nCannot be updated.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "args" = mkOverride 1002 null;
        "command" = mkOverride 1002 null;
        "env" = mkOverride 1002 null;
        "envFrom" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullPolicy" = mkOverride 1002 null;
        "lifecycle" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "ports" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "resizePolicy" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "restartPolicy" = mkOverride 1002 null;
        "restartPolicyRules" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "stdin" = mkOverride 1002 null;
        "stdinOnce" = mkOverride 1002 null;
        "terminationMessagePath" = mkOverride 1002 null;
        "terminationMessagePolicy" = mkOverride 1002 null;
        "tty" = mkOverride 1002 null;
        "volumeDevices" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "workingDir" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
            type = types.str;
          };
          "value" = mkOption {
            description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
            type = (types.nullOr types.str);
          };
          "valueFrom" = mkOption {
            description = "Source for the environment variable's value. Cannot be used if value is not empty.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom"
              )
            );
          };
        };

        config = {
          "value" = mkOverride 1002 null;
          "valueFrom" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom" =
      {

        options = {
          "configMapRef" = mkOption {
            description = "The ConfigMap to select from";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromConfigMapRef"
              )
            );
          };
          "prefix" = mkOption {
            description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
            type = (types.nullOr types.str);
          };
          "secretRef" = mkOption {
            description = "The Secret to select from";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromSecretRef"
              )
            );
          };
        };

        config = {
          "configMapRef" = mkOverride 1002 null;
          "prefix" = mkOverride 1002 null;
          "secretRef" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromConfigMapRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom" =
      {

        options = {
          "configMapKeyRef" = mkOption {
            description = "Selects a key of a ConfigMap.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef"
              )
            );
          };
          "fieldRef" = mkOption {
            description = "Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,\nspec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFieldRef"
              )
            );
          };
          "fileKeyRef" = mkOption {
            description = "FileKeyRef selects a key of the env file.\nRequires the EnvFiles feature gate to be enabled.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFileKeyRef"
              )
            );
          };
          "resourceFieldRef" = mkOption {
            description = "Selects a resource of the container: only resources limits and requests\n(limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef"
              )
            );
          };
          "secretKeyRef" = mkOption {
            description = "Selects a key of a secret in the pod's namespace";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef"
              )
            );
          };
        };

        config = {
          "configMapKeyRef" = mkOverride 1002 null;
          "fieldRef" = mkOverride 1002 null;
          "fileKeyRef" = mkOverride 1002 null;
          "resourceFieldRef" = mkOverride 1002 null;
          "secretKeyRef" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFieldRef" =
      {

        options = {
          "apiVersion" = mkOption {
            description = "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".";
            type = (types.nullOr types.str);
          };
          "fieldPath" = mkOption {
            description = "Path of the field to select in the specified API version.";
            type = types.str;
          };
        };

        config = {
          "apiVersion" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFileKeyRef" =
      {

        options = {
          "key" = mkOption {
            description = "The key within the env file. An invalid key will prevent the pod from starting.\nThe keys defined within a source may consist of any printable ASCII characters except '='.\nDuring Alpha stage of the EnvFiles feature gate, the key size is limited to 128 characters.";
            type = types.str;
          };
          "optional" = mkOption {
            description = "Specify whether the file or its key must be defined. If the file or key\ndoes not exist, then the env var is not published.\nIf optional is set to true and the specified key does not exist,\nthe environment variable will not be set in the Pod's containers.\n\nIf optional is set to false and the specified key does not exist,\nan error will be returned during Pod creation.";
            type = (types.nullOr types.bool);
          };
          "path" = mkOption {
            description = "The path within the volume from which to select the file.\nMust be relative and may not contain the '..' path or start with '..'.";
            type = types.str;
          };
          "volumeName" = mkOption {
            description = "The name of the volume mount containing the env file.";
            type = types.str;
          };
        };

        config = {
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef" =
      {

        options = {
          "containerName" = mkOption {
            description = "Container name: required for volumes, optional for env vars";
            type = (types.nullOr types.str);
          };
          "divisor" = mkOption {
            description = "Specifies the output format of the exposed resources, defaults to \"1\"";
            type = (types.nullOr (types.either types.int types.str));
          };
          "resource" = mkOption {
            description = "Required: resource to select";
            type = types.str;
          };
        };

        config = {
          "containerName" = mkOverride 1002 null;
          "divisor" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle" =
      {

        options = {
          "postStart" = mkOption {
            description = "PostStart is called immediately after a container is created. If the handler fails,\nthe container is terminated and restarted according to its restart policy.\nOther management of the container blocks until the hook completes.\nMore info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart"
              )
            );
          };
          "preStop" = mkOption {
            description = "PreStop is called immediately before a container is terminated due to an\nAPI request or management event such as liveness/startup probe failure,\npreemption, resource contention, etc. The handler is not called if the\ncontainer crashes or exits. The Pod's termination grace period countdown begins before the\nPreStop hook is executed. Regardless of the outcome of the handler, the\ncontainer will eventually terminate within the Pod's termination grace\nperiod (unless delayed by finalizers). Other management of the container blocks until the hook completes\nor until the termination grace period is reached.\nMore info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop"
              )
            );
          };
          "stopSignal" = mkOption {
            description = "StopSignal defines which signal will be sent to a container when it is being stopped.\nIf not specified, the default is defined by the container runtime in use.\nStopSignal can only be set for Pods with a non-empty .spec.os.name";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "postStart" = mkOverride 1002 null;
          "preStop" = mkOverride 1002 null;
          "stopSignal" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart" =
      {

        options = {
          "exec" = mkOption {
            description = "Exec specifies a command to execute in the container.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartExec"
              )
            );
          };
          "httpGet" = mkOption {
            description = "HTTPGet specifies an HTTP GET request to perform.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet"
              )
            );
          };
          "sleep" = mkOption {
            description = "Sleep represents a duration that the container should sleep.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartSleep"
              )
            );
          };
          "tcpSocket" = mkOption {
            description = "Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept\nfor backward compatibility. There is no validation of this field and\nlifecycle hooks will fail at runtime when it is specified.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocket"
              )
            );
          };
        };

        config = {
          "exec" = mkOverride 1002 null;
          "httpGet" = mkOverride 1002 null;
          "sleep" = mkOverride 1002 null;
          "tcpSocket" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartExec" =
      {

        options = {
          "command" = mkOption {
            description = "Command is the command line to execute inside the container, the working directory for the\ncommand  is root ('/') in the container's filesystem. The command is simply exec'd, it is\nnot run inside a shell, so traditional shell instructions ('|', etc) won't work. To use\na shell, you need to explicitly call out to that shell.\nExit status of 0 is treated as live/healthy and non-zero is unhealthy.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "command" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet" =
      {

        options = {
          "host" = mkOption {
            description = "Host name to connect to, defaults to the pod IP. You probably want to set\n\"Host\" in httpHeaders instead.";
            type = (types.nullOr types.str);
          };
          "httpHeaders" = mkOption {
            description = "Custom headers to set in the request. HTTP allows repeated headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetHttpHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "path" = mkOption {
            description = "Path to access on the HTTP server.";
            type = (types.nullOr types.str);
          };
          "port" = mkOption {
            description = "Name or number of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.";
            type = (types.either types.int types.str);
          };
          "scheme" = mkOption {
            description = "Scheme to use for connecting to the host.\nDefaults to HTTP.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "host" = mkOverride 1002 null;
          "httpHeaders" = mkOverride 1002 null;
          "path" = mkOverride 1002 null;
          "scheme" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetHttpHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "The header field name.\nThis will be canonicalized upon output, so case-variant names will be understood as the same header.";
            type = types.str;
          };
          "value" = mkOption {
            description = "The header field value";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartSleep" =
      {

        options = {
          "seconds" = mkOption {
            description = "Seconds is the number of seconds to sleep.";
            type = types.int;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocket" =
      {

        options = {
          "host" = mkOption {
            description = "Optional: Host name to connect to, defaults to the pod IP.";
            type = (types.nullOr types.str);
          };
          "port" = mkOption {
            description = "Number or name of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.";
            type = (types.either types.int types.str);
          };
        };

        config = {
          "host" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop" =
      {

        options = {
          "exec" = mkOption {
            description = "Exec specifies a command to execute in the container.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopExec"
              )
            );
          };
          "httpGet" = mkOption {
            description = "HTTPGet specifies an HTTP GET request to perform.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet"
              )
            );
          };
          "sleep" = mkOption {
            description = "Sleep represents a duration that the container should sleep.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopSleep"
              )
            );
          };
          "tcpSocket" = mkOption {
            description = "Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept\nfor backward compatibility. There is no validation of this field and\nlifecycle hooks will fail at runtime when it is specified.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocket"
              )
            );
          };
        };

        config = {
          "exec" = mkOverride 1002 null;
          "httpGet" = mkOverride 1002 null;
          "sleep" = mkOverride 1002 null;
          "tcpSocket" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopExec" =
      {

        options = {
          "command" = mkOption {
            description = "Command is the command line to execute inside the container, the working directory for the\ncommand  is root ('/') in the container's filesystem. The command is simply exec'd, it is\nnot run inside a shell, so traditional shell instructions ('|', etc) won't work. To use\na shell, you need to explicitly call out to that shell.\nExit status of 0 is treated as live/healthy and non-zero is unhealthy.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "command" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet" =
      {

        options = {
          "host" = mkOption {
            description = "Host name to connect to, defaults to the pod IP. You probably want to set\n\"Host\" in httpHeaders instead.";
            type = (types.nullOr types.str);
          };
          "httpHeaders" = mkOption {
            description = "Custom headers to set in the request. HTTP allows repeated headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetHttpHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "path" = mkOption {
            description = "Path to access on the HTTP server.";
            type = (types.nullOr types.str);
          };
          "port" = mkOption {
            description = "Name or number of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.";
            type = (types.either types.int types.str);
          };
          "scheme" = mkOption {
            description = "Scheme to use for connecting to the host.\nDefaults to HTTP.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "host" = mkOverride 1002 null;
          "httpHeaders" = mkOverride 1002 null;
          "path" = mkOverride 1002 null;
          "scheme" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetHttpHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "The header field name.\nThis will be canonicalized upon output, so case-variant names will be understood as the same header.";
            type = types.str;
          };
          "value" = mkOption {
            description = "The header field value";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopSleep" =
      {

        options = {
          "seconds" = mkOption {
            description = "Seconds is the number of seconds to sleep.";
            type = types.int;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocket" =
      {

        options = {
          "host" = mkOption {
            description = "Optional: Host name to connect to, defaults to the pod IP.";
            type = (types.nullOr types.str);
          };
          "port" = mkOption {
            description = "Number or name of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.";
            type = (types.either types.int types.str);
          };
        };

        config = {
          "host" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe" =
      {

        options = {
          "exec" = mkOption {
            description = "Exec specifies a command to execute in the container.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeExec"
              )
            );
          };
          "failureThreshold" = mkOption {
            description = "Minimum consecutive failures for the probe to be considered failed after having succeeded.\nDefaults to 3. Minimum value is 1.";
            type = (types.nullOr types.int);
          };
          "grpc" = mkOption {
            description = "GRPC specifies a GRPC HealthCheckRequest.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeGrpc"
              )
            );
          };
          "httpGet" = mkOption {
            description = "HTTPGet specifies an HTTP GET request to perform.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet"
              )
            );
          };
          "initialDelaySeconds" = mkOption {
            description = "Number of seconds after the container has started before liveness probes are initiated.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes";
            type = (types.nullOr types.int);
          };
          "periodSeconds" = mkOption {
            description = "How often (in seconds) to perform the probe.\nDefault to 10 seconds. Minimum value is 1.";
            type = (types.nullOr types.int);
          };
          "successThreshold" = mkOption {
            description = "Minimum consecutive successes for the probe to be considered successful after having failed.\nDefaults to 1. Must be 1 for liveness and startup. Minimum value is 1.";
            type = (types.nullOr types.int);
          };
          "tcpSocket" = mkOption {
            description = "TCPSocket specifies a connection to a TCP port.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocket"
              )
            );
          };
          "terminationGracePeriodSeconds" = mkOption {
            description = "Optional duration in seconds the pod needs to terminate gracefully upon probe failure.\nThe grace period is the duration in seconds after the processes running in the pod are sent\na termination signal and the time when the processes are forcibly halted with a kill signal.\nSet this value longer than the expected cleanup time for your process.\nIf this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this\nvalue overrides the value provided by the pod spec.\nValue must be non-negative integer. The value zero indicates stop immediately via\nthe kill signal (no opportunity to shut down).\nThis is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.\nMinimum value is 1. spec.terminationGracePeriodSeconds is used if unset.";
            type = (types.nullOr types.int);
          };
          "timeoutSeconds" = mkOption {
            description = "Number of seconds after which the probe times out.\nDefaults to 1 second. Minimum value is 1.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "exec" = mkOverride 1002 null;
          "failureThreshold" = mkOverride 1002 null;
          "grpc" = mkOverride 1002 null;
          "httpGet" = mkOverride 1002 null;
          "initialDelaySeconds" = mkOverride 1002 null;
          "periodSeconds" = mkOverride 1002 null;
          "successThreshold" = mkOverride 1002 null;
          "tcpSocket" = mkOverride 1002 null;
          "terminationGracePeriodSeconds" = mkOverride 1002 null;
          "timeoutSeconds" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeExec" =
      {

        options = {
          "command" = mkOption {
            description = "Command is the command line to execute inside the container, the working directory for the\ncommand  is root ('/') in the container's filesystem. The command is simply exec'd, it is\nnot run inside a shell, so traditional shell instructions ('|', etc) won't work. To use\na shell, you need to explicitly call out to that shell.\nExit status of 0 is treated as live/healthy and non-zero is unhealthy.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "command" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeGrpc" =
      {

        options = {
          "port" = mkOption {
            description = "Port number of the gRPC service. Number must be in the range 1 to 65535.";
            type = types.int;
          };
          "service" = mkOption {
            description = "Service is the name of the service to place in the gRPC HealthCheckRequest\n(see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).\n\nIf this is not specified, the default behavior is defined by gRPC.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "service" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet" =
      {

        options = {
          "host" = mkOption {
            description = "Host name to connect to, defaults to the pod IP. You probably want to set\n\"Host\" in httpHeaders instead.";
            type = (types.nullOr types.str);
          };
          "httpHeaders" = mkOption {
            description = "Custom headers to set in the request. HTTP allows repeated headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetHttpHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "path" = mkOption {
            description = "Path to access on the HTTP server.";
            type = (types.nullOr types.str);
          };
          "port" = mkOption {
            description = "Name or number of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.";
            type = (types.either types.int types.str);
          };
          "scheme" = mkOption {
            description = "Scheme to use for connecting to the host.\nDefaults to HTTP.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "host" = mkOverride 1002 null;
          "httpHeaders" = mkOverride 1002 null;
          "path" = mkOverride 1002 null;
          "scheme" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetHttpHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "The header field name.\nThis will be canonicalized upon output, so case-variant names will be understood as the same header.";
            type = types.str;
          };
          "value" = mkOption {
            description = "The header field value";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocket" =
      {

        options = {
          "host" = mkOption {
            description = "Optional: Host name to connect to, defaults to the pod IP.";
            type = (types.nullOr types.str);
          };
          "port" = mkOption {
            description = "Number or name of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.";
            type = (types.either types.int types.str);
          };
        };

        config = {
          "host" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts" =
      {

        options = {
          "containerPort" = mkOption {
            description = "Number of port to expose on the pod's IP address.\nThis must be a valid port number, 0 < x < 65536.";
            type = types.int;
          };
          "hostIP" = mkOption {
            description = "What host IP to bind the external port to.";
            type = (types.nullOr types.str);
          };
          "hostPort" = mkOption {
            description = "Number of port to expose on the host.\nIf specified, this must be a valid port number, 0 < x < 65536.\nIf HostNetwork is specified, this must match ContainerPort.\nMost containers do not need this.";
            type = (types.nullOr types.int);
          };
          "name" = mkOption {
            description = "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each\nnamed port in a pod must have a unique name. Name for the port that can be\nreferred to by services.";
            type = (types.nullOr types.str);
          };
          "protocol" = mkOption {
            description = "Protocol for port. Must be UDP, TCP, or SCTP.\nDefaults to \"TCP\".";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "hostIP" = mkOverride 1002 null;
          "hostPort" = mkOverride 1002 null;
          "name" = mkOverride 1002 null;
          "protocol" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe" =
      {

        options = {
          "exec" = mkOption {
            description = "Exec specifies a command to execute in the container.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeExec"
              )
            );
          };
          "failureThreshold" = mkOption {
            description = "Minimum consecutive failures for the probe to be considered failed after having succeeded.\nDefaults to 3. Minimum value is 1.";
            type = (types.nullOr types.int);
          };
          "grpc" = mkOption {
            description = "GRPC specifies a GRPC HealthCheckRequest.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeGrpc"
              )
            );
          };
          "httpGet" = mkOption {
            description = "HTTPGet specifies an HTTP GET request to perform.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet"
              )
            );
          };
          "initialDelaySeconds" = mkOption {
            description = "Number of seconds after the container has started before liveness probes are initiated.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes";
            type = (types.nullOr types.int);
          };
          "periodSeconds" = mkOption {
            description = "How often (in seconds) to perform the probe.\nDefault to 10 seconds. Minimum value is 1.";
            type = (types.nullOr types.int);
          };
          "successThreshold" = mkOption {
            description = "Minimum consecutive successes for the probe to be considered successful after having failed.\nDefaults to 1. Must be 1 for liveness and startup. Minimum value is 1.";
            type = (types.nullOr types.int);
          };
          "tcpSocket" = mkOption {
            description = "TCPSocket specifies a connection to a TCP port.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocket"
              )
            );
          };
          "terminationGracePeriodSeconds" = mkOption {
            description = "Optional duration in seconds the pod needs to terminate gracefully upon probe failure.\nThe grace period is the duration in seconds after the processes running in the pod are sent\na termination signal and the time when the processes are forcibly halted with a kill signal.\nSet this value longer than the expected cleanup time for your process.\nIf this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this\nvalue overrides the value provided by the pod spec.\nValue must be non-negative integer. The value zero indicates stop immediately via\nthe kill signal (no opportunity to shut down).\nThis is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.\nMinimum value is 1. spec.terminationGracePeriodSeconds is used if unset.";
            type = (types.nullOr types.int);
          };
          "timeoutSeconds" = mkOption {
            description = "Number of seconds after which the probe times out.\nDefaults to 1 second. Minimum value is 1.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "exec" = mkOverride 1002 null;
          "failureThreshold" = mkOverride 1002 null;
          "grpc" = mkOverride 1002 null;
          "httpGet" = mkOverride 1002 null;
          "initialDelaySeconds" = mkOverride 1002 null;
          "periodSeconds" = mkOverride 1002 null;
          "successThreshold" = mkOverride 1002 null;
          "tcpSocket" = mkOverride 1002 null;
          "terminationGracePeriodSeconds" = mkOverride 1002 null;
          "timeoutSeconds" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeExec" =
      {

        options = {
          "command" = mkOption {
            description = "Command is the command line to execute inside the container, the working directory for the\ncommand  is root ('/') in the container's filesystem. The command is simply exec'd, it is\nnot run inside a shell, so traditional shell instructions ('|', etc) won't work. To use\na shell, you need to explicitly call out to that shell.\nExit status of 0 is treated as live/healthy and non-zero is unhealthy.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "command" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeGrpc" =
      {

        options = {
          "port" = mkOption {
            description = "Port number of the gRPC service. Number must be in the range 1 to 65535.";
            type = types.int;
          };
          "service" = mkOption {
            description = "Service is the name of the service to place in the gRPC HealthCheckRequest\n(see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).\n\nIf this is not specified, the default behavior is defined by gRPC.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "service" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet" =
      {

        options = {
          "host" = mkOption {
            description = "Host name to connect to, defaults to the pod IP. You probably want to set\n\"Host\" in httpHeaders instead.";
            type = (types.nullOr types.str);
          };
          "httpHeaders" = mkOption {
            description = "Custom headers to set in the request. HTTP allows repeated headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetHttpHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "path" = mkOption {
            description = "Path to access on the HTTP server.";
            type = (types.nullOr types.str);
          };
          "port" = mkOption {
            description = "Name or number of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.";
            type = (types.either types.int types.str);
          };
          "scheme" = mkOption {
            description = "Scheme to use for connecting to the host.\nDefaults to HTTP.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "host" = mkOverride 1002 null;
          "httpHeaders" = mkOverride 1002 null;
          "path" = mkOverride 1002 null;
          "scheme" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetHttpHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "The header field name.\nThis will be canonicalized upon output, so case-variant names will be understood as the same header.";
            type = types.str;
          };
          "value" = mkOption {
            description = "The header field value";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocket" =
      {

        options = {
          "host" = mkOption {
            description = "Optional: Host name to connect to, defaults to the pod IP.";
            type = (types.nullOr types.str);
          };
          "port" = mkOption {
            description = "Number or name of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.";
            type = (types.either types.int types.str);
          };
        };

        config = {
          "host" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResizePolicy" =
      {

        options = {
          "resourceName" = mkOption {
            description = "Name of the resource to which this resource resize policy applies.\nSupported values: cpu, memory.";
            type = types.str;
          };
          "restartPolicy" = mkOption {
            description = "Restart policy to apply when specified resource is resized.\nIf not specified, it defaults to NotRequired.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources" =
      {

        options = {
          "claims" = mkOption {
            description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesClaims"
                  "name"
                  [ "name" ]
              )
            );
            apply = attrsToList;
          };
          "limits" = mkOption {
            description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
          "requests" = mkOption {
            description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
        };

        config = {
          "claims" = mkOverride 1002 null;
          "limits" = mkOverride 1002 null;
          "requests" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesClaims" =
      {

        options = {
          "name" = mkOption {
            description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
            type = types.str;
          };
          "request" = mkOption {
            description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "request" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRules" =
      {

        options = {
          "action" = mkOption {
            description = "Specifies the action taken on a container exit if the requirements\nare satisfied. The only possible value is \"Restart\" to restart the\ncontainer.";
            type = types.str;
          };
          "exitCodes" = mkOption {
            description = "Represents the exit codes to check on container exits.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRulesExitCodes"
              )
            );
          };
        };

        config = {
          "exitCodes" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRulesExitCodes" =
      {

        options = {
          "operator" = mkOption {
            description = "Represents the relationship between the container exit code(s) and the\nspecified values. Possible values are:\n- In: the requirement is satisfied if the container exit code is in the\n  set of specified values.\n- NotIn: the requirement is satisfied if the container exit code is\n  not in the set of specified values.";
            type = types.str;
          };
          "values" = mkOption {
            description = "Specifies the set of values to check for container exit codes.\nAt most 255 elements are allowed.";
            type = (types.nullOr (types.listOf types.int));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext" =
      {

        options = {
          "allowPrivilegeEscalation" = mkOption {
            description = "AllowPrivilegeEscalation controls whether a process can gain more\nprivileges than its parent process. This bool directly controls if\nthe no_new_privs flag will be set on the container process.\nAllowPrivilegeEscalation is true always when the container is:\n1) run as Privileged\n2) has CAP_SYS_ADMIN\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.bool);
          };
          "appArmorProfile" = mkOption {
            description = "appArmorProfile is the AppArmor options to use by this container. If set, this profile\noverrides the pod's appArmorProfile.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextAppArmorProfile"
              )
            );
          };
          "capabilities" = mkOption {
            description = "The capabilities to add/drop when running containers.\nDefaults to the default set of capabilities granted by the container runtime.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextCapabilities"
              )
            );
          };
          "privileged" = mkOption {
            description = "Run container in privileged mode.\nProcesses in privileged containers are essentially equivalent to root on the host.\nDefaults to false.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.bool);
          };
          "procMount" = mkOption {
            description = "procMount denotes the type of proc mount to use for the containers.\nThe default value is Default which uses the container runtime defaults for\nreadonly paths and masked paths.\nThis requires the ProcMountType feature flag to be enabled.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.str);
          };
          "readOnlyRootFilesystem" = mkOption {
            description = "Whether this container has a read-only root filesystem.\nDefault is false.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.bool);
          };
          "runAsGroup" = mkOption {
            description = "The GID to run the entrypoint of the container process.\nUses runtime default if unset.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.int);
          };
          "runAsNonRoot" = mkOption {
            description = "Indicates that the container must run as a non-root user.\nIf true, the Kubelet will validate the image at runtime to ensure that it\ndoes not run as UID 0 (root) and fail to start the container if it does.\nIf unset or false, no such validation will be performed.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.";
            type = (types.nullOr types.bool);
          };
          "runAsUser" = mkOption {
            description = "The UID to run the entrypoint of the container process.\nDefaults to user specified in image metadata if unspecified.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.int);
          };
          "seLinuxOptions" = mkOption {
            description = "The SELinux context to be applied to the container.\nIf unspecified, the container runtime will allocate a random SELinux context for each\ncontainer.  May also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions"
              )
            );
          };
          "seccompProfile" = mkOption {
            description = "The seccomp options to use by this container. If seccomp options are\nprovided at both the pod & container level, the container options\noverride the pod options.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeccompProfile"
              )
            );
          };
          "windowsOptions" = mkOption {
            description = "The Windows specific settings applied to all containers.\nIf unspecified, the options from the PodSecurityContext will be used.\nIf set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is linux.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions"
              )
            );
          };
        };

        config = {
          "allowPrivilegeEscalation" = mkOverride 1002 null;
          "appArmorProfile" = mkOverride 1002 null;
          "capabilities" = mkOverride 1002 null;
          "privileged" = mkOverride 1002 null;
          "procMount" = mkOverride 1002 null;
          "readOnlyRootFilesystem" = mkOverride 1002 null;
          "runAsGroup" = mkOverride 1002 null;
          "runAsNonRoot" = mkOverride 1002 null;
          "runAsUser" = mkOverride 1002 null;
          "seLinuxOptions" = mkOverride 1002 null;
          "seccompProfile" = mkOverride 1002 null;
          "windowsOptions" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextAppArmorProfile" =
      {

        options = {
          "localhostProfile" = mkOption {
            description = "localhostProfile indicates a profile loaded on the node that should be used.\nThe profile must be preconfigured on the node to work.\nMust match the loaded name of the profile.\nMust be set if and only if type is \"Localhost\".";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "type indicates which kind of AppArmor profile will be applied.\nValid options are:\n  Localhost - a profile pre-loaded on the node.\n  RuntimeDefault - the container runtime's default profile.\n  Unconfined - no AppArmor enforcement.";
            type = types.str;
          };
        };

        config = {
          "localhostProfile" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextCapabilities" =
      {

        options = {
          "add" = mkOption {
            description = "Added capabilities";
            type = (types.nullOr (types.listOf types.str));
          };
          "drop" = mkOption {
            description = "Removed capabilities";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "add" = mkOverride 1002 null;
          "drop" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions" =
      {

        options = {
          "level" = mkOption {
            description = "Level is SELinux level label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "role" = mkOption {
            description = "Role is a SELinux role label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type is a SELinux type label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "user" = mkOption {
            description = "User is a SELinux user label that applies to the container.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "level" = mkOverride 1002 null;
          "role" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
          "user" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeccompProfile" =
      {

        options = {
          "localhostProfile" = mkOption {
            description = "localhostProfile indicates a profile defined in a file on the node should be used.\nThe profile must be preconfigured on the node to work.\nMust be a descending path, relative to the kubelet's configured seccomp profile location.\nMust be set if type is \"Localhost\". Must NOT be set for any other type.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "type indicates which kind of seccomp profile will be applied.\nValid options are:\n\nLocalhost - a profile defined in a file on the node should be used.\nRuntimeDefault - the container runtime default profile should be used.\nUnconfined - no profile should be applied.";
            type = types.str;
          };
        };

        config = {
          "localhostProfile" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions" =
      {

        options = {
          "gmsaCredentialSpec" = mkOption {
            description = "GMSACredentialSpec is where the GMSA admission webhook\n(https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the\nGMSA credential spec named by the GMSACredentialSpecName field.";
            type = (types.nullOr types.str);
          };
          "gmsaCredentialSpecName" = mkOption {
            description = "GMSACredentialSpecName is the name of the GMSA credential spec to use.";
            type = (types.nullOr types.str);
          };
          "hostProcess" = mkOption {
            description = "HostProcess determines if a container should be run as a 'Host Process' container.\nAll of a Pod's containers must have the same effective HostProcess value\n(it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).\nIn addition, if HostProcess is true then HostNetwork must also be set to true.";
            type = (types.nullOr types.bool);
          };
          "runAsUserName" = mkOption {
            description = "The UserName in Windows to run the entrypoint of the container process.\nDefaults to the user specified in image metadata if unspecified.\nMay also be set in PodSecurityContext. If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "gmsaCredentialSpec" = mkOverride 1002 null;
          "gmsaCredentialSpecName" = mkOverride 1002 null;
          "hostProcess" = mkOverride 1002 null;
          "runAsUserName" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe" =
      {

        options = {
          "exec" = mkOption {
            description = "Exec specifies a command to execute in the container.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeExec"
              )
            );
          };
          "failureThreshold" = mkOption {
            description = "Minimum consecutive failures for the probe to be considered failed after having succeeded.\nDefaults to 3. Minimum value is 1.";
            type = (types.nullOr types.int);
          };
          "grpc" = mkOption {
            description = "GRPC specifies a GRPC HealthCheckRequest.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeGrpc"
              )
            );
          };
          "httpGet" = mkOption {
            description = "HTTPGet specifies an HTTP GET request to perform.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet"
              )
            );
          };
          "initialDelaySeconds" = mkOption {
            description = "Number of seconds after the container has started before liveness probes are initiated.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes";
            type = (types.nullOr types.int);
          };
          "periodSeconds" = mkOption {
            description = "How often (in seconds) to perform the probe.\nDefault to 10 seconds. Minimum value is 1.";
            type = (types.nullOr types.int);
          };
          "successThreshold" = mkOption {
            description = "Minimum consecutive successes for the probe to be considered successful after having failed.\nDefaults to 1. Must be 1 for liveness and startup. Minimum value is 1.";
            type = (types.nullOr types.int);
          };
          "tcpSocket" = mkOption {
            description = "TCPSocket specifies a connection to a TCP port.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocket"
              )
            );
          };
          "terminationGracePeriodSeconds" = mkOption {
            description = "Optional duration in seconds the pod needs to terminate gracefully upon probe failure.\nThe grace period is the duration in seconds after the processes running in the pod are sent\na termination signal and the time when the processes are forcibly halted with a kill signal.\nSet this value longer than the expected cleanup time for your process.\nIf this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this\nvalue overrides the value provided by the pod spec.\nValue must be non-negative integer. The value zero indicates stop immediately via\nthe kill signal (no opportunity to shut down).\nThis is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.\nMinimum value is 1. spec.terminationGracePeriodSeconds is used if unset.";
            type = (types.nullOr types.int);
          };
          "timeoutSeconds" = mkOption {
            description = "Number of seconds after which the probe times out.\nDefaults to 1 second. Minimum value is 1.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "exec" = mkOverride 1002 null;
          "failureThreshold" = mkOverride 1002 null;
          "grpc" = mkOverride 1002 null;
          "httpGet" = mkOverride 1002 null;
          "initialDelaySeconds" = mkOverride 1002 null;
          "periodSeconds" = mkOverride 1002 null;
          "successThreshold" = mkOverride 1002 null;
          "tcpSocket" = mkOverride 1002 null;
          "terminationGracePeriodSeconds" = mkOverride 1002 null;
          "timeoutSeconds" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeExec" =
      {

        options = {
          "command" = mkOption {
            description = "Command is the command line to execute inside the container, the working directory for the\ncommand  is root ('/') in the container's filesystem. The command is simply exec'd, it is\nnot run inside a shell, so traditional shell instructions ('|', etc) won't work. To use\na shell, you need to explicitly call out to that shell.\nExit status of 0 is treated as live/healthy and non-zero is unhealthy.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "command" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeGrpc" =
      {

        options = {
          "port" = mkOption {
            description = "Port number of the gRPC service. Number must be in the range 1 to 65535.";
            type = types.int;
          };
          "service" = mkOption {
            description = "Service is the name of the service to place in the gRPC HealthCheckRequest\n(see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).\n\nIf this is not specified, the default behavior is defined by gRPC.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "service" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet" =
      {

        options = {
          "host" = mkOption {
            description = "Host name to connect to, defaults to the pod IP. You probably want to set\n\"Host\" in httpHeaders instead.";
            type = (types.nullOr types.str);
          };
          "httpHeaders" = mkOption {
            description = "Custom headers to set in the request. HTTP allows repeated headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetHttpHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "path" = mkOption {
            description = "Path to access on the HTTP server.";
            type = (types.nullOr types.str);
          };
          "port" = mkOption {
            description = "Name or number of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.";
            type = (types.either types.int types.str);
          };
          "scheme" = mkOption {
            description = "Scheme to use for connecting to the host.\nDefaults to HTTP.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "host" = mkOverride 1002 null;
          "httpHeaders" = mkOverride 1002 null;
          "path" = mkOverride 1002 null;
          "scheme" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetHttpHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "The header field name.\nThis will be canonicalized upon output, so case-variant names will be understood as the same header.";
            type = types.str;
          };
          "value" = mkOption {
            description = "The header field value";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocket" =
      {

        options = {
          "host" = mkOption {
            description = "Optional: Host name to connect to, defaults to the pod IP.";
            type = (types.nullOr types.str);
          };
          "port" = mkOption {
            description = "Number or name of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.";
            type = (types.either types.int types.str);
          };
        };

        config = {
          "host" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeDevices" =
      {

        options = {
          "devicePath" = mkOption {
            description = "devicePath is the path inside of the container that the device will be mapped to.";
            type = types.str;
          };
          "name" = mkOption {
            description = "name must match the name of a persistentVolumeClaim in the pod";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts" =
      {

        options = {
          "mountPath" = mkOption {
            description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
            type = types.str;
          };
          "mountPropagation" = mkOption {
            description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
            type = (types.nullOr types.str);
          };
          "name" = mkOption {
            description = "This must match the Name of a Volume.";
            type = types.str;
          };
          "readOnly" = mkOption {
            description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
            type = (types.nullOr types.bool);
          };
          "recursiveReadOnly" = mkOption {
            description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
            type = (types.nullOr types.str);
          };
          "subPath" = mkOption {
            description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
            type = (types.nullOr types.str);
          };
          "subPathExpr" = mkOption {
            description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "mountPropagation" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
          "recursiveReadOnly" = mkOverride 1002 null;
          "subPath" = mkOverride 1002 null;
          "subPathExpr" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch" = {

      options = {
        "type" = mkOption {
          description = "Type is the type of merge operation to perform\n\nBy default, StrategicMerge is used as the patch type.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Object contains the raw configuration for merged object";
          type = types.unspecified;
        };
      };

      config = {
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod" = {

      options = {
        "affinity" = mkOption {
          description = "If specified, the pod's scheduling constraints.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity"
            )
          );
        };
        "annotations" = mkOption {
          description = "Annotations are the annotations that should be appended to the pods.\nBy default, no pod annotations are appended.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets is an optional list of references to secrets\nin the same namespace to use for pulling any of the images used by this PodSpec.\nIf specified, these secrets will be passed to individual puller implementations for them to use.\nMore info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "labels" = mkOption {
          description = "Labels are the additional labels that should be tagged to the pods.\nBy default, no additional pod labels are tagged.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector is a selector which must be true for the pod to fit on a node.\nSelector which must match a node's labels for the pod to be scheduled on that node.\nMore info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName indicates the importance of a Pod relative to other Pods.\nIf a PriorityClassName is not specified, the pod priority will be default or zero if there is no default.\nMore info: https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/";
          type = (types.nullOr types.str);
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nOptional: Defaults to empty.  See type description for default values of each field.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext"
            )
          );
        };
        "tolerations" = mkOption {
          description = "If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations"
              )
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints describes how a group of pods ought to spread across topology\ndomains. Scheduler will schedule pods in a way which abides by the constraints.\nAll topologySpreadConstraints are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints"
              )
            )
          );
        };
        "volumes" = mkOption {
          description = "Volumes that can be mounted by containers belonging to the pod.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "annotations" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity" = {

      options = {
        "nodeAffinity" = mkOption {
          description = "Describes node affinity scheduling rules for the pod.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinity"
            )
          );
        };
        "podAffinity" = mkOption {
          description = "Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinity"
            )
          );
        };
        "podAntiAffinity" = mkOption {
          description = "Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinity"
            )
          );
        };
      };

      config = {
        "nodeAffinity" = mkOverride 1002 null;
        "podAffinity" = mkOverride 1002 null;
        "podAntiAffinity" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinity" =
      {

        options = {
          "preferredDuringSchedulingIgnoredDuringExecution" = mkOption {
            description = "The scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions specified by this field, but it may choose\na node that violates one or more of the expressions. The node that is\nmost preferred is the one with the greatest sum of weights, i.e.\nfor each node that meets all of the scheduling requirements (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\" to the sum if the node matches the corresponding matchExpressions; the\nnode(s) with the highest sum are the most preferred.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"
                )
              )
            );
          };
          "requiredDuringSchedulingIgnoredDuringExecution" = mkOption {
            description = "If the affinity requirements specified by this field are not met at\nscheduling time, the pod will not be scheduled onto the node.\nIf the affinity requirements specified by this field cease to be met\nat some point during pod execution (e.g. due to an update), the system\nmay or may not try to eventually evict the pod from its node.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"
              )
            );
          };
        };

        config = {
          "preferredDuringSchedulingIgnoredDuringExecution" = mkOverride 1002 null;
          "requiredDuringSchedulingIgnoredDuringExecution" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution" =
      {

        options = {
          "preference" = mkOption {
            description = "A node selector term, associated with the corresponding weight.";
            type = (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference"
            );
          };
          "weight" = mkOption {
            description = "Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.";
            type = types.int;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "A list of node selector requirements by node's labels.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"
                )
              )
            );
          };
          "matchFields" = mkOption {
            description = "A list of node selector requirements by node's fields.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"
                )
              )
            );
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchFields" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "The label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.";
            type = types.str;
          };
          "values" = mkOption {
            description = "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields" =
      {

        options = {
          "key" = mkOption {
            description = "The label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.";
            type = types.str;
          };
          "values" = mkOption {
            description = "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution" =
      {

        options = {
          "nodeSelectorTerms" = mkOption {
            description = "Required. A list of node selector terms. The terms are ORed.";
            type = (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"
              )
            );
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "A list of node selector requirements by node's labels.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"
                )
              )
            );
          };
          "matchFields" = mkOption {
            description = "A list of node selector requirements by node's fields.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"
                )
              )
            );
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchFields" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "The label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.";
            type = types.str;
          };
          "values" = mkOption {
            description = "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields" =
      {

        options = {
          "key" = mkOption {
            description = "The label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.";
            type = types.str;
          };
          "values" = mkOption {
            description = "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinity" =
      {

        options = {
          "preferredDuringSchedulingIgnoredDuringExecution" = mkOption {
            description = "The scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions specified by this field, but it may choose\na node that violates one or more of the expressions. The node that is\nmost preferred is the one with the greatest sum of weights, i.e.\nfor each node that meets all of the scheduling requirements (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the\nnode(s) with the highest sum are the most preferred.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"
                )
              )
            );
          };
          "requiredDuringSchedulingIgnoredDuringExecution" = mkOption {
            description = "If the affinity requirements specified by this field are not met at\nscheduling time, the pod will not be scheduled onto the node.\nIf the affinity requirements specified by this field cease to be met\nat some point during pod execution (e.g. due to a pod label update), the\nsystem may or may not try to eventually evict the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"
                )
              )
            );
          };
        };

        config = {
          "preferredDuringSchedulingIgnoredDuringExecution" = mkOverride 1002 null;
          "requiredDuringSchedulingIgnoredDuringExecution" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution" =
      {

        options = {
          "podAffinityTerm" = mkOption {
            description = "Required. A pod affinity term, associated with the corresponding weight.";
            type = (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm"
            );
          };
          "weight" = mkOption {
            description = "weight associated with matching the corresponding podAffinityTerm,\nin the range 1-100.";
            type = types.int;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm" =
      {

        options = {
          "labelSelector" = mkOption {
            description = "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"
              )
            );
          };
          "matchLabelKeys" = mkOption {
            description = "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "mismatchLabelKeys" = mkOption {
            description = "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "namespaceSelector" = mkOption {
            description = "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"
              )
            );
          };
          "namespaces" = mkOption {
            description = "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".";
            type = (types.nullOr (types.listOf types.str));
          };
          "topologyKey" = mkOption {
            description = "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.";
            type = types.str;
          };
        };

        config = {
          "labelSelector" = mkOverride 1002 null;
          "matchLabelKeys" = mkOverride 1002 null;
          "mismatchLabelKeys" = mkOverride 1002 null;
          "namespaceSelector" = mkOverride 1002 null;
          "namespaces" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution" =
      {

        options = {
          "labelSelector" = mkOption {
            description = "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"
              )
            );
          };
          "matchLabelKeys" = mkOption {
            description = "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "mismatchLabelKeys" = mkOption {
            description = "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "namespaceSelector" = mkOption {
            description = "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"
              )
            );
          };
          "namespaces" = mkOption {
            description = "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".";
            type = (types.nullOr (types.listOf types.str));
          };
          "topologyKey" = mkOption {
            description = "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.";
            type = types.str;
          };
        };

        config = {
          "labelSelector" = mkOverride 1002 null;
          "matchLabelKeys" = mkOverride 1002 null;
          "mismatchLabelKeys" = mkOverride 1002 null;
          "namespaceSelector" = mkOverride 1002 null;
          "namespaces" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinity" =
      {

        options = {
          "preferredDuringSchedulingIgnoredDuringExecution" = mkOption {
            description = "The scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity expressions specified by this field, but it may choose\na node that violates one or more of the expressions. The node that is\nmost preferred is the one with the greatest sum of weights, i.e.\nfor each node that meets all of the scheduling requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions, etc.),\ncompute a sum by iterating through the elements of this field and subtracting\n\"weight\" from the sum if the node has pods which matches the corresponding podAffinityTerm; the\nnode(s) with the highest sum are the most preferred.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"
                )
              )
            );
          };
          "requiredDuringSchedulingIgnoredDuringExecution" = mkOption {
            description = "If the anti-affinity requirements specified by this field are not met at\nscheduling time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements specified by this field cease to be met\nat some point during pod execution (e.g. due to a pod label update), the\nsystem may or may not try to eventually evict the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"
                )
              )
            );
          };
        };

        config = {
          "preferredDuringSchedulingIgnoredDuringExecution" = mkOverride 1002 null;
          "requiredDuringSchedulingIgnoredDuringExecution" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution" =
      {

        options = {
          "podAffinityTerm" = mkOption {
            description = "Required. A pod affinity term, associated with the corresponding weight.";
            type = (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm"
            );
          };
          "weight" = mkOption {
            description = "weight associated with matching the corresponding podAffinityTerm,\nin the range 1-100.";
            type = types.int;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm" =
      {

        options = {
          "labelSelector" = mkOption {
            description = "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"
              )
            );
          };
          "matchLabelKeys" = mkOption {
            description = "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "mismatchLabelKeys" = mkOption {
            description = "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "namespaceSelector" = mkOption {
            description = "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"
              )
            );
          };
          "namespaces" = mkOption {
            description = "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".";
            type = (types.nullOr (types.listOf types.str));
          };
          "topologyKey" = mkOption {
            description = "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.";
            type = types.str;
          };
        };

        config = {
          "labelSelector" = mkOverride 1002 null;
          "matchLabelKeys" = mkOverride 1002 null;
          "mismatchLabelKeys" = mkOverride 1002 null;
          "namespaceSelector" = mkOverride 1002 null;
          "namespaces" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution" =
      {

        options = {
          "labelSelector" = mkOption {
            description = "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"
              )
            );
          };
          "matchLabelKeys" = mkOption {
            description = "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "mismatchLabelKeys" = mkOption {
            description = "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.";
            type = (types.nullOr (types.listOf types.str));
          };
          "namespaceSelector" = mkOption {
            description = "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"
              )
            );
          };
          "namespaces" = mkOption {
            description = "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".";
            type = (types.nullOr (types.listOf types.str));
          };
          "topologyKey" = mkOption {
            description = "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.";
            type = types.str;
          };
        };

        config = {
          "labelSelector" = mkOverride 1002 null;
          "matchLabelKeys" = mkOverride 1002 null;
          "mismatchLabelKeys" = mkOverride 1002 null;
          "namespaceSelector" = mkOverride 1002 null;
          "namespaces" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodImagePullSecrets" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext" =
      {

        options = {
          "appArmorProfile" = mkOption {
            description = "appArmorProfile is the AppArmor options to use by the containers in this pod.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextAppArmorProfile"
              )
            );
          };
          "fsGroup" = mkOption {
            description = "A special supplemental group that applies to all containers in a pod.\nSome volume types allow the Kubelet to change the ownership of that volume\nto be owned by the pod:\n\n1. The owning GID will be the FSGroup\n2. The setgid bit is set (new files created in the volume will be owned by FSGroup)\n3. The permission bits are OR'd with rw-rw----\n\nIf unset, the Kubelet will not modify the ownership and permissions of any volume.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.int);
          };
          "fsGroupChangePolicy" = mkOption {
            description = "fsGroupChangePolicy defines behavior of changing ownership and permission of the volume\nbefore being exposed inside Pod. This field will only apply to\nvolume types which support fsGroup based ownership(and permissions).\nIt will have no effect on ephemeral volume types such as: secret, configmaps\nand emptydir.\nValid values are \"OnRootMismatch\" and \"Always\". If not specified, \"Always\" is used.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.str);
          };
          "runAsGroup" = mkOption {
            description = "The GID to run the entrypoint of the container process.\nUses runtime default if unset.\nMay also be set in SecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence\nfor that container.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.int);
          };
          "runAsNonRoot" = mkOption {
            description = "Indicates that the container must run as a non-root user.\nIf true, the Kubelet will validate the image at runtime to ensure that it\ndoes not run as UID 0 (root) and fail to start the container if it does.\nIf unset or false, no such validation will be performed.\nMay also be set in SecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.";
            type = (types.nullOr types.bool);
          };
          "runAsUser" = mkOption {
            description = "The UID to run the entrypoint of the container process.\nDefaults to user specified in image metadata if unspecified.\nMay also be set in SecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence\nfor that container.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.int);
          };
          "seLinuxChangePolicy" = mkOption {
            description = "seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.\nIt has no effect on nodes that do not support SELinux or to volumes does not support SELinux.\nValid values are \"MountOption\" and \"Recursive\".\n\n\"Recursive\" means relabeling of all files on all Pod volumes by the container runtime.\nThis may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.\n\n\"MountOption\" mounts all eligible Pod volumes with `-o context` mount option.\nThis requires all Pods that share the same volume to use the same SELinux label.\nIt is not possible to share the same volume among privileged and unprivileged Pods.\nEligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes\nwhose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their\nCSIDriver instance. Other volumes are always re-labelled recursively.\n\"MountOption\" value is allowed only when SELinuxMount feature gate is enabled.\n\nIf not specified and SELinuxMount feature gate is enabled, \"MountOption\" is used.\nIf not specified and SELinuxMount feature gate is disabled, \"MountOption\" is used for ReadWriteOncePod volumes\nand \"Recursive\" for all other volumes.\n\nThis field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.\n\nAll Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.str);
          };
          "seLinuxOptions" = mkOption {
            description = "The SELinux context to be applied to all containers.\nIf unspecified, the container runtime will allocate a random SELinux context for each\ncontainer.  May also be set in SecurityContext.  If set in\nboth SecurityContext and PodSecurityContext, the value specified in SecurityContext\ntakes precedence for that container.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions"
              )
            );
          };
          "seccompProfile" = mkOption {
            description = "The seccomp options to use by the containers in this pod.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeccompProfile"
              )
            );
          };
          "supplementalGroups" = mkOption {
            description = "A list of groups applied to the first process run in each container, in\naddition to the container's primary GID and fsGroup (if specified).  If\nthe SupplementalGroupsPolicy feature is enabled, the\nsupplementalGroupsPolicy field determines whether these are in addition\nto or instead of any group memberships defined in the container image.\nIf unspecified, no additional groups are added, though group memberships\ndefined in the container image may still be used, depending on the\nsupplementalGroupsPolicy field.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr (types.listOf types.int));
          };
          "supplementalGroupsPolicy" = mkOption {
            description = "Defines how supplemental groups of the first container processes are calculated.\nValid values are \"Merge\" and \"Strict\". If not specified, \"Merge\" is used.\n(Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled\nand the container runtime must implement support for this feature.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (types.nullOr types.str);
          };
          "sysctls" = mkOption {
            description = "Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported\nsysctls (by the container runtime) might fail to launch.\nNote that this field cannot be set when spec.os.name is windows.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSysctls"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "windowsOptions" = mkOption {
            description = "The Windows specific settings applied to all containers.\nIf unspecified, the options within a container's SecurityContext will be used.\nIf set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is linux.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions"
              )
            );
          };
        };

        config = {
          "appArmorProfile" = mkOverride 1002 null;
          "fsGroup" = mkOverride 1002 null;
          "fsGroupChangePolicy" = mkOverride 1002 null;
          "runAsGroup" = mkOverride 1002 null;
          "runAsNonRoot" = mkOverride 1002 null;
          "runAsUser" = mkOverride 1002 null;
          "seLinuxChangePolicy" = mkOverride 1002 null;
          "seLinuxOptions" = mkOverride 1002 null;
          "seccompProfile" = mkOverride 1002 null;
          "supplementalGroups" = mkOverride 1002 null;
          "supplementalGroupsPolicy" = mkOverride 1002 null;
          "sysctls" = mkOverride 1002 null;
          "windowsOptions" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextAppArmorProfile" =
      {

        options = {
          "localhostProfile" = mkOption {
            description = "localhostProfile indicates a profile loaded on the node that should be used.\nThe profile must be preconfigured on the node to work.\nMust match the loaded name of the profile.\nMust be set if and only if type is \"Localhost\".";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "type indicates which kind of AppArmor profile will be applied.\nValid options are:\n  Localhost - a profile pre-loaded on the node.\n  RuntimeDefault - the container runtime's default profile.\n  Unconfined - no AppArmor enforcement.";
            type = types.str;
          };
        };

        config = {
          "localhostProfile" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions" =
      {

        options = {
          "level" = mkOption {
            description = "Level is SELinux level label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "role" = mkOption {
            description = "Role is a SELinux role label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type is a SELinux type label that applies to the container.";
            type = (types.nullOr types.str);
          };
          "user" = mkOption {
            description = "User is a SELinux user label that applies to the container.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "level" = mkOverride 1002 null;
          "role" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
          "user" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeccompProfile" =
      {

        options = {
          "localhostProfile" = mkOption {
            description = "localhostProfile indicates a profile defined in a file on the node should be used.\nThe profile must be preconfigured on the node to work.\nMust be a descending path, relative to the kubelet's configured seccomp profile location.\nMust be set if type is \"Localhost\". Must NOT be set for any other type.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "type indicates which kind of seccomp profile will be applied.\nValid options are:\n\nLocalhost - a profile defined in a file on the node should be used.\nRuntimeDefault - the container runtime default profile should be used.\nUnconfined - no profile should be applied.";
            type = types.str;
          };
        };

        config = {
          "localhostProfile" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSysctls" =
      {

        options = {
          "name" = mkOption {
            description = "Name of a property to set";
            type = types.str;
          };
          "value" = mkOption {
            description = "Value of a property to set";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions" =
      {

        options = {
          "gmsaCredentialSpec" = mkOption {
            description = "GMSACredentialSpec is where the GMSA admission webhook\n(https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the\nGMSA credential spec named by the GMSACredentialSpecName field.";
            type = (types.nullOr types.str);
          };
          "gmsaCredentialSpecName" = mkOption {
            description = "GMSACredentialSpecName is the name of the GMSA credential spec to use.";
            type = (types.nullOr types.str);
          };
          "hostProcess" = mkOption {
            description = "HostProcess determines if a container should be run as a 'Host Process' container.\nAll of a Pod's containers must have the same effective HostProcess value\n(it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).\nIn addition, if HostProcess is true then HostNetwork must also be set to true.";
            type = (types.nullOr types.bool);
          };
          "runAsUserName" = mkOption {
            description = "The UserName in Windows to run the entrypoint of the container process.\nDefaults to the user specified in image metadata if unspecified.\nMay also be set in PodSecurityContext. If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "gmsaCredentialSpec" = mkOverride 1002 null;
          "gmsaCredentialSpecName" = mkOverride 1002 null;
          "hostProcess" = mkOverride 1002 null;
          "runAsUserName" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists, Equal, Lt, and Gt. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.\nLt and Gt perform numeric comparisons (requires feature gate TaintTolerationComparisonOperators).";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints" =
      {

        options = {
          "labelSelector" = mkOption {
            description = "LabelSelector is used to find matching pods.\nPods that match this label selector are counted to determine the number of pods\nin their corresponding topology domain.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelector"
              )
            );
          };
          "matchLabelKeys" = mkOption {
            description = "MatchLabelKeys is a set of pod label keys to select the pods over which\nspreading will be calculated. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are ANDed with labelSelector\nto select the group of existing pods over which spreading will be calculated\nfor the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.\nMatchLabelKeys cannot be set when LabelSelector isn't set.\nKeys that don't exist in the incoming pod labels will\nbe ignored. A null or empty list means only match against labelSelector.\n\nThis is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).";
            type = (types.nullOr (types.listOf types.str));
          };
          "maxSkew" = mkOption {
            description = "MaxSkew describes the degree to which pods may be unevenly distributed.\nWhen `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference\nbetween the number of matching pods in the target topology and the global minimum.\nThe global minimum is the minimum number of matching pods in an eligible domain\nor zero if the number of eligible domains is less than MinDomains.\nFor example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same\nlabelSelector spread as 2/2/1:\nIn this case, the global minimum is 1.\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |   P   |\n- if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;\nscheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)\nviolate MaxSkew(1).\n- if MaxSkew is 2, incoming pod can be scheduled onto any zone.\nWhen `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence\nto topologies that satisfy it.\nIt's a required field. Default value is 1 and 0 is not allowed.";
            type = types.int;
          };
          "minDomains" = mkOption {
            description = "MinDomains indicates a minimum number of eligible domains.\nWhen the number of eligible domains with matching topology keys is less than minDomains,\nPod Topology Spread treats \"global minimum\" as 0, and then the calculation of Skew is performed.\nAnd when the number of eligible domains with matching topology keys equals or greater than minDomains,\nthis value has no effect on scheduling.\nAs a result, when the number of eligible domains is less than minDomains,\nscheduler won't schedule more than maxSkew Pods to those domains.\nIf value is nil, the constraint behaves as if MinDomains is equal to 1.\nValid values are integers greater than 0.\nWhen value is not nil, WhenUnsatisfiable must be DoNotSchedule.\n\nFor example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same\nlabelSelector spread as 2/2/2:\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |  P P  |\nThe number of domains is less than 5(MinDomains), so \"global minimum\" is treated as 0.\nIn this situation, new pod with the same labelSelector cannot be scheduled,\nbecause computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,\nit will violate MaxSkew.";
            type = (types.nullOr types.int);
          };
          "nodeAffinityPolicy" = mkOption {
            description = "NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector\nwhen calculating pod topology spread skew. Options are:\n- Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.\n- Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.\n\nIf this value is nil, the behavior is equivalent to the Honor policy.";
            type = (types.nullOr types.str);
          };
          "nodeTaintsPolicy" = mkOption {
            description = "NodeTaintsPolicy indicates how we will treat node taints when calculating\npod topology spread skew. Options are:\n- Honor: nodes without taints, along with tainted nodes for which the incoming pod\nhas a toleration, are included.\n- Ignore: node taints are ignored. All nodes are included.\n\nIf this value is nil, the behavior is equivalent to the Ignore policy.";
            type = (types.nullOr types.str);
          };
          "topologyKey" = mkOption {
            description = "TopologyKey is the key of node labels. Nodes that have a label with this key\nand identical values are considered to be in the same topology.\nWe consider each <key, value> as a \"bucket\", and try to put balanced number\nof pods into each bucket.\nWe define a domain as a particular instance of a topology.\nAlso, we define an eligible domain as a domain whose nodes meet the requirements of\nnodeAffinityPolicy and nodeTaintsPolicy.\ne.g. If TopologyKey is \"kubernetes.io/hostname\", each Node is a domain of that topology.\nAnd, if TopologyKey is \"topology.kubernetes.io/zone\", each zone is a domain of that topology.\nIt's a required field.";
            type = types.str;
          };
          "whenUnsatisfiable" = mkOption {
            description = "WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy\nthe spread constraint.\n- DoNotSchedule (default) tells the scheduler not to schedule it.\n- ScheduleAnyway tells the scheduler to schedule the pod in any location,\n  but giving higher precedence to topologies that would help reduce the\n  skew.\nA constraint is considered \"Unsatisfiable\" for an incoming pod\nif and only if every possible node assignment for that pod would violate\n\"MaxSkew\" on some topology.\nFor example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same\nlabelSelector spread as 3/1/1:\n| zone1 | zone2 | zone3 |\n| P P P |   P   |   P   |\nIf WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled\nto zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies\nMaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler\nwon't make it *more* imbalanced.\nIt's a required field.";
            type = types.str;
          };
        };

        config = {
          "labelSelector" = mkOverride 1002 null;
          "matchLabelKeys" = mkOverride 1002 null;
          "minDomains" = mkOverride 1002 null;
          "nodeAffinityPolicy" = mkOverride 1002 null;
          "nodeTaintsPolicy" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes" = {

      options = {
        "awsElasticBlockStore" = mkOption {
          description = "awsElasticBlockStore represents an AWS Disk resource that is attached to a\nkubelet's host machine and then exposed to the pod.\nDeprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree\nawsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore"
            )
          );
        };
        "azureDisk" = mkOption {
          description = "azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.\nDeprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type\nare redirected to the disk.csi.azure.com CSI driver.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk"
            )
          );
        };
        "azureFile" = mkOption {
          description = "azureFile represents an Azure File Service mount on the host and bind mount to the pod.\nDeprecated: AzureFile is deprecated. All operations for the in-tree azureFile type\nare redirected to the file.csi.azure.com CSI driver.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile"
            )
          );
        };
        "cephfs" = mkOption {
          description = "cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.\nDeprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs"
            )
          );
        };
        "cinder" = mkOption {
          description = "cinder represents a cinder volume attached and mounted on kubelets host machine.\nDeprecated: Cinder is deprecated. All operations for the in-tree cinder type\nare redirected to the cinder.csi.openstack.org CSI driver.\nMore info: https://examples.k8s.io/mysql-cinder-pd/README.md";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder"
            )
          );
        };
        "configMap" = mkOption {
          description = "configMap represents a configMap that should populate this volume";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap"
            )
          );
        };
        "csi" = mkOption {
          description = "csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi"
            )
          );
        };
        "downwardAPI" = mkOption {
          description = "downwardAPI represents downward API about the pod that should populate this volume";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPI"
            )
          );
        };
        "emptyDir" = mkOption {
          description = "emptyDir represents a temporary directory that shares a pod's lifetime.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDir"
            )
          );
        };
        "ephemeral" = mkOption {
          description = "ephemeral represents a volume that is handled by a cluster storage driver.\nThe volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,\nand deleted when the pod is removed.\n\nUse this if:\na) the volume is only needed while the pod runs,\nb) features of normal volumes like restoring from snapshot or capacity\n   tracking are needed,\nc) the storage driver is specified through a storage class, and\nd) the storage driver supports dynamic volume provisioning through\n   a PersistentVolumeClaim (see EphemeralVolumeSource for more\n   information on the connection between this volume type\n   and PersistentVolumeClaim).\n\nUse PersistentVolumeClaim or one of the vendor-specific\nAPIs for volumes that persist for longer than the lifecycle\nof an individual pod.\n\nUse CSI for light-weight local ephemeral volumes if the CSI driver is meant to\nbe used that way - see the documentation of the driver for\nmore information.\n\nA pod can use both types of ephemeral volumes and\npersistent volumes at the same time.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeral"
            )
          );
        };
        "fc" = mkOption {
          description = "fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc"
            )
          );
        };
        "flexVolume" = mkOption {
          description = "flexVolume represents a generic volume resource that is\nprovisioned/attached using an exec based plugin.\nDeprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume"
            )
          );
        };
        "flocker" = mkOption {
          description = "flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.\nDeprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlocker"
            )
          );
        };
        "gcePersistentDisk" = mkOption {
          description = "gcePersistentDisk represents a GCE Disk resource that is attached to a\nkubelet's host machine and then exposed to the pod.\nDeprecated: GCEPersistentDisk is deprecated. All operations for the in-tree\ngcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk"
            )
          );
        };
        "gitRepo" = mkOption {
          description = "gitRepo represents a git repository at a particular revision.\nDeprecated: GitRepo is deprecated. To provision a container with a git repo, mount an\nEmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir\ninto the Pod's container.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo"
            )
          );
        };
        "glusterfs" = mkOption {
          description = "glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.\nDeprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs"
            )
          );
        };
        "hostPath" = mkOption {
          description = "hostPath represents a pre-existing file or directory on the host\nmachine that is directly exposed to the container. This is generally\nused for system agents or other privileged things that are allowed\nto see the host machine. Most containers will NOT need this.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesHostPath"
            )
          );
        };
        "image" = mkOption {
          description = "image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.\nThe volume is resolved at pod startup depending on which PullPolicy value is provided:\n\n- Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.\n- Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.\n- IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\n\nThe volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.\nA failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.\nThe types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.\nThe OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.\nThe volume will be mounted read-only (ro) and non-executable files (noexec).\nSub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.\nThe field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesImage"
            )
          );
        };
        "iscsi" = mkOption {
          description = "iscsi represents an ISCSI Disk resource that is attached to a\nkubelet's host machine and then exposed to the pod.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes/#iscsi";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi"
            )
          );
        };
        "name" = mkOption {
          description = "name of the volume.\nMust be a DNS_LABEL and unique within the pod.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = types.str;
        };
        "nfs" = mkOption {
          description = "nfs represents an NFS mount on the host that shares a pod's lifetime\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#nfs";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs"
            )
          );
        };
        "persistentVolumeClaim" = mkOption {
          description = "persistentVolumeClaimVolumeSource represents a reference to a\nPersistentVolumeClaim in the same namespace.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPersistentVolumeClaim"
            )
          );
        };
        "photonPersistentDisk" = mkOption {
          description = "photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.\nDeprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPhotonPersistentDisk"
            )
          );
        };
        "portworxVolume" = mkOption {
          description = "portworxVolume represents a portworx volume attached and mounted on kubelets host machine.\nDeprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type\nare redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate\nis on.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume"
            )
          );
        };
        "projected" = mkOption {
          description = "projected items for all in one resources secrets, configmaps, and downward API";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjected"
            )
          );
        };
        "quobyte" = mkOption {
          description = "quobyte represents a Quobyte mount on the host that shares a pod's lifetime.\nDeprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte"
            )
          );
        };
        "rbd" = mkOption {
          description = "rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.\nDeprecated: RBD is deprecated and the in-tree rbd type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd"
            )
          );
        };
        "scaleIO" = mkOption {
          description = "scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.\nDeprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIO"
            )
          );
        };
        "secret" = mkOption {
          description = "secret represents a secret that should populate this volume.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#secret";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret"
            )
          );
        };
        "storageos" = mkOption {
          description = "storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.\nDeprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos"
            )
          );
        };
        "vsphereVolume" = mkOption {
          description = "vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.\nDeprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type\nare redirected to the csi.vsphere.vmware.com CSI driver.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume"
            )
          );
        };
      };

      config = {
        "awsElasticBlockStore" = mkOverride 1002 null;
        "azureDisk" = mkOverride 1002 null;
        "azureFile" = mkOverride 1002 null;
        "cephfs" = mkOverride 1002 null;
        "cinder" = mkOverride 1002 null;
        "configMap" = mkOverride 1002 null;
        "csi" = mkOverride 1002 null;
        "downwardAPI" = mkOverride 1002 null;
        "emptyDir" = mkOverride 1002 null;
        "ephemeral" = mkOverride 1002 null;
        "fc" = mkOverride 1002 null;
        "flexVolume" = mkOverride 1002 null;
        "flocker" = mkOverride 1002 null;
        "gcePersistentDisk" = mkOverride 1002 null;
        "gitRepo" = mkOverride 1002 null;
        "glusterfs" = mkOverride 1002 null;
        "hostPath" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "iscsi" = mkOverride 1002 null;
        "nfs" = mkOverride 1002 null;
        "persistentVolumeClaim" = mkOverride 1002 null;
        "photonPersistentDisk" = mkOverride 1002 null;
        "portworxVolume" = mkOverride 1002 null;
        "projected" = mkOverride 1002 null;
        "quobyte" = mkOverride 1002 null;
        "rbd" = mkOverride 1002 null;
        "scaleIO" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
        "storageos" = mkOverride 1002 null;
        "vsphereVolume" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore" =
      {

        options = {
          "fsType" = mkOption {
            description = "fsType is the filesystem type of the volume that you want to mount.\nTip: Ensure that the filesystem type is supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore";
            type = (types.nullOr types.str);
          };
          "partition" = mkOption {
            description = "partition is the partition in the volume that you want to mount.\nIf omitted, the default is to mount by volume name.\nExamples: For volume /dev/sda1, you specify the partition as \"1\".\nSimilarly, the volume partition for /dev/sda is \"0\" (or you can leave the property empty).";
            type = (types.nullOr types.int);
          };
          "readOnly" = mkOption {
            description = "readOnly value true will force the readOnly setting in VolumeMounts.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore";
            type = (types.nullOr types.bool);
          };
          "volumeID" = mkOption {
            description = "volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore";
            type = types.str;
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
          "partition" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk" =
      {

        options = {
          "cachingMode" = mkOption {
            description = "cachingMode is the Host Caching mode: None, Read Only, Read Write.";
            type = (types.nullOr types.str);
          };
          "diskName" = mkOption {
            description = "diskName is the Name of the data disk in the blob storage";
            type = types.str;
          };
          "diskURI" = mkOption {
            description = "diskURI is the URI of data disk in the blob storage";
            type = types.str;
          };
          "fsType" = mkOption {
            description = "fsType is Filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared";
            type = (types.nullOr types.str);
          };
          "readOnly" = mkOption {
            description = "readOnly Defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "cachingMode" = mkOverride 1002 null;
          "fsType" = mkOverride 1002 null;
          "kind" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile" =
      {

        options = {
          "readOnly" = mkOption {
            description = "readOnly defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
            type = (types.nullOr types.bool);
          };
          "secretName" = mkOption {
            description = "secretName is the  name of secret that contains Azure Storage Account Name and Key";
            type = types.str;
          };
          "shareName" = mkOption {
            description = "shareName is the azure share Name";
            type = types.str;
          };
        };

        config = {
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs" = {

      options = {
        "monitors" = mkOption {
          description = "monitors is Required: Monitors is a collection of Ceph monitors\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it";
          type = (types.listOf types.str);
        };
        "path" = mkOption {
          description = "path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /";
          type = (types.nullOr types.str);
        };
        "readOnly" = mkOption {
          description = "readOnly is Optional: Defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it";
          type = (types.nullOr types.bool);
        };
        "secretFile" = mkOption {
          description = "secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfsSecretRef"
            )
          );
        };
        "user" = mkOption {
          description = "user is optional: User is the rados user name, default is admin\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "path" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "secretFile" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
        "user" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfsSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder" = {

      options = {
        "fsType" = mkOption {
          description = "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://examples.k8s.io/mysql-cinder-pd/README.md";
          type = (types.nullOr types.str);
        };
        "readOnly" = mkOption {
          description = "readOnly defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.\nMore info: https://examples.k8s.io/mysql-cinder-pd/README.md";
          type = (types.nullOr types.bool);
        };
        "secretRef" = mkOption {
          description = "secretRef is optional: points to a secret object containing parameters used to connect\nto OpenStack.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinderSecretRef"
            )
          );
        };
        "volumeID" = mkOption {
          description = "volumeID used to identify the volume in cinder.\nMore info: https://examples.k8s.io/mysql-cinder-pd/README.md";
          type = types.str;
        };
      };

      config = {
        "fsType" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinderSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap" =
      {

        options = {
          "defaultMode" = mkOption {
            description = "defaultMode is optional: mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nDefaults to 0644.\nDirectories within the path are not affected by this setting.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "items" = mkOption {
            description = "items if unspecified, each key-value pair in the Data field of the referenced\nConfigMap will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the ConfigMap,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems"
                )
              )
            );
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "optional specify whether the ConfigMap or its keys must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "defaultMode" = mkOverride 1002 null;
          "items" = mkOverride 1002 null;
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems" =
      {

        options = {
          "key" = mkOption {
            description = "key is the key to project.";
            type = types.str;
          };
          "mode" = mkOption {
            description = "mode is Optional: mode bits used to set permissions on this file.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "path is the relative path of the file to map the key to.\nMay not be an absolute path.\nMay not contain the path element '..'.\nMay not start with the string '..'.";
            type = types.str;
          };
        };

        config = {
          "mode" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi" = {

      options = {
        "driver" = mkOption {
          description = "driver is the name of the CSI driver that handles this volume.\nConsult with your admin for the correct name as registered in the cluster.";
          type = types.str;
        };
        "fsType" = mkOption {
          description = "fsType to mount. Ex. \"ext4\", \"xfs\", \"ntfs\".\nIf not provided, the empty value is passed to the associated CSI driver\nwhich will determine the default filesystem to apply.";
          type = (types.nullOr types.str);
        };
        "nodePublishSecretRef" = mkOption {
          description = "nodePublishSecretRef is a reference to the secret object containing\nsensitive information to pass to the CSI driver to complete the CSI\nNodePublishVolume and NodeUnpublishVolume calls.\nThis field is optional, and  may be empty if no secret is required. If the\nsecret object contains more than one secret, all secret references are passed.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsiNodePublishSecretRef"
            )
          );
        };
        "readOnly" = mkOption {
          description = "readOnly specifies a read-only configuration for the volume.\nDefaults to false (read/write).";
          type = (types.nullOr types.bool);
        };
        "volumeAttributes" = mkOption {
          description = "volumeAttributes stores driver-specific properties that are passed to the CSI\ndriver. Consult your driver's documentation for supported values.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "fsType" = mkOverride 1002 null;
        "nodePublishSecretRef" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "volumeAttributes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsiNodePublishSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPI" =
      {

        options = {
          "defaultMode" = mkOption {
            description = "Optional: mode bits to use on created files by default. Must be a\nOptional: mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nDefaults to 0644.\nDirectories within the path are not affected by this setting.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "items" = mkOption {
            description = "Items is a list of downward API volume file";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPIItems"
                )
              )
            );
          };
        };

        config = {
          "defaultMode" = mkOverride 1002 null;
          "items" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPIItems" =
      {

        options = {
          "fieldRef" = mkOption {
            description = "Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPIItemsFieldRef"
              )
            );
          };
          "mode" = mkOption {
            description = "Optional: mode bits used to set permissions on this file, must be an octal value\nbetween 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'";
            type = types.str;
          };
          "resourceFieldRef" = mkOption {
            description = "Selects a resource of the container: only resources limits and requests\n(limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPIItemsResourceFieldRef"
              )
            );
          };
        };

        config = {
          "fieldRef" = mkOverride 1002 null;
          "mode" = mkOverride 1002 null;
          "resourceFieldRef" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPIItemsFieldRef" =
      {

        options = {
          "apiVersion" = mkOption {
            description = "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".";
            type = (types.nullOr types.str);
          };
          "fieldPath" = mkOption {
            description = "Path of the field to select in the specified API version.";
            type = types.str;
          };
        };

        config = {
          "apiVersion" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPIItemsResourceFieldRef" =
      {

        options = {
          "containerName" = mkOption {
            description = "Container name: required for volumes, optional for env vars";
            type = (types.nullOr types.str);
          };
          "divisor" = mkOption {
            description = "Specifies the output format of the exposed resources, defaults to \"1\"";
            type = (types.nullOr (types.either types.int types.str));
          };
          "resource" = mkOption {
            description = "Required: resource to select";
            type = types.str;
          };
        };

        config = {
          "containerName" = mkOverride 1002 null;
          "divisor" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDir" =
      {

        options = {
          "medium" = mkOption {
            description = "medium represents what type of storage medium should back this directory.\nThe default is \"\" which means to use the node's default medium.\nMust be an empty string (default) or Memory.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
            type = (types.nullOr types.str);
          };
          "sizeLimit" = mkOption {
            description = "sizeLimit is the total amount of local storage required for this EmptyDir volume.\nThe size limit is also applicable for memory medium.\nThe maximum usage on memory medium EmptyDir would be the minimum value between\nthe SizeLimit specified here and the sum of memory limits of all containers in a pod.\nThe default is nil which means that the limit is undefined.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
            type = (types.nullOr (types.either types.int types.str));
          };
        };

        config = {
          "medium" = mkOverride 1002 null;
          "sizeLimit" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeral" =
      {

        options = {
          "volumeClaimTemplate" = mkOption {
            description = "Will be used to create a stand-alone PVC to provision the volume.\nThe pod in which this EphemeralVolumeSource is embedded will be the\nowner of the PVC, i.e. the PVC will be deleted together with the\npod.  The name of the PVC will be `<pod name>-<volume name>` where\n`<volume name>` is the name from the `PodSpec.Volumes` array\nentry. Pod validation will reject the pod if the concatenated name\nis not valid for a PVC (for example, too long).\n\nAn existing PVC with that name that is not owned by the pod\nwill *not* be used for the pod to avoid using an unrelated\nvolume by mistake. Starting the pod is then blocked until\nthe unrelated PVC is removed. If such a pre-created PVC is\nmeant to be used by the pod, the PVC has to updated with an\nowner reference to the pod once the pod exists. Normally\nthis should not be necessary, but it may be useful when\nmanually reconstructing a broken cluster.\n\nThis field is read-only and no changes will be made by Kubernetes\nto the PVC after it has been created.\n\nRequired, must not be nil.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplate"
              )
            );
          };
        };

        config = {
          "volumeClaimTemplate" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplate" =
      {

        options = {
          "metadata" = mkOption {
            description = "May contain labels and annotations that will be copied into the PVC\nwhen creating it. No other fields are allowed and will be rejected during\nvalidation.";
            type = (types.nullOr types.attrs);
          };
          "spec" = mkOption {
            description = "The specification for the PersistentVolumeClaim. The entire content is\ncopied unchanged into the PVC that gets created from this\ntemplate. The same fields as in a PersistentVolumeClaim\nare also valid here.";
            type = (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec"
            );
          };
        };

        config = {
          "metadata" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec" =
      {

        options = {
          "accessModes" = mkOption {
            description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
            type = (types.nullOr (types.listOf types.str));
          };
          "dataSource" = mkOption {
            description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource"
              )
            );
          };
          "dataSourceRef" = mkOption {
            description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef"
              )
            );
          };
          "resources" = mkOption {
            description = "resources represents the minimum resources the volume should have.\nUsers are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResources"
              )
            );
          };
          "selector" = mkOption {
            description = "selector is a label query over volumes to consider for binding.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelector"
              )
            );
          };
          "storageClassName" = mkOption {
            description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
            type = (types.nullOr types.str);
          };
          "volumeAttributesClassName" = mkOption {
            description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
            type = (types.nullOr types.str);
          };
          "volumeMode" = mkOption {
            description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
            type = (types.nullOr types.str);
          };
          "volumeName" = mkOption {
            description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "accessModes" = mkOverride 1002 null;
          "dataSource" = mkOverride 1002 null;
          "dataSourceRef" = mkOverride 1002 null;
          "resources" = mkOverride 1002 null;
          "selector" = mkOverride 1002 null;
          "storageClassName" = mkOverride 1002 null;
          "volumeAttributesClassName" = mkOverride 1002 null;
          "volumeMode" = mkOverride 1002 null;
          "volumeName" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource" =
      {

        options = {
          "apiGroup" = mkOption {
            description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "Kind is the type of resource being referenced";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name is the name of resource being referenced";
            type = types.str;
          };
        };

        config = {
          "apiGroup" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef" =
      {

        options = {
          "apiGroup" = mkOption {
            description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "Kind is the type of resource being referenced";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name is the name of resource being referenced";
            type = types.str;
          };
          "namespace" = mkOption {
            description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "apiGroup" = mkOverride 1002 null;
          "namespace" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResources" =
      {

        options = {
          "limits" = mkOption {
            description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
          "requests" = mkOption {
            description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
        };

        config = {
          "limits" = mkOverride 1002 null;
          "requests" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc" = {

      options = {
        "fsType" = mkOption {
          description = "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.";
          type = (types.nullOr types.str);
        };
        "lun" = mkOption {
          description = "lun is Optional: FC target lun number";
          type = (types.nullOr types.int);
        };
        "readOnly" = mkOption {
          description = "readOnly is Optional: Defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
          type = (types.nullOr types.bool);
        };
        "targetWWNs" = mkOption {
          description = "targetWWNs is Optional: FC target worldwide names (WWNs)";
          type = (types.nullOr (types.listOf types.str));
        };
        "wwids" = mkOption {
          description = "wwids Optional: FC volume world wide identifiers (wwids)\nEither wwids or combination of targetWWNs and lun must be set, but not both simultaneously.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "fsType" = mkOverride 1002 null;
        "lun" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "targetWWNs" = mkOverride 1002 null;
        "wwids" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume" =
      {

        options = {
          "driver" = mkOption {
            description = "driver is the name of the driver to use for this volume.";
            type = types.str;
          };
          "fsType" = mkOption {
            description = "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends on FlexVolume script.";
            type = (types.nullOr types.str);
          };
          "options" = mkOption {
            description = "options is Optional: this field holds extra command options if any.";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "readOnly" = mkOption {
            description = "readOnly is Optional: defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
            type = (types.nullOr types.bool);
          };
          "secretRef" = mkOption {
            description = "secretRef is Optional: secretRef is reference to the secret object containing\nsensitive information to pass to the plugin scripts. This may be\nempty if no secret object is specified. If the secret object\ncontains more than one secret, all secrets are passed to the plugin\nscripts.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolumeSecretRef"
              )
            );
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
          "options" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
          "secretRef" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolumeSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlocker" =
      {

        options = {
          "datasetName" = mkOption {
            description = "datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker\nshould be considered as deprecated";
            type = (types.nullOr types.str);
          };
          "datasetUUID" = mkOption {
            description = "datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "datasetName" = mkOverride 1002 null;
          "datasetUUID" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk" =
      {

        options = {
          "fsType" = mkOption {
            description = "fsType is filesystem type of the volume that you want to mount.\nTip: Ensure that the filesystem type is supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk";
            type = (types.nullOr types.str);
          };
          "partition" = mkOption {
            description = "partition is the partition in the volume that you want to mount.\nIf omitted, the default is to mount by volume name.\nExamples: For volume /dev/sda1, you specify the partition as \"1\".\nSimilarly, the volume partition for /dev/sda is \"0\" (or you can leave the property empty).\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk";
            type = (types.nullOr types.int);
          };
          "pdName" = mkOption {
            description = "pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk";
            type = types.str;
          };
          "readOnly" = mkOption {
            description = "readOnly here will force the ReadOnly setting in VolumeMounts.\nDefaults to false.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
          "partition" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo" =
      {

        options = {
          "directory" = mkOption {
            description = "directory is the target directory name.\nMust not contain or start with '..'.  If '.' is supplied, the volume directory will be the\ngit repository.  Otherwise, if specified, the volume will contain the git repository in\nthe subdirectory with the given name.";
            type = (types.nullOr types.str);
          };
          "repository" = mkOption {
            description = "repository is the URL";
            type = types.str;
          };
          "revision" = mkOption {
            description = "revision is the commit hash for the specified revision.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "directory" = mkOverride 1002 null;
          "revision" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs" =
      {

        options = {
          "endpoints" = mkOption {
            description = "endpoints is the endpoint name that details Glusterfs topology.";
            type = types.str;
          };
          "path" = mkOption {
            description = "path is the Glusterfs volume path.\nMore info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod";
            type = types.str;
          };
          "readOnly" = mkOption {
            description = "readOnly here will force the Glusterfs volume to be mounted with read-only permissions.\nDefaults to false.\nMore info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesHostPath" =
      {

        options = {
          "path" = mkOption {
            description = "path of the directory on the host.\nIf the path is a symlink, it will follow the link to the real path.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath";
            type = types.str;
          };
          "type" = mkOption {
            description = "type for HostPath Volume\nDefaults to \"\"\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "type" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "Policy for pulling OCI objects. Possible values are:\nAlways: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.\nNever: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.\nIfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\nDefaults to Always if :latest tag is specified, or IfNotPresent otherwise.";
          type = (types.nullOr types.str);
        };
        "reference" = mkOption {
          description = "Required: Image or artifact reference to be used.\nBehaves in the same way as pod.spec.containers[*].image.\nPull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.\nMore info: https://kubernetes.io/docs/concepts/containers/images\nThis field is optional to allow higher level config management to default or override\ncontainer images in workload controllers like Deployments and StatefulSets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "reference" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi" = {

      options = {
        "chapAuthDiscovery" = mkOption {
          description = "chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication";
          type = (types.nullOr types.bool);
        };
        "chapAuthSession" = mkOption {
          description = "chapAuthSession defines whether support iSCSI Session CHAP authentication";
          type = (types.nullOr types.bool);
        };
        "fsType" = mkOption {
          description = "fsType is the filesystem type of the volume that you want to mount.\nTip: Ensure that the filesystem type is supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi";
          type = (types.nullOr types.str);
        };
        "initiatorName" = mkOption {
          description = "initiatorName is the custom iSCSI Initiator Name.\nIf initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface\n<target portal>:<volume name> will be created for the connection.";
          type = (types.nullOr types.str);
        };
        "iqn" = mkOption {
          description = "iqn is the target iSCSI Qualified Name.";
          type = types.str;
        };
        "iscsiInterface" = mkOption {
          description = "iscsiInterface is the interface Name that uses an iSCSI transport.\nDefaults to 'default' (tcp).";
          type = (types.nullOr types.str);
        };
        "lun" = mkOption {
          description = "lun represents iSCSI Target Lun number.";
          type = types.int;
        };
        "portals" = mkOption {
          description = "portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port\nis other than default (typically TCP ports 860 and 3260).";
          type = (types.nullOr (types.listOf types.str));
        };
        "readOnly" = mkOption {
          description = "readOnly here will force the ReadOnly setting in VolumeMounts.\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "secretRef" = mkOption {
          description = "secretRef is the CHAP Secret for iSCSI target and initiator authentication";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsiSecretRef"
            )
          );
        };
        "targetPortal" = mkOption {
          description = "targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port\nis other than default (typically TCP ports 860 and 3260).";
          type = types.str;
        };
      };

      config = {
        "chapAuthDiscovery" = mkOverride 1002 null;
        "chapAuthSession" = mkOverride 1002 null;
        "fsType" = mkOverride 1002 null;
        "initiatorName" = mkOverride 1002 null;
        "iscsiInterface" = mkOverride 1002 null;
        "portals" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsiSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs" = {

      options = {
        "path" = mkOption {
          description = "path that is exported by the NFS server.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#nfs";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "readOnly here will force the NFS export to be mounted with read-only permissions.\nDefaults to false.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#nfs";
          type = (types.nullOr types.bool);
        };
        "server" = mkOption {
          description = "server is the hostname or IP address of the NFS server.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#nfs";
          type = types.str;
        };
      };

      config = {
        "readOnly" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPersistentVolumeClaim" =
      {

        options = {
          "claimName" = mkOption {
            description = "claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
            type = types.str;
          };
          "readOnly" = mkOption {
            description = "readOnly Will force the ReadOnly setting in VolumeMounts.\nDefault false.";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPhotonPersistentDisk" =
      {

        options = {
          "fsType" = mkOption {
            description = "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.";
            type = (types.nullOr types.str);
          };
          "pdID" = mkOption {
            description = "pdID is the ID that identifies Photon Controller persistent disk";
            type = types.str;
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume" =
      {

        options = {
          "fsType" = mkOption {
            description = "fSType represents the filesystem type to mount\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\". Implicitly inferred to be \"ext4\" if unspecified.";
            type = (types.nullOr types.str);
          };
          "readOnly" = mkOption {
            description = "readOnly defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
            type = (types.nullOr types.bool);
          };
          "volumeID" = mkOption {
            description = "volumeID uniquely identifies a Portworx volume";
            type = types.str;
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjected" =
      {

        options = {
          "defaultMode" = mkOption {
            description = "defaultMode are the mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nDirectories within the path are not affected by this setting.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "sources" = mkOption {
            description = "sources is the list of volume projections. Each entry in this list\nhandles one source.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources"
                )
              )
            );
          };
        };

        config = {
          "defaultMode" = mkOverride 1002 null;
          "sources" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources" =
      {

        options = {
          "clusterTrustBundle" = mkOption {
            description = "ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field\nof ClusterTrustBundle objects in an auto-updating file.\n\nAlpha, gated by the ClusterTrustBundleProjection feature gate.\n\nClusterTrustBundle objects can either be selected by name, or by the\ncombination of signer name and a label selector.\n\nKubelet performs aggressive normalization of the PEM contents written\ninto the pod filesystem.  Esoteric PEM features such as inter-block\ncomments and block headers are stripped.  Certificates are deduplicated.\nThe ordering of certificates within the file is arbitrary, and Kubelet\nmay change the order over time.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle"
              )
            );
          };
          "configMap" = mkOption {
            description = "configMap information about the configMap data to project";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap"
              )
            );
          };
          "downwardAPI" = mkOption {
            description = "downwardAPI information about the downwardAPI data to project";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPI"
              )
            );
          };
          "podCertificate" = mkOption {
            description = "Projects an auto-rotating credential bundle (private key and certificate\nchain) that the pod can use either as a TLS client or server.\n\nKubelet generates a private key and uses it to send a\nPodCertificateRequest to the named signer.  Once the signer approves the\nrequest and issues a certificate chain, Kubelet writes the key and\ncertificate chain to the pod filesystem.  The pod does not start until\ncertificates have been issued for each podCertificate projected volume\nsource in its spec.\n\nKubelet will begin trying to rotate the certificate at the time indicated\nby the signer using the PodCertificateRequest.Status.BeginRefreshAt\ntimestamp.\n\nKubelet can write a single file, indicated by the credentialBundlePath\nfield, or separate files, indicated by the keyPath and\ncertificateChainPath fields.\n\nThe credential bundle is a single file in PEM format.  The first PEM\nentry is the private key (in PKCS#8 format), and the remaining PEM\nentries are the certificate chain issued by the signer (typically,\nsigners will return their certificate chain in leaf-to-root order).\n\nPrefer using the credential bundle format, since your application code\ncan read it atomically.  If you use keyPath and certificateChainPath,\nyour application must make two separate file reads. If these coincide\nwith a certificate rotation, it is possible that the private key and leaf\ncertificate you read may not correspond to each other.  Your application\nwill need to check for this condition, and re-read until they are\nconsistent.\n\nThe named signer controls chooses the format of the certificate it\nissues; consult the signer implementation's documentation to learn how to\nuse the certificates it issues.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate"
              )
            );
          };
          "secret" = mkOption {
            description = "secret information about the secret data to project";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret"
              )
            );
          };
          "serviceAccountToken" = mkOption {
            description = "serviceAccountToken is information about the serviceAccountToken data to project";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken"
              )
            );
          };
        };

        config = {
          "clusterTrustBundle" = mkOverride 1002 null;
          "configMap" = mkOverride 1002 null;
          "downwardAPI" = mkOverride 1002 null;
          "podCertificate" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
          "serviceAccountToken" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle" =
      {

        options = {
          "labelSelector" = mkOption {
            description = "Select all ClusterTrustBundles that match this label selector.  Only has\neffect if signerName is set.  Mutually-exclusive with name.  If unset,\ninterpreted as \"match nothing\".  If set but empty, interpreted as \"match\neverything\".";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelector"
              )
            );
          };
          "name" = mkOption {
            description = "Select a single ClusterTrustBundle by object name.  Mutually-exclusive\nwith signerName and labelSelector.";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "If true, don't block pod startup if the referenced ClusterTrustBundle(s)\naren't available.  If using name, then the named ClusterTrustBundle is\nallowed not to exist.  If using signerName, then the combination of\nsignerName and labelSelector is allowed to match zero\nClusterTrustBundles.";
            type = (types.nullOr types.bool);
          };
          "path" = mkOption {
            description = "Relative path from the volume root to write the bundle.";
            type = types.str;
          };
          "signerName" = mkOption {
            description = "Select all ClusterTrustBundles that match this signer name.\nMutually-exclusive with name.  The contents of all selected\nClusterTrustBundles will be unified and deduplicated.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "labelSelector" = mkOverride 1002 null;
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
          "signerName" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap" =
      {

        options = {
          "items" = mkOption {
            description = "items if unspecified, each key-value pair in the Data field of the referenced\nConfigMap will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the ConfigMap,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems"
                )
              )
            );
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "optional specify whether the ConfigMap or its keys must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "items" = mkOverride 1002 null;
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems" =
      {

        options = {
          "key" = mkOption {
            description = "key is the key to project.";
            type = types.str;
          };
          "mode" = mkOption {
            description = "mode is Optional: mode bits used to set permissions on this file.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "path is the relative path of the file to map the key to.\nMay not be an absolute path.\nMay not contain the path element '..'.\nMay not start with the string '..'.";
            type = types.str;
          };
        };

        config = {
          "mode" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPI" =
      {

        options = {
          "items" = mkOption {
            description = "Items is a list of DownwardAPIVolume file";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPIItems"
                )
              )
            );
          };
        };

        config = {
          "items" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPIItems" =
      {

        options = {
          "fieldRef" = mkOption {
            description = "Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPIItemsFieldRef"
              )
            );
          };
          "mode" = mkOption {
            description = "Optional: mode bits used to set permissions on this file, must be an octal value\nbetween 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'";
            type = types.str;
          };
          "resourceFieldRef" = mkOption {
            description = "Selects a resource of the container: only resources limits and requests\n(limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef"
              )
            );
          };
        };

        config = {
          "fieldRef" = mkOverride 1002 null;
          "mode" = mkOverride 1002 null;
          "resourceFieldRef" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPIItemsFieldRef" =
      {

        options = {
          "apiVersion" = mkOption {
            description = "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".";
            type = (types.nullOr types.str);
          };
          "fieldPath" = mkOption {
            description = "Path of the field to select in the specified API version.";
            type = types.str;
          };
        };

        config = {
          "apiVersion" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef" =
      {

        options = {
          "containerName" = mkOption {
            description = "Container name: required for volumes, optional for env vars";
            type = (types.nullOr types.str);
          };
          "divisor" = mkOption {
            description = "Specifies the output format of the exposed resources, defaults to \"1\"";
            type = (types.nullOr (types.either types.int types.str));
          };
          "resource" = mkOption {
            description = "Required: resource to select";
            type = types.str;
          };
        };

        config = {
          "containerName" = mkOverride 1002 null;
          "divisor" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate" =
      {

        options = {
          "certificateChainPath" = mkOption {
            description = "Write the certificate chain at this path in the projected volume.\n\nMost applications should use credentialBundlePath.  When using keyPath\nand certificateChainPath, your application needs to check that the key\nand leaf certificate are consistent, because it is possible to read the\nfiles mid-rotation.";
            type = (types.nullOr types.str);
          };
          "credentialBundlePath" = mkOption {
            description = "Write the credential bundle at this path in the projected volume.\n\nThe credential bundle is a single file that contains multiple PEM blocks.\nThe first PEM block is a PRIVATE KEY block, containing a PKCS#8 private\nkey.\n\nThe remaining blocks are CERTIFICATE blocks, containing the issued\ncertificate chain from the signer (leaf and any intermediates).\n\nUsing credentialBundlePath lets your Pod's application code make a single\natomic read that retrieves a consistent key and certificate chain.  If you\nproject them to separate files, your application code will need to\nadditionally check that the leaf certificate was issued to the key.";
            type = (types.nullOr types.str);
          };
          "keyPath" = mkOption {
            description = "Write the key at this path in the projected volume.\n\nMost applications should use credentialBundlePath.  When using keyPath\nand certificateChainPath, your application needs to check that the key\nand leaf certificate are consistent, because it is possible to read the\nfiles mid-rotation.";
            type = (types.nullOr types.str);
          };
          "keyType" = mkOption {
            description = "The type of keypair Kubelet will generate for the pod.\n\nValid values are \"RSA3072\", \"RSA4096\", \"ECDSAP256\", \"ECDSAP384\",\n\"ECDSAP521\", and \"ED25519\".";
            type = types.str;
          };
          "maxExpirationSeconds" = mkOption {
            description = "maxExpirationSeconds is the maximum lifetime permitted for the\ncertificate.\n\nKubelet copies this value verbatim into the PodCertificateRequests it\ngenerates for this projection.\n\nIf omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver\nwill reject values shorter than 3600 (1 hour).  The maximum allowable\nvalue is 7862400 (91 days).\n\nThe signer implementation is then free to issue a certificate with any\nlifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600\nseconds (1 hour).  This constraint is enforced by kube-apiserver.\n`kubernetes.io` signers will never issue certificates with a lifetime\nlonger than 24 hours.";
            type = (types.nullOr types.int);
          };
          "signerName" = mkOption {
            description = "Kubelet's generated CSRs will be addressed to this signer.";
            type = types.str;
          };
          "userAnnotations" = mkOption {
            description = "userAnnotations allow pod authors to pass additional information to\nthe signer implementation.  Kubernetes does not restrict or validate this\nmetadata in any way.\n\nThese values are copied verbatim into the `spec.unverifiedUserAnnotations` field of\nthe PodCertificateRequest objects that Kubelet creates.\n\nEntries are subject to the same validation as object metadata annotations,\nwith the addition that all keys must be domain-prefixed. No restrictions\nare placed on values, except an overall size limitation on the entire field.\n\nSigners should document the keys and values they support. Signers should\ndeny requests that contain keys they do not recognize.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "certificateChainPath" = mkOverride 1002 null;
          "credentialBundlePath" = mkOverride 1002 null;
          "keyPath" = mkOverride 1002 null;
          "maxExpirationSeconds" = mkOverride 1002 null;
          "userAnnotations" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret" =
      {

        options = {
          "items" = mkOption {
            description = "items if unspecified, each key-value pair in the Data field of the referenced\nSecret will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the Secret,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems"
                )
              )
            );
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "optional field specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "items" = mkOverride 1002 null;
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems" =
      {

        options = {
          "key" = mkOption {
            description = "key is the key to project.";
            type = types.str;
          };
          "mode" = mkOption {
            description = "mode is Optional: mode bits used to set permissions on this file.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "path is the relative path of the file to map the key to.\nMay not be an absolute path.\nMay not contain the path element '..'.\nMay not start with the string '..'.";
            type = types.str;
          };
        };

        config = {
          "mode" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken" =
      {

        options = {
          "audience" = mkOption {
            description = "audience is the intended audience of the token. A recipient of a token\nmust identify itself with an identifier specified in the audience of the\ntoken, and otherwise should reject the token. The audience defaults to the\nidentifier of the apiserver.";
            type = (types.nullOr types.str);
          };
          "expirationSeconds" = mkOption {
            description = "expirationSeconds is the requested duration of validity of the service\naccount token. As the token approaches expiration, the kubelet volume\nplugin will proactively rotate the service account token. The kubelet will\nstart trying to rotate the token if the token is older than 80 percent of\nits time to live or if the token is older than 24 hours.Defaults to 1 hour\nand must be at least 10 minutes.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "path is the path relative to the mount point of the file to project the\ntoken into.";
            type = types.str;
          };
        };

        config = {
          "audience" = mkOverride 1002 null;
          "expirationSeconds" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte" =
      {

        options = {
          "group" = mkOption {
            description = "group to map volume access to\nDefault is no group";
            type = (types.nullOr types.str);
          };
          "readOnly" = mkOption {
            description = "readOnly here will force the Quobyte volume to be mounted with read-only permissions.\nDefaults to false.";
            type = (types.nullOr types.bool);
          };
          "registry" = mkOption {
            description = "registry represents a single or multiple Quobyte Registry services\nspecified as a string as host:port pair (multiple entries are separated with commas)\nwhich acts as the central registry for volumes";
            type = types.str;
          };
          "tenant" = mkOption {
            description = "tenant owning the given Quobyte volume in the Backend\nUsed with dynamically provisioned Quobyte volumes, value is set by the plugin";
            type = (types.nullOr types.str);
          };
          "user" = mkOption {
            description = "user to map volume access to\nDefaults to serivceaccount user";
            type = (types.nullOr types.str);
          };
          "volume" = mkOption {
            description = "volume is a string that references an already created Quobyte volume by name.";
            type = types.str;
          };
        };

        config = {
          "group" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
          "tenant" = mkOverride 1002 null;
          "user" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd" = {

      options = {
        "fsType" = mkOption {
          description = "fsType is the filesystem type of the volume that you want to mount.\nTip: Ensure that the filesystem type is supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#rbd";
          type = (types.nullOr types.str);
        };
        "image" = mkOption {
          description = "image is the rados image name.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = types.str;
        };
        "keyring" = mkOption {
          description = "keyring is the path to key ring for RBDUser.\nDefault is /etc/ceph/keyring.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = (types.nullOr types.str);
        };
        "monitors" = mkOption {
          description = "monitors is a collection of Ceph monitors.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = (types.listOf types.str);
        };
        "pool" = mkOption {
          description = "pool is the rados pool name.\nDefault is rbd.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = (types.nullOr types.str);
        };
        "readOnly" = mkOption {
          description = "readOnly here will force the ReadOnly setting in VolumeMounts.\nDefaults to false.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = (types.nullOr types.bool);
        };
        "secretRef" = mkOption {
          description = "secretRef is name of the authentication secret for RBDUser. If provided\noverrides keyring.\nDefault is nil.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbdSecretRef"
            )
          );
        };
        "user" = mkOption {
          description = "user is the rados user name.\nDefault is admin.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "fsType" = mkOverride 1002 null;
        "keyring" = mkOverride 1002 null;
        "pool" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
        "user" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbdSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIO" =
      {

        options = {
          "fsType" = mkOption {
            description = "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\".\nDefault is \"xfs\".";
            type = (types.nullOr types.str);
          };
          "gateway" = mkOption {
            description = "gateway is the host address of the ScaleIO API Gateway.";
            type = types.str;
          };
          "protectionDomain" = mkOption {
            description = "protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.";
            type = (types.nullOr types.str);
          };
          "readOnly" = mkOption {
            description = "readOnly Defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
            type = (types.nullOr types.bool);
          };
          "secretRef" = mkOption {
            description = "secretRef references to the secret for ScaleIO user and other\nsensitive information. If this is not provided, Login operation will fail.";
            type = (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIOSecretRef"
            );
          };
          "sslEnabled" = mkOption {
            description = "sslEnabled Flag enable/disable SSL communication with Gateway, default false";
            type = (types.nullOr types.bool);
          };
          "storageMode" = mkOption {
            description = "storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.\nDefault is ThinProvisioned.";
            type = (types.nullOr types.str);
          };
          "storagePool" = mkOption {
            description = "storagePool is the ScaleIO Storage Pool associated with the protection domain.";
            type = (types.nullOr types.str);
          };
          "system" = mkOption {
            description = "system is the name of the storage system as configured in ScaleIO.";
            type = types.str;
          };
          "volumeName" = mkOption {
            description = "volumeName is the name of a volume already created in the ScaleIO system\nthat is associated with this volume source.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
          "protectionDomain" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
          "sslEnabled" = mkOverride 1002 null;
          "storageMode" = mkOverride 1002 null;
          "storagePool" = mkOverride 1002 null;
          "volumeName" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIOSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret" = {

      options = {
        "defaultMode" = mkOption {
          description = "defaultMode is Optional: mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values\nfor mode bits. Defaults to 0644.\nDirectories within the path are not affected by this setting.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
          type = (types.nullOr types.int);
        };
        "items" = mkOption {
          description = "items If unspecified, each key-value pair in the Data field of the referenced\nSecret will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the Secret,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems"
              )
            )
          );
        };
        "optional" = mkOption {
          description = "optional field specify whether the Secret or its keys must be defined";
          type = (types.nullOr types.bool);
        };
        "secretName" = mkOption {
          description = "secretName is the name of the secret in the pod's namespace to use.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#secret";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "defaultMode" = mkOverride 1002 null;
        "items" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
        "secretName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems" =
      {

        options = {
          "key" = mkOption {
            description = "key is the key to project.";
            type = types.str;
          };
          "mode" = mkOption {
            description = "mode is Optional: mode bits used to set permissions on this file.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.";
            type = (types.nullOr types.int);
          };
          "path" = mkOption {
            description = "path is the relative path of the file to map the key to.\nMay not be an absolute path.\nMay not contain the path element '..'.\nMay not start with the string '..'.";
            type = types.str;
          };
        };

        config = {
          "mode" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos" =
      {

        options = {
          "fsType" = mkOption {
            description = "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.";
            type = (types.nullOr types.str);
          };
          "readOnly" = mkOption {
            description = "readOnly defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.";
            type = (types.nullOr types.bool);
          };
          "secretRef" = mkOption {
            description = "secretRef specifies the secret to use for obtaining the StorageOS API\ncredentials.  If not specified, default values will be attempted.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageosSecretRef"
              )
            );
          };
          "volumeName" = mkOption {
            description = "volumeName is the human-readable name of the StorageOS volume.  Volume\nnames are only unique within a namespace.";
            type = (types.nullOr types.str);
          };
          "volumeNamespace" = mkOption {
            description = "volumeNamespace specifies the scope of the volume within StorageOS.  If no\nnamespace is specified then the Pod's namespace will be used.  This allows the\nKubernetes name scoping to be mirrored within StorageOS for tighter integration.\nSet VolumeName to any name to override the default behaviour.\nSet to \"default\" if you are not using namespaces within StorageOS.\nNamespaces that do not pre-exist within StorageOS will be created.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
          "readOnly" = mkOverride 1002 null;
          "secretRef" = mkOverride 1002 null;
          "volumeName" = mkOverride 1002 null;
          "volumeNamespace" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageosSecretRef" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume" =
      {

        options = {
          "fsType" = mkOption {
            description = "fsType is filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.";
            type = (types.nullOr types.str);
          };
          "storagePolicyID" = mkOption {
            description = "storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.";
            type = (types.nullOr types.str);
          };
          "storagePolicyName" = mkOption {
            description = "storagePolicyName is the storage Policy Based Management (SPBM) profile name.";
            type = (types.nullOr types.str);
          };
          "volumePath" = mkOption {
            description = "volumePath is the path that identifies vSphere volume vmdk";
            type = types.str;
          };
        };

        config = {
          "fsType" = mkOverride 1002 null;
          "storagePolicyID" = mkOverride 1002 null;
          "storagePolicyName" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategy" = {

      options = {
        "rollingUpdate" = mkOption {
          description = "Rolling update config params. Present only if DeploymentStrategyType =\nRollingUpdate.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdate"
            )
          );
        };
        "type" = mkOption {
          description = "Type of deployment. Can be \"Recreate\" or \"RollingUpdate\". Default is RollingUpdate.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "rollingUpdate" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdate" =
      {

        options = {
          "maxSurge" = mkOption {
            description = "The maximum number of pods that can be scheduled above the desired number of\npods.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nThis can not be 0 if MaxUnavailable is 0.\nAbsolute number is calculated from percentage by rounding up.\nDefaults to 25%.\nExample: when this is set to 30%, the new ReplicaSet can be scaled up immediately when\nthe rolling update starts, such that the total number of old and new pods do not exceed\n130% of desired pods. Once old pods have been killed,\nnew ReplicaSet can be scaled up further, ensuring that total number of pods running\nat any time during the update is at most 130% of desired pods.";
            type = (types.nullOr (types.either types.int types.str));
          };
          "maxUnavailable" = mkOption {
            description = "The maximum number of pods that can be unavailable during the update.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nAbsolute number is calculated from percentage by rounding down.\nThis can not be 0 if MaxSurge is 0.\nDefaults to 25%.\nExample: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods\nimmediately when the rolling update starts. Once new pods are ready, old ReplicaSet\ncan be scaled down further, followed by scaling up the new ReplicaSet, ensuring\nthat the total number of pods available at all times during the update is at\nleast 70% of desired pods.";
            type = (types.nullOr (types.either types.int types.str));
          };
        };

        config = {
          "maxSurge" = mkOverride 1002 null;
          "maxUnavailable" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpa" = {

      options = {
        "behavior" = mkOption {
          description = "behavior configures the scaling behavior of the target\nin both Up and Down directions (scaleUp and scaleDown fields respectively).\nIf not set, the default HPAScalingRules for scale up and scale down are used.\nSee k8s.io.autoscaling.v2.HorizontalPodAutoScalerBehavior.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehavior"
            )
          );
        };
        "maxReplicas" = mkOption {
          description = "maxReplicas is the upper limit for the number of replicas to which the autoscaler can scale up.\nIt cannot be less that minReplicas.";
          type = types.int;
        };
        "metrics" = mkOption {
          description = "metrics contains the specifications for which to use to calculate the\ndesired replica count (the maximum replica count across all metrics will\nbe used).\nIf left empty, it defaults to being based on CPU utilization with average on 80% usage.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics"
              )
            )
          );
        };
        "minReplicas" = mkOption {
          description = "minReplicas is the lower limit for the number of replicas to which the autoscaler\ncan scale down. It defaults to 1 replica.";
          type = (types.nullOr types.int);
        };
        "name" = mkOption {
          description = "Name of the horizontalPodAutoScaler.\nWhen unset, this defaults to an autogenerated name.";
          type = (types.nullOr types.str);
        };
        "patch" = mkOption {
          description = "Patch defines how to perform the patch operation to the HorizontalPodAutoscaler";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaPatch"
            )
          );
        };
      };

      config = {
        "behavior" = mkOverride 1002 null;
        "metrics" = mkOverride 1002 null;
        "minReplicas" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
        "patch" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehavior" = {

      options = {
        "scaleDown" = mkOption {
          description = "scaleDown is scaling policy for scaling Down.\nIf not set, the default value is to allow to scale down to minReplicas pods, with a\n300 second stabilization window (i.e., the highest recommendation for\nthe last 300sec is used).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown"
            )
          );
        };
        "scaleUp" = mkOption {
          description = "scaleUp is scaling policy for scaling Up.\nIf not set, the default value is the higher of:\n  * increase no more than 4 pods per 60 seconds\n  * double the number of pods per 60 seconds\nNo stabilization is used.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp"
            )
          );
        };
      };

      config = {
        "scaleDown" = mkOverride 1002 null;
        "scaleUp" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown" = {

      options = {
        "policies" = mkOption {
          description = "policies is a list of potential scaling polices which can be used during scaling.\nIf not set, use the default values:\n- For scale up: allow doubling the number of pods, or an absolute change of 4 pods in a 15s window.\n- For scale down: allow all pods to be removed in a 15s window.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies"
              )
            )
          );
        };
        "selectPolicy" = mkOption {
          description = "selectPolicy is used to specify which policy should be used.\nIf not set, the default value Max is used.";
          type = (types.nullOr types.str);
        };
        "stabilizationWindowSeconds" = mkOption {
          description = "stabilizationWindowSeconds is the number of seconds for which past recommendations should be\nconsidered while scaling up or scaling down.\nStabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).\nIf not set, use the default values:\n- For scale up: 0 (i.e. no stabilization is done).\n- For scale down: 300 (i.e. the stabilization window is 300 seconds long).";
          type = (types.nullOr types.int);
        };
        "tolerance" = mkOption {
          description = "tolerance is the tolerance on the ratio between the current and desired\nmetric value under which no updates are made to the desired number of\nreplicas (e.g. 0.01 for 1%). Must be greater than or equal to zero. If not\nset, the default cluster-wide tolerance is applied (by default 10%).\n\nFor example, if autoscaling is configured with a memory consumption target of 100Mi,\nand scale-down and scale-up tolerances of 5% and 1% respectively, scaling will be\ntriggered when the actual consumption falls below 95Mi or exceeds 101Mi.\n\nThis is an beta field and requires the HPAConfigurableTolerance feature\ngate to be enabled.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "policies" = mkOverride 1002 null;
        "selectPolicy" = mkOverride 1002 null;
        "stabilizationWindowSeconds" = mkOverride 1002 null;
        "tolerance" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies" =
      {

        options = {
          "periodSeconds" = mkOption {
            description = "periodSeconds specifies the window of time for which the policy should hold true.\nPeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).";
            type = types.int;
          };
          "type" = mkOption {
            description = "type is used to specify the scaling policy.";
            type = types.str;
          };
          "value" = mkOption {
            description = "value contains the amount of change which is permitted by the policy.\nIt must be greater than zero";
            type = types.int;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp" = {

      options = {
        "policies" = mkOption {
          description = "policies is a list of potential scaling polices which can be used during scaling.\nIf not set, use the default values:\n- For scale up: allow doubling the number of pods, or an absolute change of 4 pods in a 15s window.\n- For scale down: allow all pods to be removed in a 15s window.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies"
              )
            )
          );
        };
        "selectPolicy" = mkOption {
          description = "selectPolicy is used to specify which policy should be used.\nIf not set, the default value Max is used.";
          type = (types.nullOr types.str);
        };
        "stabilizationWindowSeconds" = mkOption {
          description = "stabilizationWindowSeconds is the number of seconds for which past recommendations should be\nconsidered while scaling up or scaling down.\nStabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).\nIf not set, use the default values:\n- For scale up: 0 (i.e. no stabilization is done).\n- For scale down: 300 (i.e. the stabilization window is 300 seconds long).";
          type = (types.nullOr types.int);
        };
        "tolerance" = mkOption {
          description = "tolerance is the tolerance on the ratio between the current and desired\nmetric value under which no updates are made to the desired number of\nreplicas (e.g. 0.01 for 1%). Must be greater than or equal to zero. If not\nset, the default cluster-wide tolerance is applied (by default 10%).\n\nFor example, if autoscaling is configured with a memory consumption target of 100Mi,\nand scale-down and scale-up tolerances of 5% and 1% respectively, scaling will be\ntriggered when the actual consumption falls below 95Mi or exceeds 101Mi.\n\nThis is an beta field and requires the HPAConfigurableTolerance feature\ngate to be enabled.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "policies" = mkOverride 1002 null;
        "selectPolicy" = mkOverride 1002 null;
        "stabilizationWindowSeconds" = mkOverride 1002 null;
        "tolerance" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies" = {

      options = {
        "periodSeconds" = mkOption {
          description = "periodSeconds specifies the window of time for which the policy should hold true.\nPeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).";
          type = types.int;
        };
        "type" = mkOption {
          description = "type is used to specify the scaling policy.";
          type = types.str;
        };
        "value" = mkOption {
          description = "value contains the amount of change which is permitted by the policy.\nIt must be greater than zero";
          type = types.int;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics" = {

      options = {
        "containerResource" = mkOption {
          description = "containerResource refers to a resource metric (such as those specified in\nrequests and limits) known to Kubernetes describing a single container in\neach pod of the current scale target (e.g. CPU or memory). Such metrics are\nbuilt in to Kubernetes, and have special scaling options on top of those\navailable to normal per-pod metrics using the \"pods\" source.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource"
            )
          );
        };
        "external" = mkOption {
          description = "external refers to a global metric that is not associated\nwith any Kubernetes object. It allows autoscaling based on information\ncoming from components running outside of cluster\n(for example length of queue in cloud messaging service, or\nQPS from loadbalancer running outside of cluster).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternal"
            )
          );
        };
        "object" = mkOption {
          description = "object refers to a metric describing a single kubernetes object\n(for example, hits-per-second on an Ingress object).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject"
            )
          );
        };
        "pods" = mkOption {
          description = "pods refers to a metric describing each pod in the current scale target\n(for example, transactions-processed-per-second).  The values will be\naveraged together before being compared to the target value.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPods"
            )
          );
        };
        "resource" = mkOption {
          description = "resource refers to a resource metric (such as those specified in\nrequests and limits) known to Kubernetes describing each pod in the\ncurrent scale target (e.g. CPU or memory). Such metrics are built in to\nKubernetes, and have special scaling options on top of those available\nto normal per-pod metrics using the \"pods\" source.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResource"
            )
          );
        };
        "type" = mkOption {
          description = "type is the type of metric source.  It should be one of \"ContainerResource\", \"External\",\n\"Object\", \"Pods\" or \"Resource\", each mapping to a matching field in the object.";
          type = types.str;
        };
      };

      config = {
        "containerResource" = mkOverride 1002 null;
        "external" = mkOverride 1002 null;
        "object" = mkOverride 1002 null;
        "pods" = mkOverride 1002 null;
        "resource" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource" =
      {

        options = {
          "container" = mkOption {
            description = "container is the name of the container in the pods of the scaling target";
            type = types.str;
          };
          "name" = mkOption {
            description = "name is the name of the resource in question.";
            type = types.str;
          };
          "target" = mkOption {
            description = "target specifies the target value for the given metric";
            type = (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget"
            );
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget" =
      {

        options = {
          "averageUtilization" = mkOption {
            description = "averageUtilization is the target value of the average of the\nresource metric across all relevant pods, represented as a percentage of\nthe requested value of the resource for the pods.\nCurrently only valid for Resource metric source type";
            type = (types.nullOr types.int);
          };
          "averageValue" = mkOption {
            description = "averageValue is the target value of the average of the\nmetric across all relevant pods (as a quantity)";
            type = (types.nullOr (types.either types.int types.str));
          };
          "type" = mkOption {
            description = "type represents whether the metric type is Utilization, Value, or AverageValue";
            type = types.str;
          };
          "value" = mkOption {
            description = "value is the target value of the metric (as a quantity).";
            type = (types.nullOr (types.either types.int types.str));
          };
        };

        config = {
          "averageUtilization" = mkOverride 1002 null;
          "averageValue" = mkOverride 1002 null;
          "value" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternal" = {

      options = {
        "metric" = mkOption {
          description = "metric identifies the target metric by name and selector";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetric"
          );
        };
        "target" = mkOption {
          description = "target specifies the target value for the given metric";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget"
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetric" = {

      options = {
        "name" = mkOption {
          description = "name is the name of the given metric";
          type = types.str;
        };
        "selector" = mkOption {
          description = "selector is the string-encoded form of a standard kubernetes label selector for the given metric\nWhen set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.\nWhen unset, just the metricName will be used to gather metrics.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelector"
            )
          );
        };
      };

      config = {
        "selector" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget" = {

      options = {
        "averageUtilization" = mkOption {
          description = "averageUtilization is the target value of the average of the\nresource metric across all relevant pods, represented as a percentage of\nthe requested value of the resource for the pods.\nCurrently only valid for Resource metric source type";
          type = (types.nullOr types.int);
        };
        "averageValue" = mkOption {
          description = "averageValue is the target value of the average of the\nmetric across all relevant pods (as a quantity)";
          type = (types.nullOr (types.either types.int types.str));
        };
        "type" = mkOption {
          description = "type represents whether the metric type is Utilization, Value, or AverageValue";
          type = types.str;
        };
        "value" = mkOption {
          description = "value is the target value of the metric (as a quantity).";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "averageUtilization" = mkOverride 1002 null;
        "averageValue" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject" = {

      options = {
        "describedObject" = mkOption {
          description = "describedObject specifies the descriptions of a object,such as kind,name apiVersion";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject"
          );
        };
        "metric" = mkOption {
          description = "metric identifies the target metric by name and selector";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetric"
          );
        };
        "target" = mkOption {
          description = "target specifies the target value for the given metric";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget"
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject" =
      {

        options = {
          "apiVersion" = mkOption {
            description = "apiVersion is the API version of the referent";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "kind is the kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
            type = types.str;
          };
          "name" = mkOption {
            description = "name is the name of the referent; More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = types.str;
          };
        };

        config = {
          "apiVersion" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetric" = {

      options = {
        "name" = mkOption {
          description = "name is the name of the given metric";
          type = types.str;
        };
        "selector" = mkOption {
          description = "selector is the string-encoded form of a standard kubernetes label selector for the given metric\nWhen set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.\nWhen unset, just the metricName will be used to gather metrics.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelector"
            )
          );
        };
      };

      config = {
        "selector" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget" = {

      options = {
        "averageUtilization" = mkOption {
          description = "averageUtilization is the target value of the average of the\nresource metric across all relevant pods, represented as a percentage of\nthe requested value of the resource for the pods.\nCurrently only valid for Resource metric source type";
          type = (types.nullOr types.int);
        };
        "averageValue" = mkOption {
          description = "averageValue is the target value of the average of the\nmetric across all relevant pods (as a quantity)";
          type = (types.nullOr (types.either types.int types.str));
        };
        "type" = mkOption {
          description = "type represents whether the metric type is Utilization, Value, or AverageValue";
          type = types.str;
        };
        "value" = mkOption {
          description = "value is the target value of the metric (as a quantity).";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "averageUtilization" = mkOverride 1002 null;
        "averageValue" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPods" = {

      options = {
        "metric" = mkOption {
          description = "metric identifies the target metric by name and selector";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetric"
          );
        };
        "target" = mkOption {
          description = "target specifies the target value for the given metric";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget"
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetric" = {

      options = {
        "name" = mkOption {
          description = "name is the name of the given metric";
          type = types.str;
        };
        "selector" = mkOption {
          description = "selector is the string-encoded form of a standard kubernetes label selector for the given metric\nWhen set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.\nWhen unset, just the metricName will be used to gather metrics.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelector"
            )
          );
        };
      };

      config = {
        "selector" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget" = {

      options = {
        "averageUtilization" = mkOption {
          description = "averageUtilization is the target value of the average of the\nresource metric across all relevant pods, represented as a percentage of\nthe requested value of the resource for the pods.\nCurrently only valid for Resource metric source type";
          type = (types.nullOr types.int);
        };
        "averageValue" = mkOption {
          description = "averageValue is the target value of the average of the\nmetric across all relevant pods (as a quantity)";
          type = (types.nullOr (types.either types.int types.str));
        };
        "type" = mkOption {
          description = "type represents whether the metric type is Utilization, Value, or AverageValue";
          type = types.str;
        };
        "value" = mkOption {
          description = "value is the target value of the metric (as a quantity).";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "averageUtilization" = mkOverride 1002 null;
        "averageValue" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResource" = {

      options = {
        "name" = mkOption {
          description = "name is the name of the resource in question.";
          type = types.str;
        };
        "target" = mkOption {
          description = "target specifies the target value for the given metric";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget"
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget" = {

      options = {
        "averageUtilization" = mkOption {
          description = "averageUtilization is the target value of the average of the\nresource metric across all relevant pods, represented as a percentage of\nthe requested value of the resource for the pods.\nCurrently only valid for Resource metric source type";
          type = (types.nullOr types.int);
        };
        "averageValue" = mkOption {
          description = "averageValue is the target value of the average of the\nmetric across all relevant pods (as a quantity)";
          type = (types.nullOr (types.either types.int types.str));
        };
        "type" = mkOption {
          description = "type represents whether the metric type is Utilization, Value, or AverageValue";
          type = types.str;
        };
        "value" = mkOption {
          description = "value is the target value of the metric (as a quantity).";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "averageUtilization" = mkOverride 1002 null;
        "averageValue" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaPatch" = {

      options = {
        "type" = mkOption {
          description = "Type is the type of merge operation to perform\n\nBy default, StrategicMerge is used as the patch type.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Object contains the raw configuration for merged object";
          type = types.unspecified;
        };
      };

      config = {
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyPDB" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "MaxUnavailable specifies the maximum amount of pods (can be expressed as integers or as a percentage) that can be unavailable at all times during voluntary disruptions,\nsuch as node drains or updates. This setting ensures that your envoy proxy maintains a certain level of availability\nand resilience during maintenance operations. Cannot be combined with minAvailable.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "MinAvailable specifies the minimum amount of pods (can be expressed as integers or as a percentage) that must be available at all times during voluntary disruptions,\nsuch as node drains or updates. This setting ensures that your envoy proxy maintains a certain level of availability\nand resilience during maintenance operations. Cannot be combined with maxUnavailable.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "name" = mkOption {
          description = "Name of the podDisruptionBudget.\nWhen unset, this defaults to an autogenerated name.";
          type = (types.nullOr types.str);
        };
        "patch" = mkOption {
          description = "Patch defines how to perform the patch operation to the PodDisruptionBudget";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyPDBPatch"
            )
          );
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
        "patch" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyPDBPatch" = {

      options = {
        "type" = mkOption {
          description = "Type is the type of merge operation to perform\n\nBy default, StrategicMerge is used as the patch type.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Object contains the raw configuration for merged object";
          type = types.unspecified;
        };
      };

      config = {
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyService" = {

      options = {
        "allocateLoadBalancerNodePorts" = mkOption {
          description = "AllocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for\nservices with type LoadBalancer. Default is \"true\". It may be set to \"false\" if the cluster\nload-balancer does not rely on NodePorts. If the caller requests specific NodePorts (by specifying a\nvalue), those requests will be respected, regardless of this field. This field may only be set for\nservices with type LoadBalancer and will be cleared if the type is changed to any other type.";
          type = (types.nullOr types.bool);
        };
        "annotations" = mkOption {
          description = "Annotations that should be appended to the service.\nBy default, no annotations are appended.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "externalTrafficPolicy" = mkOption {
          description = "ExternalTrafficPolicy determines the externalTrafficPolicy for the Envoy Service. Valid options\nare Local and Cluster. Default is \"Local\". \"Local\" means traffic will only go to pods on the node\nreceiving the traffic. \"Cluster\" means connections are loadbalanced to all pods in the cluster.";
          type = (types.nullOr types.str);
        };
        "labels" = mkOption {
          description = "Labels that should be appended to the service.\nBy default, no labels are appended.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "loadBalancerClass" = mkOption {
          description = "LoadBalancerClass, when specified, allows for choosing the LoadBalancer provider\nimplementation if more than one are available or is otherwise expected to be specified";
          type = (types.nullOr types.str);
        };
        "loadBalancerIP" = mkOption {
          description = "LoadBalancerIP defines the IP Address of the underlying load balancer service. This field\nmay be ignored if the load balancer provider does not support this feature.\nThis field has been deprecated in Kubernetes, but it is still used for setting the IP Address in some cloud\nproviders such as GCP.";
          type = (types.nullOr types.str);
        };
        "loadBalancerSourceRanges" = mkOption {
          description = "LoadBalancerSourceRanges defines a list of allowed IP addresses which will be configured as\nfirewall rules on the platform providers load balancer. This is not guaranteed to be working as\nit happens outside of kubernetes and has to be supported and handled by the platform provider.\nThis field may only be set for services with type LoadBalancer and will be cleared if the type\nis changed to any other type.";
          type = (types.nullOr (types.listOf types.str));
        };
        "name" = mkOption {
          description = "Name of the service.\nWhen unset, this defaults to an autogenerated name.";
          type = (types.nullOr types.str);
        };
        "patch" = mkOption {
          description = "Patch defines how to perform the patch operation to the service";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyServicePatch"
            )
          );
        };
        "type" = mkOption {
          description = "Type determines how the Service is exposed. Defaults to LoadBalancer.\nValid options are ClusterIP, LoadBalancer and NodePort.\n\"LoadBalancer\" means a service will be exposed via an external load balancer (if the cloud provider supports it).\n\"ClusterIP\" means a service will only be accessible inside the cluster, via the cluster IP.\n\"NodePort\" means a service will be exposed on a static Port on all Nodes of the cluster.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "allocateLoadBalancerNodePorts" = mkOverride 1002 null;
        "annotations" = mkOverride 1002 null;
        "externalTrafficPolicy" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "loadBalancerClass" = mkOverride 1002 null;
        "loadBalancerIP" = mkOverride 1002 null;
        "loadBalancerSourceRanges" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
        "patch" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyServiceAccount" = {

      options = {
        "name" = mkOption {
          description = "Name of the Service Account.\nWhen unset, this defaults to an autogenerated name.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyServicePatch" = {

      options = {
        "type" = mkOption {
          description = "Type is the type of merge operation to perform\n\nBy default, StrategicMerge is used as the patch type.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Object contains the raw configuration for merged object";
          type = types.unspecified;
        };
      };

      config = {
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecShutdown" = {

      options = {
        "drainTimeout" = mkOption {
          description = "DrainTimeout defines the graceful drain timeout. This should be less than the pod's terminationGracePeriodSeconds.\nIf unspecified, defaults to 60 seconds.";
          type = (types.nullOr types.str);
        };
        "minDrainDuration" = mkOption {
          description = "MinDrainDuration defines the minimum drain duration allowing time for endpoint deprogramming to complete.\nIf unspecified, defaults to 10 seconds.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "drainTimeout" = mkOverride 1002 null;
        "minDrainDuration" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetry" = {

      options = {
        "accessLog" = mkOption {
          description = "AccessLogs defines accesslog parameters for managed proxies.\nIf unspecified, will send default format to stdout.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLog")
          );
        };
        "metrics" = mkOption {
          description = "Metrics defines metrics configuration for managed proxies.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetrics"));
        };
        "requestID" = mkOption {
          description = "RequestID configures Envoy request ID behavior.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryRequestID")
          );
        };
        "tracing" = mkOption {
          description = "Tracing defines tracing configuration for managed proxies.\nIf unspecified, will not send tracing data.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracing"));
        };
      };

      config = {
        "accessLog" = mkOverride 1002 null;
        "metrics" = mkOverride 1002 null;
        "requestID" = mkOverride 1002 null;
        "tracing" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLog" = {

      options = {
        "disable" = mkOption {
          description = "Disable disables access logging for managed proxies if set to true.";
          type = (types.nullOr types.bool);
        };
        "settings" = mkOption {
          description = "Settings defines accesslog settings for managed proxies.\nIf unspecified, will send default format to stdout.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettings")
            )
          );
        };
      };

      config = {
        "disable" = mkOverride 1002 null;
        "settings" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettings" = {

      options = {
        "format" = mkOption {
          description = "Format defines the format of accesslog.\nThis will be ignored if sink type is ALS.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsFormat"
            )
          );
        };
        "matches" = mkOption {
          description = "Matches defines the match conditions for accesslog in CEL expression.\nAn accesslog will be emitted only when one or more match conditions are evaluated to true.\nInvalid [CEL](https://www.envoyproxy.io/docs/envoy/latest/xds/type/v3/cel.proto.html#common-expression-language-cel-proto) expressions will be ignored.";
          type = (types.nullOr (types.listOf types.str));
        };
        "sinks" = mkOption {
          description = "Sinks defines the sinks of accesslog.";
          type = (
            types.listOf (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinks"
            )
          );
        };
        "type" = mkOption {
          description = "Type defines the component emitting the accesslog, such as Listener and Route.\nIf type not defined, the setting would apply to:\n(1) All Routes.\n(2) Listeners if and only if Envoy does not find a matching route for a request.\nIf type is defined, the accesslog settings would apply to the relevant component (as-is).";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "format" = mkOverride 1002 null;
        "matches" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsFormat" = {

      options = {
        "json" = mkOption {
          description = "JSON is additional attributes that describe the specific event occurrence.\nStructured format for the envoy access logs. Envoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators)\ncan be used as values for fields within the Struct.\nIt's required when the format type is \"JSON\".";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "text" = mkOption {
          description = "Text defines the text accesslog format, following Envoy accesslog formatting,\nIt's required when the format type is \"Text\".\nEnvoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators) may be used in the format.\nThe [format string documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings) provides more information.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type defines the type of accesslog format.\nWhen unset, both text and json can be specified.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "json" = mkOverride 1002 null;
        "text" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinks" = {

      options = {
        "als" = mkOption {
          description = "ALS defines the gRPC Access Log Service (ALS) sink.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAls"
            )
          );
        };
        "file" = mkOption {
          description = "File defines the file accesslog sink.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksFile"
            )
          );
        };
        "openTelemetry" = mkOption {
          description = "OpenTelemetry defines the OpenTelemetry accesslog sink.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry"
            )
          );
        };
        "type" = mkOption {
          description = "Type defines the type of accesslog sink.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "als" = mkOverride 1002 null;
        "file" = mkOverride 1002 null;
        "openTelemetry" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAls" = {

      options = {
        "backendRef" = mkOption {
          description = "BackendRef references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.\n\nDeprecated: Use BackendRefs instead.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef"
            )
          );
        };
        "backendRefs" = mkOption {
          description = "BackendRefs references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "backendSettings" = mkOption {
          description = "BackendSettings holds configuration for managing the connection\nto the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings"
            )
          );
        };
        "http" = mkOption {
          description = "HTTP defines additional configuration specific to HTTP access logs.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp"
            )
          );
        };
        "logName" = mkOption {
          description = "LogName defines the friendly name of the access log to be returned in\nStreamAccessLogsMessage.Identifier. This allows the access log server\nto differentiate between different access logs coming from the same Envoy.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type defines the type of accesslog. Supported types are \"HTTP\" and \"TCP\".";
          type = types.str;
        };
      };

      config = {
        "backendRef" = mkOverride 1002 null;
        "backendRefs" = mkOverride 1002 null;
        "backendSettings" = mkOverride 1002 null;
        "http" = mkOverride 1002 null;
        "logName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs" = {

      options = {
        "fallback" = mkOption {
          description = "Fallback indicates whether the backend is designated as a fallback.\nMultiple fallback backends can be configured.\nIt is highly recommended to configure active or passive health checks to ensure that failover can be detected\nwhen the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.\nThe overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when\nthe health of the active backends falls below 72%.";
          type = (types.nullOr types.bool);
        };
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
        "weight" = mkOption {
          description = "Weight specifies the proportion of requests forwarded to the referenced\nbackend. This is computed as weight/(sum of all weights in this\nBackendRefs list). For non-zero values, there may be some epsilon from\nthe exact proportion defined here depending on the precision an\nimplementation supports. Weight is not a percentage and the sum of\nweights does not need to equal 100.\n\nIf only one backend is specified and it has a weight greater than 0, 100%\nof the traffic is forwarded to that backend. If weight is set to 0, no\ntraffic should be forwarded for this entry. If unspecified, weight\ndefaults to 1.\n\nSupport for this field varies based on the context where used.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "fallback" = mkOverride 1002 null;
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "weight" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings" = {

      options = {
        "circuitBreaker" = mkOption {
          description = "Circuit Breaker settings for the upstream connections and requests.\nIf not set, circuit breakers will be enabled with the default thresholds";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker"
            )
          );
        };
        "connection" = mkOption {
          description = "Connection includes backend connection settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection"
            )
          );
        };
        "dns" = mkOption {
          description = "DNS includes dns resolution settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns"
            )
          );
        };
        "healthCheck" = mkOption {
          description = "HealthCheck allows gateway to perform active health checking on backends.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck"
            )
          );
        };
        "http2" = mkOption {
          description = "HTTP2 provides HTTP/2 configuration for backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2"
            )
          );
        };
        "loadBalancer" = mkOption {
          description = "LoadBalancer policy to apply when routing traffic from the gateway to\nthe backend endpoints. Defaults to `LeastRequest`.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer"
            )
          );
        };
        "proxyProtocol" = mkOption {
          description = "ProxyProtocol enables the Proxy Protocol when communicating with the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocol"
            )
          );
        };
        "retry" = mkOption {
          description = "Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.\nIf not set, retry will be disabled.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry"
            )
          );
        };
        "tcpKeepalive" = mkOption {
          description = "TcpKeepalive settings associated with the upstream client connection.\nDisabled by default.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout settings for the backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeout"
            )
          );
        };
      };

      config = {
        "circuitBreaker" = mkOverride 1002 null;
        "connection" = mkOverride 1002 null;
        "dns" = mkOverride 1002 null;
        "healthCheck" = mkOverride 1002 null;
        "http2" = mkOverride 1002 null;
        "loadBalancer" = mkOverride 1002 null;
        "proxyProtocol" = mkOverride 1002 null;
        "retry" = mkOverride 1002 null;
        "tcpKeepalive" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxParallelRequests" = mkOption {
            description = "The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxParallelRetries" = mkOption {
            description = "The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxPendingRequests" = mkOption {
            description = "The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxRequestsPerConnection" = mkOption {
            description = "The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.\nDefault: unlimited.";
            type = (types.nullOr types.int);
          };
          "perEndpoint" = mkOption {
            description = "PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpoint"
              )
            );
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
          "maxParallelRequests" = mkOverride 1002 null;
          "maxParallelRetries" = mkOverride 1002 null;
          "maxPendingRequests" = mkOverride 1002 null;
          "maxRequestsPerConnection" = mkOverride 1002 null;
          "perEndpoint" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpoint" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection" =
      {

        options = {
          "bufferLimit" = mkOption {
            description = "BufferLimit Soft limit on size of the cluster’s connections read and write buffers.\nBufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.\nIf unspecified, an implementation defined default is applied (32768 bytes).\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote: that when the suffix is not provided, the value is interpreted as bytes.";
            type = (types.nullOr (types.either types.int types.str));
          };
          "preconnect" = mkOption {
            description = "Preconnect configures proactive upstream connections to reduce latency by establishing\nconnections before they’re needed and avoiding connection establishment overhead.\n\nIf unset, Envoy will fetch connections as needed to serve in-flight requests.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionPreconnect"
              )
            );
          };
          "socketBufferLimit" = mkOption {
            description = "SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket\nto backend.\nSocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote that when the suffix is not provided, the value is interpreted as bytes.";
            type = (types.nullOr (types.either types.int types.str));
          };
        };

        config = {
          "bufferLimit" = mkOverride 1002 null;
          "preconnect" = mkOverride 1002 null;
          "socketBufferLimit" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionPreconnect" =
      {

        options = {
          "perEndpointPercent" = mkOption {
            description = "PerEndpointPercent configures how many additional connections to maintain per\nupstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a\npercentage of the connections required by active streams\n(e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).\n\nAllowed value range is between 100-300. When both PerEndpointPercent and\nPredictivePercent are set, Envoy ensures both are satisfied (max of the two).";
            type = (types.nullOr types.int);
          };
          "predictivePercent" = mkOption {
            description = "PredictivePercent configures how many additional connections to maintain\nacross the cluster by anticipating which upstream endpoint the load balancer\nwill select next, useful for low-QPS services. Relies on deterministic\nloadbalancing and is only supported with Random or RoundRobin.\nExpressed as a percentage of the connections required by active streams\n(e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).\n\nMinimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are\nset Envoy ensures both are satisfied per host (max of the two).";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "perEndpointPercent" = mkOverride 1002 null;
          "predictivePercent" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns" =
      {

        options = {
          "dnsRefreshRate" = mkOption {
            description = "DNSRefreshRate specifies the rate at which DNS records should be refreshed.\nDefaults to 30 seconds.";
            type = (types.nullOr types.str);
          };
          "lookupFamily" = mkOption {
            description = "LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).\nIf set, this configuration overrides other defaults.";
            type = (types.nullOr types.str);
          };
          "respectDnsTtl" = mkOption {
            description = "RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.\nIf the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.\nDefaults to true.";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "dnsRefreshRate" = mkOverride 1002 null;
          "lookupFamily" = mkOverride 1002 null;
          "respectDnsTtl" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck" =
      {

        options = {
          "active" = mkOption {
            description = "Active health check configuration";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive"
              )
            );
          };
          "panicThreshold" = mkOption {
            description = "When number of unhealthy endpoints for a backend reaches this threshold\nEnvoy will disregard health status and balance across all endpoints.\nIt's designed to prevent a situation in which host failures cascade throughout the cluster\nas load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.";
            type = (types.nullOr types.int);
          };
          "passive" = mkOption {
            description = "Passive passive check configuration";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive"
              )
            );
          };
        };

        config = {
          "active" = mkOverride 1002 null;
          "panicThreshold" = mkOverride 1002 null;
          "passive" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive" =
      {

        options = {
          "grpc" = mkOption {
            description = "GRPC defines the configuration of the GRPC health checker.\nIt's optional, and can only be used if the specified type is GRPC.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpc"
              )
            );
          };
          "healthyThreshold" = mkOption {
            description = "HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.";
            type = (types.nullOr types.int);
          };
          "http" = mkOption {
            description = "HTTP defines the configuration of http health checker.\nIt's required while the health checker type is HTTP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp"
              )
            );
          };
          "initialJitter" = mkOption {
            description = "InitialJitter defines the maximum time Envoy will wait before the first health check.\nEnvoy will randomly select a value between 0 and the initial jitter value.";
            type = (types.nullOr types.str);
          };
          "interval" = mkOption {
            description = "Interval defines the time between active health checks.";
            type = (types.nullOr types.str);
          };
          "tcp" = mkOption {
            description = "TCP defines the configuration of tcp health checker.\nIt's required while the health checker type is TCP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcp"
              )
            );
          };
          "timeout" = mkOption {
            description = "Timeout defines the time to wait for a health check response.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of health checker.";
            type = types.str;
          };
          "unhealthyThreshold" = mkOption {
            description = "UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "grpc" = mkOverride 1002 null;
          "healthyThreshold" = mkOverride 1002 null;
          "http" = mkOverride 1002 null;
          "initialJitter" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "tcp" = mkOverride 1002 null;
          "timeout" = mkOverride 1002 null;
          "unhealthyThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpc" =
      {

        options = {
          "service" = mkOption {
            description = "Service to send in the health check request.\nIf this is not specified, then the health check request applies to the entire\nserver and not to a specific service.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "service" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp" =
      {

        options = {
          "expectedResponse" = mkOption {
            description = "ExpectedResponse defines a list of HTTP expected responses to match.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse"
              )
            );
          };
          "expectedStatuses" = mkOption {
            description = "ExpectedStatuses defines a list of HTTP response statuses considered healthy.\nDefaults to 200 only";
            type = (types.nullOr (types.listOf types.int));
          };
          "hostname" = mkOption {
            description = "Hostname defines the HTTP host that will be requested during health checking.\nDefault: HTTPRoute or GRPCRoute hostname.";
            type = (types.nullOr types.str);
          };
          "method" = mkOption {
            description = "Method defines the HTTP method used for health checking.\nDefaults to GET";
            type = (types.nullOr types.str);
          };
          "path" = mkOption {
            description = "Path defines the HTTP path that will be requested during health checking.";
            type = types.str;
          };
        };

        config = {
          "expectedResponse" = mkOverride 1002 null;
          "expectedStatuses" = mkOverride 1002 null;
          "hostname" = mkOverride 1002 null;
          "method" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcp" =
      {

        options = {
          "receive" = mkOption {
            description = "Receive defines the expected response payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive"
              )
            );
          };
          "send" = mkOption {
            description = "Send defines the request payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend"
              )
            );
          };
        };

        config = {
          "receive" = mkOverride 1002 null;
          "send" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive" =
      {

        options = {
          "baseEjectionTime" = mkOption {
            description = "BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.";
            type = (types.nullOr types.str);
          };
          "consecutive5XxErrors" = mkOption {
            description = "Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.";
            type = (types.nullOr types.int);
          };
          "consecutiveGatewayErrors" = mkOption {
            description = "ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.";
            type = (types.nullOr types.int);
          };
          "consecutiveLocalOriginFailures" = mkOption {
            description = "ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.\nParameter takes effect only when split_external_local_origin_errors is set to true.";
            type = (types.nullOr types.int);
          };
          "failurePercentageThreshold" = mkOption {
            description = "FailurePercentageThreshold sets the failure percentage threshold for outlier detection.\nIf the failure percentage of a given host is greater than or equal to this value, it will be ejected.\nDefaults to 85.";
            type = (types.nullOr types.int);
          };
          "interval" = mkOption {
            description = "Interval defines the time between passive health checks.";
            type = (types.nullOr types.str);
          };
          "maxEjectionPercent" = mkOption {
            description = "MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.";
            type = (types.nullOr types.int);
          };
          "splitExternalLocalOriginErrors" = mkOption {
            description = "SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "baseEjectionTime" = mkOverride 1002 null;
          "consecutive5XxErrors" = mkOverride 1002 null;
          "consecutiveGatewayErrors" = mkOverride 1002 null;
          "consecutiveLocalOriginFailures" = mkOverride 1002 null;
          "failurePercentageThreshold" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "maxEjectionPercent" = mkOverride 1002 null;
          "splitExternalLocalOriginErrors" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2" =
      {

        options = {
          "initialConnectionWindowSize" = mkOption {
            description = "InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.\nIf not set, the default value is 1 MiB.";
            type = (types.nullOr (types.either types.int types.str));
          };
          "initialStreamWindowSize" = mkOption {
            description = "InitialStreamWindowSize sets the initial window size for HTTP/2 streams.\nIf not set, the default value is 64 KiB(64*1024).";
            type = (types.nullOr (types.either types.int types.str));
          };
          "maxConcurrentStreams" = mkOption {
            description = "MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.\nIf not set, the default value is 100.";
            type = (types.nullOr types.int);
          };
          "onInvalidMessage" = mkOption {
            description = "OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error\nIt's recommended for L2 Envoy deployments to set this value to TerminateStream.\nhttps://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two\nDefault: TerminateConnection";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "initialConnectionWindowSize" = mkOverride 1002 null;
          "initialStreamWindowSize" = mkOverride 1002 null;
          "maxConcurrentStreams" = mkOverride 1002 null;
          "onInvalidMessage" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer" =
      {

        options = {
          "consistentHash" = mkOption {
            description = "ConsistentHash defines the configuration when the load balancer type is\nset to ConsistentHash";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash"
              )
            );
          };
          "endpointOverride" = mkOption {
            description = "EndpointOverride defines the configuration for endpoint override.\nWhen specified, the load balancer will attempt to route requests to endpoints\nbased on the override information extracted from request headers or metadata.\n If the override endpoints are not available, the configured load balancer policy will be used as fallback.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverride"
              )
            );
          };
          "slowStart" = mkOption {
            description = "SlowStart defines the configuration related to the slow start load balancer policy.\nIf set, during slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently this is only supported for RoundRobin and LeastRequest load balancers";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStart"
              )
            );
          };
          "type" = mkOption {
            description = "Type decides the type of Load Balancer policy.\nValid LoadBalancerType values are\n\"ConsistentHash\",\n\"LeastRequest\",\n\"Random\",\n\"RoundRobin\".";
            type = types.str;
          };
          "zoneAware" = mkOption {
            description = "ZoneAware defines the configuration related to the distribution of requests between locality zones.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAware"
              )
            );
          };
        };

        config = {
          "consistentHash" = mkOverride 1002 null;
          "endpointOverride" = mkOverride 1002 null;
          "slowStart" = mkOverride 1002 null;
          "zoneAware" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash" =
      {

        options = {
          "cookie" = mkOption {
            description = "Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie"
              )
            );
          };
          "header" = mkOption {
            description = "Header configures the header hash policy when the consistent hash type is set to Header.\n\nDeprecated: use Headers instead";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeader"
              )
            );
          };
          "headers" = mkOption {
            description = "Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "queryParams" = mkOption {
            description = "QueryParams configures the query parameter hash policy when the consistent hash type is set to QueryParams.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashQueryParams"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "tableSize" = mkOption {
            description = "The table size for consistent hashing, must be prime number limited to 5000011.";
            type = (types.nullOr types.int);
          };
          "type" = mkOption {
            description = "ConsistentHashType defines the type of input to hash on. Valid Type values are\n\"SourceIP\",\n\"Header\",\n\"Headers\",\n\"Cookie\".\n\"QueryParams\".";
            type = types.str;
          };
        };

        config = {
          "cookie" = mkOverride 1002 null;
          "header" = mkOverride 1002 null;
          "headers" = mkOverride 1002 null;
          "queryParams" = mkOverride 1002 null;
          "tableSize" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie" =
      {

        options = {
          "attributes" = mkOption {
            description = "Additional Attributes to set for the generated cookie.";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "name" = mkOption {
            description = "Name of the cookie to hash.\nIf this cookie does not exist in the request, Envoy will generate a cookie and set\nthe TTL on the response back to the client based on Layer 4\nattributes of the backend endpoint, to ensure that these future requests\ngo to the same backend endpoint. Make sure to set the TTL field for this case.";
            type = types.str;
          };
          "ttl" = mkOption {
            description = "TTL of the generated cookie if the cookie is not present. This value sets the\nMax-Age attribute value.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "attributes" = mkOverride 1002 null;
          "ttl" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeader" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashQueryParams" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the query param to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverride" =
      {

        options = {
          "extractFrom" = mkOption {
            description = "ExtractFrom defines the sources to extract endpoint override information from.";
            type = (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFrom"
              )
            );
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFrom" =
      {

        options = {
          "header" = mkOption {
            description = "Header defines the header to get the override endpoint addresses.\nThe header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.\nFor example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.\nThe IPv6 address is enclosed in square brackets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "header" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStart" =
      {

        options = {
          "window" = mkOption {
            description = "Window defines the duration of the warm up period for newly added host.\nDuring slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently only supports linear growth of traffic. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAware" =
      {

        options = {
          "preferLocal" = mkOption {
            description = "PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal"
              )
            );
          };
        };

        config = {
          "preferLocal" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal" =
      {

        options = {
          "force" = mkOption {
            description = "ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior\nwhich maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForce"
              )
            );
          };
          "minEndpointsThreshold" = mkOption {
            description = "MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.";
            type = (types.nullOr types.int);
          };
          "percentageEnabled" = mkOption {
            description = "Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "force" = mkOverride 1002 null;
          "minEndpointsThreshold" = mkOverride 1002 null;
          "percentageEnabled" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForce" =
      {

        options = {
          "minEndpointsInZoneThreshold" = mkOption {
            description = "MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone\noverride. This is useful for protecting zones with fewer endpoints.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "minEndpointsInZoneThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocol" =
      {

        options = {
          "version" = mkOption {
            description = "Version of ProxyProtol\nValid ProxyProtocolVersion values are\n\"V1\"\n\"V2\"";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry" =
      {

        options = {
          "numAttemptsPerPriority" = mkOption {
            description = "NumAttemptsPerPriority defines the number of requests (initial attempt + retries)\nthat should be sent to the same priority before switching to a different one.\nIf not specified or set to 0, all requests are sent to the highest priority that is healthy.";
            type = (types.nullOr types.int);
          };
          "numRetries" = mkOption {
            description = "NumRetries is the number of retries to be attempted. Defaults to 2.";
            type = (types.nullOr types.int);
          };
          "perRetry" = mkOption {
            description = "PerRetry is the retry policy to be applied per retry attempt.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetry"
              )
            );
          };
          "retryOn" = mkOption {
            description = "RetryOn specifies the retry trigger condition.\n\nIf not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOn"
              )
            );
          };
        };

        config = {
          "numAttemptsPerPriority" = mkOverride 1002 null;
          "numRetries" = mkOverride 1002 null;
          "perRetry" = mkOverride 1002 null;
          "retryOn" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetry" =
      {

        options = {
          "backOff" = mkOption {
            description = "Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential\nback-off algorithm for retries. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOff"
              )
            );
          };
          "timeout" = mkOption {
            description = "Timeout is the timeout per retry attempt.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "backOff" = mkOverride 1002 null;
          "timeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOff" =
      {

        options = {
          "baseInterval" = mkOption {
            description = "BaseInterval is the base interval between retries.";
            type = (types.nullOr types.str);
          };
          "maxInterval" = mkOption {
            description = "MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.\nThe default is 10 times the base_interval";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "baseInterval" = mkOverride 1002 null;
          "maxInterval" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOn" =
      {

        options = {
          "httpStatusCodes" = mkOption {
            description = "HttpStatusCodes specifies the http status codes to be retried.\nThe retriable-status-codes trigger must also be configured for these status codes to trigger a retry.";
            type = (types.nullOr (types.listOf types.int));
          };
          "triggers" = mkOption {
            description = "Triggers specifies the retry trigger condition(Http/Grpc).";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "httpStatusCodes" = mkOverride 1002 null;
          "triggers" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive" =
      {

        options = {
          "idleTime" = mkOption {
            description = "The duration a connection needs to be idle before keep-alive\nprobes start being sent.\nThe duration format is\nDefaults to `7200s`.";
            type = (types.nullOr types.str);
          };
          "interval" = mkOption {
            description = "The duration between keep-alive probes.\nDefaults to `75s`.";
            type = (types.nullOr types.str);
          };
          "probes" = mkOption {
            description = "The total number of unacknowledged probes to send before deciding\nthe connection is dead.\nDefaults to 9.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "idleTime" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "probes" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeout" =
      {

        options = {
          "http" = mkOption {
            description = "Timeout settings for HTTP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp"
              )
            );
          };
          "tcp" = mkOption {
            description = "Timeout settings for TCP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcp"
              )
            );
          };
        };

        config = {
          "http" = mkOverride 1002 null;
          "tcp" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp" =
      {

        options = {
          "connectionIdleTimeout" = mkOption {
            description = "The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.\nDefault: 1 hour.";
            type = (types.nullOr types.str);
          };
          "maxConnectionDuration" = mkOption {
            description = "The maximum duration of an HTTP connection.\nDefault: unlimited.";
            type = (types.nullOr types.str);
          };
          "maxStreamDuration" = mkOption {
            description = "MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time\nfrom when the request is sent until the response stream is fully consumed and does not apply to\nnon-streaming requests.\nWhen set to \"0s\", no max duration is applied and streams can run indefinitely.";
            type = (types.nullOr types.str);
          };
          "requestTimeout" = mkOption {
            description = "RequestTimeout is the time until which entire response is received from the upstream.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "connectionIdleTimeout" = mkOverride 1002 null;
          "maxConnectionDuration" = mkOverride 1002 null;
          "maxStreamDuration" = mkOverride 1002 null;
          "requestTimeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcp" =
      {

        options = {
          "connectTimeout" = mkOption {
            description = "The timeout for network connection establishment, including TCP and TLS handshakes.\nDefault: 10 seconds.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "connectTimeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp" = {

      options = {
        "requestHeaders" = mkOption {
          description = "RequestHeaders defines request headers to include in log entries sent to the access log service.";
          type = (types.nullOr (types.listOf types.str));
        };
        "responseHeaders" = mkOption {
          description = "ResponseHeaders defines response headers to include in log entries sent to the access log service.";
          type = (types.nullOr (types.listOf types.str));
        };
        "responseTrailers" = mkOption {
          description = "ResponseTrailers defines response trailers to include in log entries sent to the access log service.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "requestHeaders" = mkOverride 1002 null;
        "responseHeaders" = mkOverride 1002 null;
        "responseTrailers" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksFile" = {

      options = {
        "path" = mkOption {
          description = "Path defines the file path used to expose envoy access log(e.g. /dev/stdout).";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "path" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry" = {

      options = {
        "backendRef" = mkOption {
          description = "BackendRef references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.\n\nDeprecated: Use BackendRefs instead.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef"
            )
          );
        };
        "backendRefs" = mkOption {
          description = "BackendRefs references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "backendSettings" = mkOption {
          description = "BackendSettings holds configuration for managing the connection\nto the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings"
            )
          );
        };
        "headers" = mkOption {
          description = "Headers is a list of additional headers to send with OTLP export requests.\nThese headers are added as gRPC initial metadata for the OTLP gRPC service.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryHeaders"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "host" = mkOption {
          description = "Host define the extension service hostname.\nDeprecated: Use BackendRefs instead.";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port defines the port the extension service is exposed on.\nDeprecated: Use BackendRefs instead.";
          type = (types.nullOr types.int);
        };
        "resourceAttributes" = mkOption {
          description = "ResourceAttributes is a set of labels that describe the source of a log entry, including envoy node info.\nIt's recommended to follow [semantic conventions](https://opentelemetry.io/docs/reference/specification/resource/semantic_conventions/).";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "resources" = mkOption {
          description = "Resources is a set of labels that describe the source of a log entry, including envoy node info.\nIt's recommended to follow [semantic conventions](https://opentelemetry.io/docs/reference/specification/resource/semantic_conventions/).\n\nDeprecated: Use ResourceAttributes instead.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "backendRef" = mkOverride 1002 null;
        "backendRefs" = mkOverride 1002 null;
        "backendSettings" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "host" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "resourceAttributes" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef" =
      {

        options = {
          "group" = mkOption {
            description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
            type = (types.nullOr types.str);
          };
          "name" = mkOption {
            description = "Name is the name of the referent.";
            type = types.str;
          };
          "namespace" = mkOption {
            description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
            type = (types.nullOr types.str);
          };
          "port" = mkOption {
            description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "group" = mkOverride 1002 null;
          "kind" = mkOverride 1002 null;
          "namespace" = mkOverride 1002 null;
          "port" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs" =
      {

        options = {
          "fallback" = mkOption {
            description = "Fallback indicates whether the backend is designated as a fallback.\nMultiple fallback backends can be configured.\nIt is highly recommended to configure active or passive health checks to ensure that failover can be detected\nwhen the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.\nThe overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when\nthe health of the active backends falls below 72%.";
            type = (types.nullOr types.bool);
          };
          "group" = mkOption {
            description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
            type = (types.nullOr types.str);
          };
          "name" = mkOption {
            description = "Name is the name of the referent.";
            type = types.str;
          };
          "namespace" = mkOption {
            description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
            type = (types.nullOr types.str);
          };
          "port" = mkOption {
            description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
            type = (types.nullOr types.int);
          };
          "weight" = mkOption {
            description = "Weight specifies the proportion of requests forwarded to the referenced\nbackend. This is computed as weight/(sum of all weights in this\nBackendRefs list). For non-zero values, there may be some epsilon from\nthe exact proportion defined here depending on the precision an\nimplementation supports. Weight is not a percentage and the sum of\nweights does not need to equal 100.\n\nIf only one backend is specified and it has a weight greater than 0, 100%\nof the traffic is forwarded to that backend. If weight is set to 0, no\ntraffic should be forwarded for this entry. If unspecified, weight\ndefaults to 1.\n\nSupport for this field varies based on the context where used.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "fallback" = mkOverride 1002 null;
          "group" = mkOverride 1002 null;
          "kind" = mkOverride 1002 null;
          "namespace" = mkOverride 1002 null;
          "port" = mkOverride 1002 null;
          "weight" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings" =
      {

        options = {
          "circuitBreaker" = mkOption {
            description = "Circuit Breaker settings for the upstream connections and requests.\nIf not set, circuit breakers will be enabled with the default thresholds";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker"
              )
            );
          };
          "connection" = mkOption {
            description = "Connection includes backend connection settings.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection"
              )
            );
          };
          "dns" = mkOption {
            description = "DNS includes dns resolution settings.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns"
              )
            );
          };
          "healthCheck" = mkOption {
            description = "HealthCheck allows gateway to perform active health checking on backends.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck"
              )
            );
          };
          "http2" = mkOption {
            description = "HTTP2 provides HTTP/2 configuration for backend connections.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2"
              )
            );
          };
          "loadBalancer" = mkOption {
            description = "LoadBalancer policy to apply when routing traffic from the gateway to\nthe backend endpoints. Defaults to `LeastRequest`.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer"
              )
            );
          };
          "proxyProtocol" = mkOption {
            description = "ProxyProtocol enables the Proxy Protocol when communicating with the backend.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocol"
              )
            );
          };
          "retry" = mkOption {
            description = "Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.\nIf not set, retry will be disabled.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry"
              )
            );
          };
          "tcpKeepalive" = mkOption {
            description = "TcpKeepalive settings associated with the upstream client connection.\nDisabled by default.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive"
              )
            );
          };
          "timeout" = mkOption {
            description = "Timeout settings for the backend connections.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeout"
              )
            );
          };
        };

        config = {
          "circuitBreaker" = mkOverride 1002 null;
          "connection" = mkOverride 1002 null;
          "dns" = mkOverride 1002 null;
          "healthCheck" = mkOverride 1002 null;
          "http2" = mkOverride 1002 null;
          "loadBalancer" = mkOverride 1002 null;
          "proxyProtocol" = mkOverride 1002 null;
          "retry" = mkOverride 1002 null;
          "tcpKeepalive" = mkOverride 1002 null;
          "timeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxParallelRequests" = mkOption {
            description = "The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxParallelRetries" = mkOption {
            description = "The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxPendingRequests" = mkOption {
            description = "The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxRequestsPerConnection" = mkOption {
            description = "The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.\nDefault: unlimited.";
            type = (types.nullOr types.int);
          };
          "perEndpoint" = mkOption {
            description = "PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint"
              )
            );
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
          "maxParallelRequests" = mkOverride 1002 null;
          "maxParallelRetries" = mkOverride 1002 null;
          "maxPendingRequests" = mkOverride 1002 null;
          "maxRequestsPerConnection" = mkOverride 1002 null;
          "perEndpoint" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection" =
      {

        options = {
          "bufferLimit" = mkOption {
            description = "BufferLimit Soft limit on size of the cluster’s connections read and write buffers.\nBufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.\nIf unspecified, an implementation defined default is applied (32768 bytes).\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote: that when the suffix is not provided, the value is interpreted as bytes.";
            type = (types.nullOr (types.either types.int types.str));
          };
          "preconnect" = mkOption {
            description = "Preconnect configures proactive upstream connections to reduce latency by establishing\nconnections before they’re needed and avoiding connection establishment overhead.\n\nIf unset, Envoy will fetch connections as needed to serve in-flight requests.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionPreconnect"
              )
            );
          };
          "socketBufferLimit" = mkOption {
            description = "SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket\nto backend.\nSocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote that when the suffix is not provided, the value is interpreted as bytes.";
            type = (types.nullOr (types.either types.int types.str));
          };
        };

        config = {
          "bufferLimit" = mkOverride 1002 null;
          "preconnect" = mkOverride 1002 null;
          "socketBufferLimit" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionPreconnect" =
      {

        options = {
          "perEndpointPercent" = mkOption {
            description = "PerEndpointPercent configures how many additional connections to maintain per\nupstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a\npercentage of the connections required by active streams\n(e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).\n\nAllowed value range is between 100-300. When both PerEndpointPercent and\nPredictivePercent are set, Envoy ensures both are satisfied (max of the two).";
            type = (types.nullOr types.int);
          };
          "predictivePercent" = mkOption {
            description = "PredictivePercent configures how many additional connections to maintain\nacross the cluster by anticipating which upstream endpoint the load balancer\nwill select next, useful for low-QPS services. Relies on deterministic\nloadbalancing and is only supported with Random or RoundRobin.\nExpressed as a percentage of the connections required by active streams\n(e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).\n\nMinimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are\nset Envoy ensures both are satisfied per host (max of the two).";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "perEndpointPercent" = mkOverride 1002 null;
          "predictivePercent" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns" =
      {

        options = {
          "dnsRefreshRate" = mkOption {
            description = "DNSRefreshRate specifies the rate at which DNS records should be refreshed.\nDefaults to 30 seconds.";
            type = (types.nullOr types.str);
          };
          "lookupFamily" = mkOption {
            description = "LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).\nIf set, this configuration overrides other defaults.";
            type = (types.nullOr types.str);
          };
          "respectDnsTtl" = mkOption {
            description = "RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.\nIf the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.\nDefaults to true.";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "dnsRefreshRate" = mkOverride 1002 null;
          "lookupFamily" = mkOverride 1002 null;
          "respectDnsTtl" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck" =
      {

        options = {
          "active" = mkOption {
            description = "Active health check configuration";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive"
              )
            );
          };
          "panicThreshold" = mkOption {
            description = "When number of unhealthy endpoints for a backend reaches this threshold\nEnvoy will disregard health status and balance across all endpoints.\nIt's designed to prevent a situation in which host failures cascade throughout the cluster\nas load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.";
            type = (types.nullOr types.int);
          };
          "passive" = mkOption {
            description = "Passive passive check configuration";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive"
              )
            );
          };
        };

        config = {
          "active" = mkOverride 1002 null;
          "panicThreshold" = mkOverride 1002 null;
          "passive" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive" =
      {

        options = {
          "grpc" = mkOption {
            description = "GRPC defines the configuration of the GRPC health checker.\nIt's optional, and can only be used if the specified type is GRPC.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc"
              )
            );
          };
          "healthyThreshold" = mkOption {
            description = "HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.";
            type = (types.nullOr types.int);
          };
          "http" = mkOption {
            description = "HTTP defines the configuration of http health checker.\nIt's required while the health checker type is HTTP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp"
              )
            );
          };
          "initialJitter" = mkOption {
            description = "InitialJitter defines the maximum time Envoy will wait before the first health check.\nEnvoy will randomly select a value between 0 and the initial jitter value.";
            type = (types.nullOr types.str);
          };
          "interval" = mkOption {
            description = "Interval defines the time between active health checks.";
            type = (types.nullOr types.str);
          };
          "tcp" = mkOption {
            description = "TCP defines the configuration of tcp health checker.\nIt's required while the health checker type is TCP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp"
              )
            );
          };
          "timeout" = mkOption {
            description = "Timeout defines the time to wait for a health check response.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of health checker.";
            type = types.str;
          };
          "unhealthyThreshold" = mkOption {
            description = "UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "grpc" = mkOverride 1002 null;
          "healthyThreshold" = mkOverride 1002 null;
          "http" = mkOverride 1002 null;
          "initialJitter" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "tcp" = mkOverride 1002 null;
          "timeout" = mkOverride 1002 null;
          "unhealthyThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc" =
      {

        options = {
          "service" = mkOption {
            description = "Service to send in the health check request.\nIf this is not specified, then the health check request applies to the entire\nserver and not to a specific service.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "service" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp" =
      {

        options = {
          "expectedResponse" = mkOption {
            description = "ExpectedResponse defines a list of HTTP expected responses to match.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse"
              )
            );
          };
          "expectedStatuses" = mkOption {
            description = "ExpectedStatuses defines a list of HTTP response statuses considered healthy.\nDefaults to 200 only";
            type = (types.nullOr (types.listOf types.int));
          };
          "hostname" = mkOption {
            description = "Hostname defines the HTTP host that will be requested during health checking.\nDefault: HTTPRoute or GRPCRoute hostname.";
            type = (types.nullOr types.str);
          };
          "method" = mkOption {
            description = "Method defines the HTTP method used for health checking.\nDefaults to GET";
            type = (types.nullOr types.str);
          };
          "path" = mkOption {
            description = "Path defines the HTTP path that will be requested during health checking.";
            type = types.str;
          };
        };

        config = {
          "expectedResponse" = mkOverride 1002 null;
          "expectedStatuses" = mkOverride 1002 null;
          "hostname" = mkOverride 1002 null;
          "method" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp" =
      {

        options = {
          "receive" = mkOption {
            description = "Receive defines the expected response payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive"
              )
            );
          };
          "send" = mkOption {
            description = "Send defines the request payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend"
              )
            );
          };
        };

        config = {
          "receive" = mkOverride 1002 null;
          "send" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive" =
      {

        options = {
          "baseEjectionTime" = mkOption {
            description = "BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.";
            type = (types.nullOr types.str);
          };
          "consecutive5XxErrors" = mkOption {
            description = "Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.";
            type = (types.nullOr types.int);
          };
          "consecutiveGatewayErrors" = mkOption {
            description = "ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.";
            type = (types.nullOr types.int);
          };
          "consecutiveLocalOriginFailures" = mkOption {
            description = "ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.\nParameter takes effect only when split_external_local_origin_errors is set to true.";
            type = (types.nullOr types.int);
          };
          "failurePercentageThreshold" = mkOption {
            description = "FailurePercentageThreshold sets the failure percentage threshold for outlier detection.\nIf the failure percentage of a given host is greater than or equal to this value, it will be ejected.\nDefaults to 85.";
            type = (types.nullOr types.int);
          };
          "interval" = mkOption {
            description = "Interval defines the time between passive health checks.";
            type = (types.nullOr types.str);
          };
          "maxEjectionPercent" = mkOption {
            description = "MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.";
            type = (types.nullOr types.int);
          };
          "splitExternalLocalOriginErrors" = mkOption {
            description = "SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "baseEjectionTime" = mkOverride 1002 null;
          "consecutive5XxErrors" = mkOverride 1002 null;
          "consecutiveGatewayErrors" = mkOverride 1002 null;
          "consecutiveLocalOriginFailures" = mkOverride 1002 null;
          "failurePercentageThreshold" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "maxEjectionPercent" = mkOverride 1002 null;
          "splitExternalLocalOriginErrors" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2" =
      {

        options = {
          "initialConnectionWindowSize" = mkOption {
            description = "InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.\nIf not set, the default value is 1 MiB.";
            type = (types.nullOr (types.either types.int types.str));
          };
          "initialStreamWindowSize" = mkOption {
            description = "InitialStreamWindowSize sets the initial window size for HTTP/2 streams.\nIf not set, the default value is 64 KiB(64*1024).";
            type = (types.nullOr (types.either types.int types.str));
          };
          "maxConcurrentStreams" = mkOption {
            description = "MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.\nIf not set, the default value is 100.";
            type = (types.nullOr types.int);
          };
          "onInvalidMessage" = mkOption {
            description = "OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error\nIt's recommended for L2 Envoy deployments to set this value to TerminateStream.\nhttps://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two\nDefault: TerminateConnection";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "initialConnectionWindowSize" = mkOverride 1002 null;
          "initialStreamWindowSize" = mkOverride 1002 null;
          "maxConcurrentStreams" = mkOverride 1002 null;
          "onInvalidMessage" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer" =
      {

        options = {
          "consistentHash" = mkOption {
            description = "ConsistentHash defines the configuration when the load balancer type is\nset to ConsistentHash";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash"
              )
            );
          };
          "endpointOverride" = mkOption {
            description = "EndpointOverride defines the configuration for endpoint override.\nWhen specified, the load balancer will attempt to route requests to endpoints\nbased on the override information extracted from request headers or metadata.\n If the override endpoints are not available, the configured load balancer policy will be used as fallback.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride"
              )
            );
          };
          "slowStart" = mkOption {
            description = "SlowStart defines the configuration related to the slow start load balancer policy.\nIf set, during slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently this is only supported for RoundRobin and LeastRequest load balancers";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart"
              )
            );
          };
          "type" = mkOption {
            description = "Type decides the type of Load Balancer policy.\nValid LoadBalancerType values are\n\"ConsistentHash\",\n\"LeastRequest\",\n\"Random\",\n\"RoundRobin\".";
            type = types.str;
          };
          "zoneAware" = mkOption {
            description = "ZoneAware defines the configuration related to the distribution of requests between locality zones.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware"
              )
            );
          };
        };

        config = {
          "consistentHash" = mkOverride 1002 null;
          "endpointOverride" = mkOverride 1002 null;
          "slowStart" = mkOverride 1002 null;
          "zoneAware" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash" =
      {

        options = {
          "cookie" = mkOption {
            description = "Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie"
              )
            );
          };
          "header" = mkOption {
            description = "Header configures the header hash policy when the consistent hash type is set to Header.\n\nDeprecated: use Headers instead";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader"
              )
            );
          };
          "headers" = mkOption {
            description = "Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "queryParams" = mkOption {
            description = "QueryParams configures the query parameter hash policy when the consistent hash type is set to QueryParams.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashQueryParams"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "tableSize" = mkOption {
            description = "The table size for consistent hashing, must be prime number limited to 5000011.";
            type = (types.nullOr types.int);
          };
          "type" = mkOption {
            description = "ConsistentHashType defines the type of input to hash on. Valid Type values are\n\"SourceIP\",\n\"Header\",\n\"Headers\",\n\"Cookie\".\n\"QueryParams\".";
            type = types.str;
          };
        };

        config = {
          "cookie" = mkOverride 1002 null;
          "header" = mkOverride 1002 null;
          "headers" = mkOverride 1002 null;
          "queryParams" = mkOverride 1002 null;
          "tableSize" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie" =
      {

        options = {
          "attributes" = mkOption {
            description = "Additional Attributes to set for the generated cookie.";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "name" = mkOption {
            description = "Name of the cookie to hash.\nIf this cookie does not exist in the request, Envoy will generate a cookie and set\nthe TTL on the response back to the client based on Layer 4\nattributes of the backend endpoint, to ensure that these future requests\ngo to the same backend endpoint. Make sure to set the TTL field for this case.";
            type = types.str;
          };
          "ttl" = mkOption {
            description = "TTL of the generated cookie if the cookie is not present. This value sets the\nMax-Age attribute value.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "attributes" = mkOverride 1002 null;
          "ttl" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashQueryParams" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the query param to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride" =
      {

        options = {
          "extractFrom" = mkOption {
            description = "ExtractFrom defines the sources to extract endpoint override information from.";
            type = (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom"
              )
            );
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom" =
      {

        options = {
          "header" = mkOption {
            description = "Header defines the header to get the override endpoint addresses.\nThe header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.\nFor example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.\nThe IPv6 address is enclosed in square brackets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "header" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart" =
      {

        options = {
          "window" = mkOption {
            description = "Window defines the duration of the warm up period for newly added host.\nDuring slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently only supports linear growth of traffic. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware" =
      {

        options = {
          "preferLocal" = mkOption {
            description = "PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal"
              )
            );
          };
        };

        config = {
          "preferLocal" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal" =
      {

        options = {
          "force" = mkOption {
            description = "ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior\nwhich maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce"
              )
            );
          };
          "minEndpointsThreshold" = mkOption {
            description = "MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.";
            type = (types.nullOr types.int);
          };
          "percentageEnabled" = mkOption {
            description = "Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "force" = mkOverride 1002 null;
          "minEndpointsThreshold" = mkOverride 1002 null;
          "percentageEnabled" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce" =
      {

        options = {
          "minEndpointsInZoneThreshold" = mkOption {
            description = "MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone\noverride. This is useful for protecting zones with fewer endpoints.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "minEndpointsInZoneThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocol" =
      {

        options = {
          "version" = mkOption {
            description = "Version of ProxyProtol\nValid ProxyProtocolVersion values are\n\"V1\"\n\"V2\"";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry" =
      {

        options = {
          "numAttemptsPerPriority" = mkOption {
            description = "NumAttemptsPerPriority defines the number of requests (initial attempt + retries)\nthat should be sent to the same priority before switching to a different one.\nIf not specified or set to 0, all requests are sent to the highest priority that is healthy.";
            type = (types.nullOr types.int);
          };
          "numRetries" = mkOption {
            description = "NumRetries is the number of retries to be attempted. Defaults to 2.";
            type = (types.nullOr types.int);
          };
          "perRetry" = mkOption {
            description = "PerRetry is the retry policy to be applied per retry attempt.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetry"
              )
            );
          };
          "retryOn" = mkOption {
            description = "RetryOn specifies the retry trigger condition.\n\nIf not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOn"
              )
            );
          };
        };

        config = {
          "numAttemptsPerPriority" = mkOverride 1002 null;
          "numRetries" = mkOverride 1002 null;
          "perRetry" = mkOverride 1002 null;
          "retryOn" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetry" =
      {

        options = {
          "backOff" = mkOption {
            description = "Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential\nback-off algorithm for retries. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff"
              )
            );
          };
          "timeout" = mkOption {
            description = "Timeout is the timeout per retry attempt.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "backOff" = mkOverride 1002 null;
          "timeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff" =
      {

        options = {
          "baseInterval" = mkOption {
            description = "BaseInterval is the base interval between retries.";
            type = (types.nullOr types.str);
          };
          "maxInterval" = mkOption {
            description = "MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.\nThe default is 10 times the base_interval";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "baseInterval" = mkOverride 1002 null;
          "maxInterval" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOn" =
      {

        options = {
          "httpStatusCodes" = mkOption {
            description = "HttpStatusCodes specifies the http status codes to be retried.\nThe retriable-status-codes trigger must also be configured for these status codes to trigger a retry.";
            type = (types.nullOr (types.listOf types.int));
          };
          "triggers" = mkOption {
            description = "Triggers specifies the retry trigger condition(Http/Grpc).";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "httpStatusCodes" = mkOverride 1002 null;
          "triggers" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive" =
      {

        options = {
          "idleTime" = mkOption {
            description = "The duration a connection needs to be idle before keep-alive\nprobes start being sent.\nThe duration format is\nDefaults to `7200s`.";
            type = (types.nullOr types.str);
          };
          "interval" = mkOption {
            description = "The duration between keep-alive probes.\nDefaults to `75s`.";
            type = (types.nullOr types.str);
          };
          "probes" = mkOption {
            description = "The total number of unacknowledged probes to send before deciding\nthe connection is dead.\nDefaults to 9.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "idleTime" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "probes" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeout" =
      {

        options = {
          "http" = mkOption {
            description = "Timeout settings for HTTP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp"
              )
            );
          };
          "tcp" = mkOption {
            description = "Timeout settings for TCP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcp"
              )
            );
          };
        };

        config = {
          "http" = mkOverride 1002 null;
          "tcp" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp" =
      {

        options = {
          "connectionIdleTimeout" = mkOption {
            description = "The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.\nDefault: 1 hour.";
            type = (types.nullOr types.str);
          };
          "maxConnectionDuration" = mkOption {
            description = "The maximum duration of an HTTP connection.\nDefault: unlimited.";
            type = (types.nullOr types.str);
          };
          "maxStreamDuration" = mkOption {
            description = "MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time\nfrom when the request is sent until the response stream is fully consumed and does not apply to\nnon-streaming requests.\nWhen set to \"0s\", no max duration is applied and streams can run indefinitely.";
            type = (types.nullOr types.str);
          };
          "requestTimeout" = mkOption {
            description = "RequestTimeout is the time until which entire response is received from the upstream.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "connectionIdleTimeout" = mkOverride 1002 null;
          "maxConnectionDuration" = mkOverride 1002 null;
          "maxStreamDuration" = mkOverride 1002 null;
          "requestTimeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcp" =
      {

        options = {
          "connectTimeout" = mkOption {
            description = "The timeout for network connection establishment, including TCP and TLS handshakes.\nDefault: 10 seconds.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "connectTimeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "Name is the name of the HTTP Header to be matched. Name matching MUST be\ncase-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).\n\nIf multiple entries specify equivalent header names, the first entry with\nan equivalent name MUST be considered for a match. Subsequent entries\nwith an equivalent header name MUST be ignored. Due to the\ncase-insensitivity of header names, \"foo\" and \"Foo\" are considered\nequivalent.";
            type = types.str;
          };
          "value" = mkOption {
            description = "Value is the value of HTTP Header to be matched.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetrics" = {

      options = {
        "clusterStatName" = mkOption {
          description = "ClusterStatName defines the value of cluster alt_stat_name, determining how cluster stats are named.\nFor more details, see envoy docs: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html\nThe supported operators for this pattern are:\n`%ROUTE_NAME%`: name of Gateway API xRoute resource\n`%ROUTE_NAMESPACE%`: namespace of Gateway API xRoute resource\n`%ROUTE_KIND%`: kind of Gateway API xRoute resource\n`%ROUTE_RULE_NAME%`: name of the Gateway API xRoute section\n`%ROUTE_RULE_NUMBER%`: name of the Gateway API xRoute section\n`%BACKEND_REFS%`: names of all backends referenced in `<NAMESPACE>/<NAME>|<NAMESPACE>/<NAME>|...` format\nOnly xDS Clusters created for HTTPRoute and GRPCRoute are currently supported.\nDefault: `%ROUTE_KIND%/%ROUTE_NAMESPACE%/%ROUTE_NAME%/rule/%ROUTE_RULE_NUMBER%`\nExample: `httproute/my-ns/my-route/rule/0`";
          type = (types.nullOr types.str);
        };
        "enablePerEndpointStats" = mkOption {
          description = "EnablePerEndpointStats enables per endpoint envoy stats metrics.\nPlease use with caution.";
          type = (types.nullOr types.bool);
        };
        "enableRequestResponseSizesStats" = mkOption {
          description = "EnableRequestResponseSizesStats enables publishing of histograms tracking header and body sizes of requests and responses.";
          type = (types.nullOr types.bool);
        };
        "enableVirtualHostStats" = mkOption {
          description = "EnableVirtualHostStats enables envoy stat metrics for virtual hosts.";
          type = (types.nullOr types.bool);
        };
        "matches" = mkOption {
          description = "Matches defines configuration for selecting specific metrics instead of generating all metrics stats\nthat are enabled by default. This helps reduce CPU and memory overhead in Envoy, but eliminating some stats\nmay after critical functionality. Here are the stats that we strongly recommend not disabling:\n`cluster_manager.warming_clusters`, `cluster.<cluster_name>.membership_total`,`cluster.<cluster_name>.membership_healthy`,\n`cluster.<cluster_name>.membership_degraded`，reference  https://github.com/envoyproxy/envoy/issues/9856,\nhttps://github.com/envoyproxy/envoy/issues/14610";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsMatches")
            )
          );
        };
        "prometheus" = mkOption {
          description = "Prometheus defines the configuration for Admin endpoint `/stats/prometheus`.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsPrometheus")
          );
        };
        "sinks" = mkOption {
          description = "Sinks defines the metric sinks where metrics are sent to.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinks")
            )
          );
        };
      };

      config = {
        "clusterStatName" = mkOverride 1002 null;
        "enablePerEndpointStats" = mkOverride 1002 null;
        "enableRequestResponseSizesStats" = mkOverride 1002 null;
        "enableVirtualHostStats" = mkOverride 1002 null;
        "matches" = mkOverride 1002 null;
        "prometheus" = mkOverride 1002 null;
        "sinks" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsMatches" = {

      options = {
        "type" = mkOption {
          description = "Type specifies how to match against a string.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value specifies the string value that the match must have.";
          type = types.str;
        };
      };

      config = {
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsPrometheus" = {

      options = {
        "compression" = mkOption {
          description = "Configure the compression on Prometheus endpoint. Compression is useful in situations when bandwidth is scarce and large payloads can be effectively compressed at the expense of higher CPU load.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsPrometheusCompression"
            )
          );
        };
        "disable" = mkOption {
          description = "Disable the Prometheus endpoint.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "compression" = mkOverride 1002 null;
        "disable" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsPrometheusCompression" = {

      options = {
        "brotli" = mkOption {
          description = "The configuration for Brotli compressor.";
          type = (types.nullOr types.attrs);
        };
        "gzip" = mkOption {
          description = "The configuration for GZIP compressor.";
          type = (types.nullOr types.attrs);
        };
        "minContentLength" = mkOption {
          description = "MinContentLength defines the minimum response size in bytes to apply compression.\nResponses smaller than this threshold will not be compressed.\nMust be at least 30 bytes as enforced by Envoy Proxy.\nNote that when the suffix is not provided, the value is interpreted as bytes.\nDefault: 30 bytes";
          type = (types.nullOr (types.either types.int types.str));
        };
        "type" = mkOption {
          description = "CompressorType defines the compressor type to use for compression.";
          type = types.str;
        };
        "zstd" = mkOption {
          description = "The configuration for Zstd compressor.";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "brotli" = mkOverride 1002 null;
        "gzip" = mkOverride 1002 null;
        "minContentLength" = mkOverride 1002 null;
        "zstd" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinks" = {

      options = {
        "openTelemetry" = mkOption {
          description = "OpenTelemetry defines the configuration for OpenTelemetry sink.\nIt's required if the sink type is OpenTelemetry.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry"
            )
          );
        };
        "type" = mkOption {
          description = "Type defines the metric sink type.\nEG currently only supports OpenTelemetry.";
          type = types.str;
        };
      };

      config = {
        "openTelemetry" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry" = {

      options = {
        "backendRef" = mkOption {
          description = "BackendRef references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.\n\nDeprecated: Use BackendRefs instead.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef"
            )
          );
        };
        "backendRefs" = mkOption {
          description = "BackendRefs references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "backendSettings" = mkOption {
          description = "BackendSettings holds configuration for managing the connection\nto the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings"
            )
          );
        };
        "headers" = mkOption {
          description = "Headers is a list of additional headers to send with OTLP export requests.\nThese headers are added as gRPC initial metadata for the OTLP gRPC service.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryHeaders"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "host" = mkOption {
          description = "Host define the service hostname.\nDeprecated: Use BackendRefs instead.";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port defines the port the service is exposed on.\nDeprecated: Use BackendRefs instead.";
          type = (types.nullOr types.int);
        };
        "reportCountersAsDeltas" = mkOption {
          description = "ReportCountersAsDeltas configures the OpenTelemetry sink to report\ncounters as delta temporality instead of cumulative.";
          type = (types.nullOr types.bool);
        };
        "reportHistogramsAsDeltas" = mkOption {
          description = "ReportHistogramsAsDeltas configures the OpenTelemetry sink to report\nhistograms as delta temporality instead of cumulative.\nRequired for backends like Elastic that drop cumulative histograms.";
          type = (types.nullOr types.bool);
        };
        "resourceAttributes" = mkOption {
          description = "ResourceAttributes is a set of labels that describe the source of metrics.\nIt's recommended to follow semantic conventions: https://opentelemetry.io/docs/reference/specification/resource/semantic_conventions/";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "backendRef" = mkOverride 1002 null;
        "backendRefs" = mkOverride 1002 null;
        "backendSettings" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "host" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "reportCountersAsDeltas" = mkOverride 1002 null;
        "reportHistogramsAsDeltas" = mkOverride 1002 null;
        "resourceAttributes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs" = {

      options = {
        "fallback" = mkOption {
          description = "Fallback indicates whether the backend is designated as a fallback.\nMultiple fallback backends can be configured.\nIt is highly recommended to configure active or passive health checks to ensure that failover can be detected\nwhen the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.\nThe overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when\nthe health of the active backends falls below 72%.";
          type = (types.nullOr types.bool);
        };
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
        "weight" = mkOption {
          description = "Weight specifies the proportion of requests forwarded to the referenced\nbackend. This is computed as weight/(sum of all weights in this\nBackendRefs list). For non-zero values, there may be some epsilon from\nthe exact proportion defined here depending on the precision an\nimplementation supports. Weight is not a percentage and the sum of\nweights does not need to equal 100.\n\nIf only one backend is specified and it has a weight greater than 0, 100%\nof the traffic is forwarded to that backend. If weight is set to 0, no\ntraffic should be forwarded for this entry. If unspecified, weight\ndefaults to 1.\n\nSupport for this field varies based on the context where used.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "fallback" = mkOverride 1002 null;
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "weight" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings" = {

      options = {
        "circuitBreaker" = mkOption {
          description = "Circuit Breaker settings for the upstream connections and requests.\nIf not set, circuit breakers will be enabled with the default thresholds";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker"
            )
          );
        };
        "connection" = mkOption {
          description = "Connection includes backend connection settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection"
            )
          );
        };
        "dns" = mkOption {
          description = "DNS includes dns resolution settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns"
            )
          );
        };
        "healthCheck" = mkOption {
          description = "HealthCheck allows gateway to perform active health checking on backends.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck"
            )
          );
        };
        "http2" = mkOption {
          description = "HTTP2 provides HTTP/2 configuration for backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2"
            )
          );
        };
        "loadBalancer" = mkOption {
          description = "LoadBalancer policy to apply when routing traffic from the gateway to\nthe backend endpoints. Defaults to `LeastRequest`.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer"
            )
          );
        };
        "proxyProtocol" = mkOption {
          description = "ProxyProtocol enables the Proxy Protocol when communicating with the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocol"
            )
          );
        };
        "retry" = mkOption {
          description = "Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.\nIf not set, retry will be disabled.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry"
            )
          );
        };
        "tcpKeepalive" = mkOption {
          description = "TcpKeepalive settings associated with the upstream client connection.\nDisabled by default.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout settings for the backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeout"
            )
          );
        };
      };

      config = {
        "circuitBreaker" = mkOverride 1002 null;
        "connection" = mkOverride 1002 null;
        "dns" = mkOverride 1002 null;
        "healthCheck" = mkOverride 1002 null;
        "http2" = mkOverride 1002 null;
        "loadBalancer" = mkOverride 1002 null;
        "proxyProtocol" = mkOverride 1002 null;
        "retry" = mkOverride 1002 null;
        "tcpKeepalive" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxParallelRequests" = mkOption {
            description = "The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxParallelRetries" = mkOption {
            description = "The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxPendingRequests" = mkOption {
            description = "The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxRequestsPerConnection" = mkOption {
            description = "The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.\nDefault: unlimited.";
            type = (types.nullOr types.int);
          };
          "perEndpoint" = mkOption {
            description = "PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint"
              )
            );
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
          "maxParallelRequests" = mkOverride 1002 null;
          "maxParallelRetries" = mkOverride 1002 null;
          "maxPendingRequests" = mkOverride 1002 null;
          "maxRequestsPerConnection" = mkOverride 1002 null;
          "perEndpoint" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection" =
      {

        options = {
          "bufferLimit" = mkOption {
            description = "BufferLimit Soft limit on size of the cluster’s connections read and write buffers.\nBufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.\nIf unspecified, an implementation defined default is applied (32768 bytes).\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote: that when the suffix is not provided, the value is interpreted as bytes.";
            type = (types.nullOr (types.either types.int types.str));
          };
          "preconnect" = mkOption {
            description = "Preconnect configures proactive upstream connections to reduce latency by establishing\nconnections before they’re needed and avoiding connection establishment overhead.\n\nIf unset, Envoy will fetch connections as needed to serve in-flight requests.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionPreconnect"
              )
            );
          };
          "socketBufferLimit" = mkOption {
            description = "SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket\nto backend.\nSocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote that when the suffix is not provided, the value is interpreted as bytes.";
            type = (types.nullOr (types.either types.int types.str));
          };
        };

        config = {
          "bufferLimit" = mkOverride 1002 null;
          "preconnect" = mkOverride 1002 null;
          "socketBufferLimit" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionPreconnect" =
      {

        options = {
          "perEndpointPercent" = mkOption {
            description = "PerEndpointPercent configures how many additional connections to maintain per\nupstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a\npercentage of the connections required by active streams\n(e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).\n\nAllowed value range is between 100-300. When both PerEndpointPercent and\nPredictivePercent are set, Envoy ensures both are satisfied (max of the two).";
            type = (types.nullOr types.int);
          };
          "predictivePercent" = mkOption {
            description = "PredictivePercent configures how many additional connections to maintain\nacross the cluster by anticipating which upstream endpoint the load balancer\nwill select next, useful for low-QPS services. Relies on deterministic\nloadbalancing and is only supported with Random or RoundRobin.\nExpressed as a percentage of the connections required by active streams\n(e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).\n\nMinimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are\nset Envoy ensures both are satisfied per host (max of the two).";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "perEndpointPercent" = mkOverride 1002 null;
          "predictivePercent" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns" =
      {

        options = {
          "dnsRefreshRate" = mkOption {
            description = "DNSRefreshRate specifies the rate at which DNS records should be refreshed.\nDefaults to 30 seconds.";
            type = (types.nullOr types.str);
          };
          "lookupFamily" = mkOption {
            description = "LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).\nIf set, this configuration overrides other defaults.";
            type = (types.nullOr types.str);
          };
          "respectDnsTtl" = mkOption {
            description = "RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.\nIf the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.\nDefaults to true.";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "dnsRefreshRate" = mkOverride 1002 null;
          "lookupFamily" = mkOverride 1002 null;
          "respectDnsTtl" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck" =
      {

        options = {
          "active" = mkOption {
            description = "Active health check configuration";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive"
              )
            );
          };
          "panicThreshold" = mkOption {
            description = "When number of unhealthy endpoints for a backend reaches this threshold\nEnvoy will disregard health status and balance across all endpoints.\nIt's designed to prevent a situation in which host failures cascade throughout the cluster\nas load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.";
            type = (types.nullOr types.int);
          };
          "passive" = mkOption {
            description = "Passive passive check configuration";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive"
              )
            );
          };
        };

        config = {
          "active" = mkOverride 1002 null;
          "panicThreshold" = mkOverride 1002 null;
          "passive" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive" =
      {

        options = {
          "grpc" = mkOption {
            description = "GRPC defines the configuration of the GRPC health checker.\nIt's optional, and can only be used if the specified type is GRPC.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc"
              )
            );
          };
          "healthyThreshold" = mkOption {
            description = "HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.";
            type = (types.nullOr types.int);
          };
          "http" = mkOption {
            description = "HTTP defines the configuration of http health checker.\nIt's required while the health checker type is HTTP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp"
              )
            );
          };
          "initialJitter" = mkOption {
            description = "InitialJitter defines the maximum time Envoy will wait before the first health check.\nEnvoy will randomly select a value between 0 and the initial jitter value.";
            type = (types.nullOr types.str);
          };
          "interval" = mkOption {
            description = "Interval defines the time between active health checks.";
            type = (types.nullOr types.str);
          };
          "tcp" = mkOption {
            description = "TCP defines the configuration of tcp health checker.\nIt's required while the health checker type is TCP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp"
              )
            );
          };
          "timeout" = mkOption {
            description = "Timeout defines the time to wait for a health check response.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of health checker.";
            type = types.str;
          };
          "unhealthyThreshold" = mkOption {
            description = "UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "grpc" = mkOverride 1002 null;
          "healthyThreshold" = mkOverride 1002 null;
          "http" = mkOverride 1002 null;
          "initialJitter" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "tcp" = mkOverride 1002 null;
          "timeout" = mkOverride 1002 null;
          "unhealthyThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc" =
      {

        options = {
          "service" = mkOption {
            description = "Service to send in the health check request.\nIf this is not specified, then the health check request applies to the entire\nserver and not to a specific service.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "service" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp" =
      {

        options = {
          "expectedResponse" = mkOption {
            description = "ExpectedResponse defines a list of HTTP expected responses to match.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse"
              )
            );
          };
          "expectedStatuses" = mkOption {
            description = "ExpectedStatuses defines a list of HTTP response statuses considered healthy.\nDefaults to 200 only";
            type = (types.nullOr (types.listOf types.int));
          };
          "hostname" = mkOption {
            description = "Hostname defines the HTTP host that will be requested during health checking.\nDefault: HTTPRoute or GRPCRoute hostname.";
            type = (types.nullOr types.str);
          };
          "method" = mkOption {
            description = "Method defines the HTTP method used for health checking.\nDefaults to GET";
            type = (types.nullOr types.str);
          };
          "path" = mkOption {
            description = "Path defines the HTTP path that will be requested during health checking.";
            type = types.str;
          };
        };

        config = {
          "expectedResponse" = mkOverride 1002 null;
          "expectedStatuses" = mkOverride 1002 null;
          "hostname" = mkOverride 1002 null;
          "method" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp" =
      {

        options = {
          "receive" = mkOption {
            description = "Receive defines the expected response payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive"
              )
            );
          };
          "send" = mkOption {
            description = "Send defines the request payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend"
              )
            );
          };
        };

        config = {
          "receive" = mkOverride 1002 null;
          "send" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive" =
      {

        options = {
          "baseEjectionTime" = mkOption {
            description = "BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.";
            type = (types.nullOr types.str);
          };
          "consecutive5XxErrors" = mkOption {
            description = "Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.";
            type = (types.nullOr types.int);
          };
          "consecutiveGatewayErrors" = mkOption {
            description = "ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.";
            type = (types.nullOr types.int);
          };
          "consecutiveLocalOriginFailures" = mkOption {
            description = "ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.\nParameter takes effect only when split_external_local_origin_errors is set to true.";
            type = (types.nullOr types.int);
          };
          "failurePercentageThreshold" = mkOption {
            description = "FailurePercentageThreshold sets the failure percentage threshold for outlier detection.\nIf the failure percentage of a given host is greater than or equal to this value, it will be ejected.\nDefaults to 85.";
            type = (types.nullOr types.int);
          };
          "interval" = mkOption {
            description = "Interval defines the time between passive health checks.";
            type = (types.nullOr types.str);
          };
          "maxEjectionPercent" = mkOption {
            description = "MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.";
            type = (types.nullOr types.int);
          };
          "splitExternalLocalOriginErrors" = mkOption {
            description = "SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "baseEjectionTime" = mkOverride 1002 null;
          "consecutive5XxErrors" = mkOverride 1002 null;
          "consecutiveGatewayErrors" = mkOverride 1002 null;
          "consecutiveLocalOriginFailures" = mkOverride 1002 null;
          "failurePercentageThreshold" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "maxEjectionPercent" = mkOverride 1002 null;
          "splitExternalLocalOriginErrors" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2" =
      {

        options = {
          "initialConnectionWindowSize" = mkOption {
            description = "InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.\nIf not set, the default value is 1 MiB.";
            type = (types.nullOr (types.either types.int types.str));
          };
          "initialStreamWindowSize" = mkOption {
            description = "InitialStreamWindowSize sets the initial window size for HTTP/2 streams.\nIf not set, the default value is 64 KiB(64*1024).";
            type = (types.nullOr (types.either types.int types.str));
          };
          "maxConcurrentStreams" = mkOption {
            description = "MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.\nIf not set, the default value is 100.";
            type = (types.nullOr types.int);
          };
          "onInvalidMessage" = mkOption {
            description = "OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error\nIt's recommended for L2 Envoy deployments to set this value to TerminateStream.\nhttps://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two\nDefault: TerminateConnection";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "initialConnectionWindowSize" = mkOverride 1002 null;
          "initialStreamWindowSize" = mkOverride 1002 null;
          "maxConcurrentStreams" = mkOverride 1002 null;
          "onInvalidMessage" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer" =
      {

        options = {
          "consistentHash" = mkOption {
            description = "ConsistentHash defines the configuration when the load balancer type is\nset to ConsistentHash";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash"
              )
            );
          };
          "endpointOverride" = mkOption {
            description = "EndpointOverride defines the configuration for endpoint override.\nWhen specified, the load balancer will attempt to route requests to endpoints\nbased on the override information extracted from request headers or metadata.\n If the override endpoints are not available, the configured load balancer policy will be used as fallback.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride"
              )
            );
          };
          "slowStart" = mkOption {
            description = "SlowStart defines the configuration related to the slow start load balancer policy.\nIf set, during slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently this is only supported for RoundRobin and LeastRequest load balancers";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart"
              )
            );
          };
          "type" = mkOption {
            description = "Type decides the type of Load Balancer policy.\nValid LoadBalancerType values are\n\"ConsistentHash\",\n\"LeastRequest\",\n\"Random\",\n\"RoundRobin\".";
            type = types.str;
          };
          "zoneAware" = mkOption {
            description = "ZoneAware defines the configuration related to the distribution of requests between locality zones.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware"
              )
            );
          };
        };

        config = {
          "consistentHash" = mkOverride 1002 null;
          "endpointOverride" = mkOverride 1002 null;
          "slowStart" = mkOverride 1002 null;
          "zoneAware" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash" =
      {

        options = {
          "cookie" = mkOption {
            description = "Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie"
              )
            );
          };
          "header" = mkOption {
            description = "Header configures the header hash policy when the consistent hash type is set to Header.\n\nDeprecated: use Headers instead";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader"
              )
            );
          };
          "headers" = mkOption {
            description = "Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "queryParams" = mkOption {
            description = "QueryParams configures the query parameter hash policy when the consistent hash type is set to QueryParams.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashQueryParams"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "tableSize" = mkOption {
            description = "The table size for consistent hashing, must be prime number limited to 5000011.";
            type = (types.nullOr types.int);
          };
          "type" = mkOption {
            description = "ConsistentHashType defines the type of input to hash on. Valid Type values are\n\"SourceIP\",\n\"Header\",\n\"Headers\",\n\"Cookie\".\n\"QueryParams\".";
            type = types.str;
          };
        };

        config = {
          "cookie" = mkOverride 1002 null;
          "header" = mkOverride 1002 null;
          "headers" = mkOverride 1002 null;
          "queryParams" = mkOverride 1002 null;
          "tableSize" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie" =
      {

        options = {
          "attributes" = mkOption {
            description = "Additional Attributes to set for the generated cookie.";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "name" = mkOption {
            description = "Name of the cookie to hash.\nIf this cookie does not exist in the request, Envoy will generate a cookie and set\nthe TTL on the response back to the client based on Layer 4\nattributes of the backend endpoint, to ensure that these future requests\ngo to the same backend endpoint. Make sure to set the TTL field for this case.";
            type = types.str;
          };
          "ttl" = mkOption {
            description = "TTL of the generated cookie if the cookie is not present. This value sets the\nMax-Age attribute value.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "attributes" = mkOverride 1002 null;
          "ttl" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashQueryParams" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the query param to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride" =
      {

        options = {
          "extractFrom" = mkOption {
            description = "ExtractFrom defines the sources to extract endpoint override information from.";
            type = (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom"
              )
            );
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom" =
      {

        options = {
          "header" = mkOption {
            description = "Header defines the header to get the override endpoint addresses.\nThe header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.\nFor example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.\nThe IPv6 address is enclosed in square brackets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "header" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart" =
      {

        options = {
          "window" = mkOption {
            description = "Window defines the duration of the warm up period for newly added host.\nDuring slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently only supports linear growth of traffic. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware" =
      {

        options = {
          "preferLocal" = mkOption {
            description = "PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal"
              )
            );
          };
        };

        config = {
          "preferLocal" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal" =
      {

        options = {
          "force" = mkOption {
            description = "ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior\nwhich maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce"
              )
            );
          };
          "minEndpointsThreshold" = mkOption {
            description = "MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.";
            type = (types.nullOr types.int);
          };
          "percentageEnabled" = mkOption {
            description = "Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "force" = mkOverride 1002 null;
          "minEndpointsThreshold" = mkOverride 1002 null;
          "percentageEnabled" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce" =
      {

        options = {
          "minEndpointsInZoneThreshold" = mkOption {
            description = "MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone\noverride. This is useful for protecting zones with fewer endpoints.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "minEndpointsInZoneThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocol" =
      {

        options = {
          "version" = mkOption {
            description = "Version of ProxyProtol\nValid ProxyProtocolVersion values are\n\"V1\"\n\"V2\"";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry" =
      {

        options = {
          "numAttemptsPerPriority" = mkOption {
            description = "NumAttemptsPerPriority defines the number of requests (initial attempt + retries)\nthat should be sent to the same priority before switching to a different one.\nIf not specified or set to 0, all requests are sent to the highest priority that is healthy.";
            type = (types.nullOr types.int);
          };
          "numRetries" = mkOption {
            description = "NumRetries is the number of retries to be attempted. Defaults to 2.";
            type = (types.nullOr types.int);
          };
          "perRetry" = mkOption {
            description = "PerRetry is the retry policy to be applied per retry attempt.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetry"
              )
            );
          };
          "retryOn" = mkOption {
            description = "RetryOn specifies the retry trigger condition.\n\nIf not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOn"
              )
            );
          };
        };

        config = {
          "numAttemptsPerPriority" = mkOverride 1002 null;
          "numRetries" = mkOverride 1002 null;
          "perRetry" = mkOverride 1002 null;
          "retryOn" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetry" =
      {

        options = {
          "backOff" = mkOption {
            description = "Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential\nback-off algorithm for retries. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff"
              )
            );
          };
          "timeout" = mkOption {
            description = "Timeout is the timeout per retry attempt.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "backOff" = mkOverride 1002 null;
          "timeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff" =
      {

        options = {
          "baseInterval" = mkOption {
            description = "BaseInterval is the base interval between retries.";
            type = (types.nullOr types.str);
          };
          "maxInterval" = mkOption {
            description = "MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.\nThe default is 10 times the base_interval";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "baseInterval" = mkOverride 1002 null;
          "maxInterval" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOn" =
      {

        options = {
          "httpStatusCodes" = mkOption {
            description = "HttpStatusCodes specifies the http status codes to be retried.\nThe retriable-status-codes trigger must also be configured for these status codes to trigger a retry.";
            type = (types.nullOr (types.listOf types.int));
          };
          "triggers" = mkOption {
            description = "Triggers specifies the retry trigger condition(Http/Grpc).";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "httpStatusCodes" = mkOverride 1002 null;
          "triggers" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive" =
      {

        options = {
          "idleTime" = mkOption {
            description = "The duration a connection needs to be idle before keep-alive\nprobes start being sent.\nThe duration format is\nDefaults to `7200s`.";
            type = (types.nullOr types.str);
          };
          "interval" = mkOption {
            description = "The duration between keep-alive probes.\nDefaults to `75s`.";
            type = (types.nullOr types.str);
          };
          "probes" = mkOption {
            description = "The total number of unacknowledged probes to send before deciding\nthe connection is dead.\nDefaults to 9.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "idleTime" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "probes" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeout" =
      {

        options = {
          "http" = mkOption {
            description = "Timeout settings for HTTP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp"
              )
            );
          };
          "tcp" = mkOption {
            description = "Timeout settings for TCP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcp"
              )
            );
          };
        };

        config = {
          "http" = mkOverride 1002 null;
          "tcp" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp" =
      {

        options = {
          "connectionIdleTimeout" = mkOption {
            description = "The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.\nDefault: 1 hour.";
            type = (types.nullOr types.str);
          };
          "maxConnectionDuration" = mkOption {
            description = "The maximum duration of an HTTP connection.\nDefault: unlimited.";
            type = (types.nullOr types.str);
          };
          "maxStreamDuration" = mkOption {
            description = "MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time\nfrom when the request is sent until the response stream is fully consumed and does not apply to\nnon-streaming requests.\nWhen set to \"0s\", no max duration is applied and streams can run indefinitely.";
            type = (types.nullOr types.str);
          };
          "requestTimeout" = mkOption {
            description = "RequestTimeout is the time until which entire response is received from the upstream.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "connectionIdleTimeout" = mkOverride 1002 null;
          "maxConnectionDuration" = mkOverride 1002 null;
          "maxStreamDuration" = mkOverride 1002 null;
          "requestTimeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcp" =
      {

        options = {
          "connectTimeout" = mkOption {
            description = "The timeout for network connection establishment, including TCP and TLS handshakes.\nDefault: 10 seconds.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "connectTimeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryHeaders" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the HTTP Header to be matched. Name matching MUST be\ncase-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).\n\nIf multiple entries specify equivalent header names, the first entry with\nan equivalent name MUST be considered for a match. Subsequent entries\nwith an equivalent header name MUST be ignored. Due to the\ncase-insensitivity of header names, \"foo\" and \"Foo\" are considered\nequivalent.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value is the value of HTTP Header to be matched.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryRequestID" = {

      options = {
        "tracing" = mkOption {
          description = "Tracing configures Envoy's behavior for the UUID request ID extension,\nincluding whether the trace sampling decision is packed into the UUID and\nwhether `X-Request-ID` is used for trace sampling decisions.\n\nWhen omitted, the default behavior is `PackAndSample`, which alters the UUID\nto contain the trace sampling decision and uses `X-Request-ID` for stable\ntrace sampling.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "tracing" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracing" = {

      options = {
        "customTags" = mkOption {
          description = "CustomTags defines the custom tags to add to each span.\nIf provider is kubernetes, pod name and namespace are added by default.\n\nDeprecated: Use Tags instead.";
          type = (types.nullOr (types.attrsOf types.attrs));
        };
        "provider" = mkOption {
          description = "Provider defines the tracing provider.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProvider");
        };
        "samplingFraction" = mkOption {
          description = "SamplingFraction represents the fraction of requests that should be\nselected for tracing if no prior sampling decision has been made.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingSamplingFraction"
            )
          );
        };
        "samplingRate" = mkOption {
          description = "SamplingRate controls the rate at which traffic will be\nselected for tracing if no prior sampling decision has been made.\nDefaults to 100, valid values [0-100]. 100 indicates 100% sampling.\n\nOnly one of SamplingRate or SamplingFraction may be specified.\nIf neither field is specified, all requests will be sampled.";
          type = (types.nullOr types.int);
        };
        "spanName" = mkOption {
          description = "SpanName defines the name of the span which will be used for tracing.\nEnvoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators) may be used in the value.\nThe [format string documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings) provides more information.\n\nIf not set, the span name is provider specific.\ne.g. Datadog use `ingress` as the default client span name,\nand `router <UPSTREAM_CLUSTER> egress` as the server span name.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingSpanName")
          );
        };
        "tags" = mkOption {
          description = "Tags defines the custom tags to add to each span.\nEnvoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators) may be used in the value.\nThe [format string documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings) provides more information.\nIf provider is kubernetes, pod name and namespace are added by default.\n\nSame keys take precedence over CustomTags.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "customTags" = mkOverride 1002 null;
        "samplingFraction" = mkOverride 1002 null;
        "samplingRate" = mkOverride 1002 null;
        "spanName" = mkOverride 1002 null;
        "tags" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProvider" = {

      options = {
        "backendRef" = mkOption {
          description = "BackendRef references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.\n\nDeprecated: Use BackendRefs instead.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendRef"
            )
          );
        };
        "backendRefs" = mkOption {
          description = "BackendRefs references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "backendSettings" = mkOption {
          description = "BackendSettings holds configuration for managing the connection\nto the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettings"
            )
          );
        };
        "host" = mkOption {
          description = "Host define the provider service hostname.\nDeprecated: Use BackendRefs instead.";
          type = (types.nullOr types.str);
        };
        "openTelemetry" = mkOption {
          description = "OpenTelemetry defines the OpenTelemetry tracing provider configuration";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderOpenTelemetry"
            )
          );
        };
        "port" = mkOption {
          description = "Port defines the port the provider service is exposed on.\nDeprecated: Use BackendRefs instead.";
          type = (types.nullOr types.int);
        };
        "serviceName" = mkOption {
          description = "ServiceName defines the service name to use in tracing configuration.\nIf not set, Envoy Gateway will use a default service name set as\n\"name.namespace\" (e.g., \"my-gateway.default\").\nNote: This field is only supported for OpenTelemetry and Datadog tracing providers.\nFor Zipkin, the service name in traces is always derived from the Envoy --service-cluster flag\n(typically \"namespace/name\" format). Setting this field has no effect for Zipkin.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type defines the tracing provider type.";
          type = types.str;
        };
        "zipkin" = mkOption {
          description = "Zipkin defines the Zipkin tracing provider configuration";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderZipkin"
            )
          );
        };
      };

      config = {
        "backendRef" = mkOverride 1002 null;
        "backendRefs" = mkOverride 1002 null;
        "backendSettings" = mkOverride 1002 null;
        "host" = mkOverride 1002 null;
        "openTelemetry" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "serviceName" = mkOverride 1002 null;
        "zipkin" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendRefs" = {

      options = {
        "fallback" = mkOption {
          description = "Fallback indicates whether the backend is designated as a fallback.\nMultiple fallback backends can be configured.\nIt is highly recommended to configure active or passive health checks to ensure that failover can be detected\nwhen the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.\nThe overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when\nthe health of the active backends falls below 72%.";
          type = (types.nullOr types.bool);
        };
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
        "weight" = mkOption {
          description = "Weight specifies the proportion of requests forwarded to the referenced\nbackend. This is computed as weight/(sum of all weights in this\nBackendRefs list). For non-zero values, there may be some epsilon from\nthe exact proportion defined here depending on the precision an\nimplementation supports. Weight is not a percentage and the sum of\nweights does not need to equal 100.\n\nIf only one backend is specified and it has a weight greater than 0, 100%\nof the traffic is forwarded to that backend. If weight is set to 0, no\ntraffic should be forwarded for this entry. If unspecified, weight\ndefaults to 1.\n\nSupport for this field varies based on the context where used.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "fallback" = mkOverride 1002 null;
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "weight" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettings" = {

      options = {
        "circuitBreaker" = mkOption {
          description = "Circuit Breaker settings for the upstream connections and requests.\nIf not set, circuit breakers will be enabled with the default thresholds";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker"
            )
          );
        };
        "connection" = mkOption {
          description = "Connection includes backend connection settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection"
            )
          );
        };
        "dns" = mkOption {
          description = "DNS includes dns resolution settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns"
            )
          );
        };
        "healthCheck" = mkOption {
          description = "HealthCheck allows gateway to perform active health checking on backends.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck"
            )
          );
        };
        "http2" = mkOption {
          description = "HTTP2 provides HTTP/2 configuration for backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2"
            )
          );
        };
        "loadBalancer" = mkOption {
          description = "LoadBalancer policy to apply when routing traffic from the gateway to\nthe backend endpoints. Defaults to `LeastRequest`.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer"
            )
          );
        };
        "proxyProtocol" = mkOption {
          description = "ProxyProtocol enables the Proxy Protocol when communicating with the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocol"
            )
          );
        };
        "retry" = mkOption {
          description = "Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.\nIf not set, retry will be disabled.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry"
            )
          );
        };
        "tcpKeepalive" = mkOption {
          description = "TcpKeepalive settings associated with the upstream client connection.\nDisabled by default.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout settings for the backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeout"
            )
          );
        };
      };

      config = {
        "circuitBreaker" = mkOverride 1002 null;
        "connection" = mkOverride 1002 null;
        "dns" = mkOverride 1002 null;
        "healthCheck" = mkOverride 1002 null;
        "http2" = mkOverride 1002 null;
        "loadBalancer" = mkOverride 1002 null;
        "proxyProtocol" = mkOverride 1002 null;
        "retry" = mkOverride 1002 null;
        "tcpKeepalive" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxParallelRequests" = mkOption {
            description = "The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxParallelRetries" = mkOption {
            description = "The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxPendingRequests" = mkOption {
            description = "The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxRequestsPerConnection" = mkOption {
            description = "The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.\nDefault: unlimited.";
            type = (types.nullOr types.int);
          };
          "perEndpoint" = mkOption {
            description = "PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpoint"
              )
            );
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
          "maxParallelRequests" = mkOverride 1002 null;
          "maxParallelRetries" = mkOverride 1002 null;
          "maxPendingRequests" = mkOverride 1002 null;
          "maxRequestsPerConnection" = mkOverride 1002 null;
          "perEndpoint" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpoint" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection" = {

      options = {
        "bufferLimit" = mkOption {
          description = "BufferLimit Soft limit on size of the cluster’s connections read and write buffers.\nBufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.\nIf unspecified, an implementation defined default is applied (32768 bytes).\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote: that when the suffix is not provided, the value is interpreted as bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "preconnect" = mkOption {
          description = "Preconnect configures proactive upstream connections to reduce latency by establishing\nconnections before they’re needed and avoiding connection establishment overhead.\n\nIf unset, Envoy will fetch connections as needed to serve in-flight requests.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionPreconnect"
            )
          );
        };
        "socketBufferLimit" = mkOption {
          description = "SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket\nto backend.\nSocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote that when the suffix is not provided, the value is interpreted as bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "bufferLimit" = mkOverride 1002 null;
        "preconnect" = mkOverride 1002 null;
        "socketBufferLimit" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionPreconnect" =
      {

        options = {
          "perEndpointPercent" = mkOption {
            description = "PerEndpointPercent configures how many additional connections to maintain per\nupstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a\npercentage of the connections required by active streams\n(e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).\n\nAllowed value range is between 100-300. When both PerEndpointPercent and\nPredictivePercent are set, Envoy ensures both are satisfied (max of the two).";
            type = (types.nullOr types.int);
          };
          "predictivePercent" = mkOption {
            description = "PredictivePercent configures how many additional connections to maintain\nacross the cluster by anticipating which upstream endpoint the load balancer\nwill select next, useful for low-QPS services. Relies on deterministic\nloadbalancing and is only supported with Random or RoundRobin.\nExpressed as a percentage of the connections required by active streams\n(e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).\n\nMinimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are\nset Envoy ensures both are satisfied per host (max of the two).";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "perEndpointPercent" = mkOverride 1002 null;
          "predictivePercent" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns" = {

      options = {
        "dnsRefreshRate" = mkOption {
          description = "DNSRefreshRate specifies the rate at which DNS records should be refreshed.\nDefaults to 30 seconds.";
          type = (types.nullOr types.str);
        };
        "lookupFamily" = mkOption {
          description = "LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).\nIf set, this configuration overrides other defaults.";
          type = (types.nullOr types.str);
        };
        "respectDnsTtl" = mkOption {
          description = "RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.\nIf the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.\nDefaults to true.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "dnsRefreshRate" = mkOverride 1002 null;
        "lookupFamily" = mkOverride 1002 null;
        "respectDnsTtl" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck" =
      {

        options = {
          "active" = mkOption {
            description = "Active health check configuration";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive"
              )
            );
          };
          "panicThreshold" = mkOption {
            description = "When number of unhealthy endpoints for a backend reaches this threshold\nEnvoy will disregard health status and balance across all endpoints.\nIt's designed to prevent a situation in which host failures cascade throughout the cluster\nas load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.";
            type = (types.nullOr types.int);
          };
          "passive" = mkOption {
            description = "Passive passive check configuration";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive"
              )
            );
          };
        };

        config = {
          "active" = mkOverride 1002 null;
          "panicThreshold" = mkOverride 1002 null;
          "passive" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive" =
      {

        options = {
          "grpc" = mkOption {
            description = "GRPC defines the configuration of the GRPC health checker.\nIt's optional, and can only be used if the specified type is GRPC.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpc"
              )
            );
          };
          "healthyThreshold" = mkOption {
            description = "HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.";
            type = (types.nullOr types.int);
          };
          "http" = mkOption {
            description = "HTTP defines the configuration of http health checker.\nIt's required while the health checker type is HTTP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp"
              )
            );
          };
          "initialJitter" = mkOption {
            description = "InitialJitter defines the maximum time Envoy will wait before the first health check.\nEnvoy will randomly select a value between 0 and the initial jitter value.";
            type = (types.nullOr types.str);
          };
          "interval" = mkOption {
            description = "Interval defines the time between active health checks.";
            type = (types.nullOr types.str);
          };
          "tcp" = mkOption {
            description = "TCP defines the configuration of tcp health checker.\nIt's required while the health checker type is TCP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcp"
              )
            );
          };
          "timeout" = mkOption {
            description = "Timeout defines the time to wait for a health check response.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of health checker.";
            type = types.str;
          };
          "unhealthyThreshold" = mkOption {
            description = "UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "grpc" = mkOverride 1002 null;
          "healthyThreshold" = mkOverride 1002 null;
          "http" = mkOverride 1002 null;
          "initialJitter" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "tcp" = mkOverride 1002 null;
          "timeout" = mkOverride 1002 null;
          "unhealthyThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpc" =
      {

        options = {
          "service" = mkOption {
            description = "Service to send in the health check request.\nIf this is not specified, then the health check request applies to the entire\nserver and not to a specific service.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "service" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp" =
      {

        options = {
          "expectedResponse" = mkOption {
            description = "ExpectedResponse defines a list of HTTP expected responses to match.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse"
              )
            );
          };
          "expectedStatuses" = mkOption {
            description = "ExpectedStatuses defines a list of HTTP response statuses considered healthy.\nDefaults to 200 only";
            type = (types.nullOr (types.listOf types.int));
          };
          "hostname" = mkOption {
            description = "Hostname defines the HTTP host that will be requested during health checking.\nDefault: HTTPRoute or GRPCRoute hostname.";
            type = (types.nullOr types.str);
          };
          "method" = mkOption {
            description = "Method defines the HTTP method used for health checking.\nDefaults to GET";
            type = (types.nullOr types.str);
          };
          "path" = mkOption {
            description = "Path defines the HTTP path that will be requested during health checking.";
            type = types.str;
          };
        };

        config = {
          "expectedResponse" = mkOverride 1002 null;
          "expectedStatuses" = mkOverride 1002 null;
          "hostname" = mkOverride 1002 null;
          "method" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcp" =
      {

        options = {
          "receive" = mkOption {
            description = "Receive defines the expected response payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive"
              )
            );
          };
          "send" = mkOption {
            description = "Send defines the request payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend"
              )
            );
          };
        };

        config = {
          "receive" = mkOverride 1002 null;
          "send" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive" =
      {

        options = {
          "baseEjectionTime" = mkOption {
            description = "BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.";
            type = (types.nullOr types.str);
          };
          "consecutive5XxErrors" = mkOption {
            description = "Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.";
            type = (types.nullOr types.int);
          };
          "consecutiveGatewayErrors" = mkOption {
            description = "ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.";
            type = (types.nullOr types.int);
          };
          "consecutiveLocalOriginFailures" = mkOption {
            description = "ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.\nParameter takes effect only when split_external_local_origin_errors is set to true.";
            type = (types.nullOr types.int);
          };
          "failurePercentageThreshold" = mkOption {
            description = "FailurePercentageThreshold sets the failure percentage threshold for outlier detection.\nIf the failure percentage of a given host is greater than or equal to this value, it will be ejected.\nDefaults to 85.";
            type = (types.nullOr types.int);
          };
          "interval" = mkOption {
            description = "Interval defines the time between passive health checks.";
            type = (types.nullOr types.str);
          };
          "maxEjectionPercent" = mkOption {
            description = "MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.";
            type = (types.nullOr types.int);
          };
          "splitExternalLocalOriginErrors" = mkOption {
            description = "SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "baseEjectionTime" = mkOverride 1002 null;
          "consecutive5XxErrors" = mkOverride 1002 null;
          "consecutiveGatewayErrors" = mkOverride 1002 null;
          "consecutiveLocalOriginFailures" = mkOverride 1002 null;
          "failurePercentageThreshold" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "maxEjectionPercent" = mkOverride 1002 null;
          "splitExternalLocalOriginErrors" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2" = {

      options = {
        "initialConnectionWindowSize" = mkOption {
          description = "InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.\nIf not set, the default value is 1 MiB.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "initialStreamWindowSize" = mkOption {
          description = "InitialStreamWindowSize sets the initial window size for HTTP/2 streams.\nIf not set, the default value is 64 KiB(64*1024).";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxConcurrentStreams" = mkOption {
          description = "MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.\nIf not set, the default value is 100.";
          type = (types.nullOr types.int);
        };
        "onInvalidMessage" = mkOption {
          description = "OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error\nIt's recommended for L2 Envoy deployments to set this value to TerminateStream.\nhttps://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two\nDefault: TerminateConnection";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "initialConnectionWindowSize" = mkOverride 1002 null;
        "initialStreamWindowSize" = mkOverride 1002 null;
        "maxConcurrentStreams" = mkOverride 1002 null;
        "onInvalidMessage" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer" =
      {

        options = {
          "consistentHash" = mkOption {
            description = "ConsistentHash defines the configuration when the load balancer type is\nset to ConsistentHash";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash"
              )
            );
          };
          "endpointOverride" = mkOption {
            description = "EndpointOverride defines the configuration for endpoint override.\nWhen specified, the load balancer will attempt to route requests to endpoints\nbased on the override information extracted from request headers or metadata.\n If the override endpoints are not available, the configured load balancer policy will be used as fallback.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverride"
              )
            );
          };
          "slowStart" = mkOption {
            description = "SlowStart defines the configuration related to the slow start load balancer policy.\nIf set, during slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently this is only supported for RoundRobin and LeastRequest load balancers";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStart"
              )
            );
          };
          "type" = mkOption {
            description = "Type decides the type of Load Balancer policy.\nValid LoadBalancerType values are\n\"ConsistentHash\",\n\"LeastRequest\",\n\"Random\",\n\"RoundRobin\".";
            type = types.str;
          };
          "zoneAware" = mkOption {
            description = "ZoneAware defines the configuration related to the distribution of requests between locality zones.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAware"
              )
            );
          };
        };

        config = {
          "consistentHash" = mkOverride 1002 null;
          "endpointOverride" = mkOverride 1002 null;
          "slowStart" = mkOverride 1002 null;
          "zoneAware" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash" =
      {

        options = {
          "cookie" = mkOption {
            description = "Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie"
              )
            );
          };
          "header" = mkOption {
            description = "Header configures the header hash policy when the consistent hash type is set to Header.\n\nDeprecated: use Headers instead";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeader"
              )
            );
          };
          "headers" = mkOption {
            description = "Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "queryParams" = mkOption {
            description = "QueryParams configures the query parameter hash policy when the consistent hash type is set to QueryParams.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashQueryParams"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "tableSize" = mkOption {
            description = "The table size for consistent hashing, must be prime number limited to 5000011.";
            type = (types.nullOr types.int);
          };
          "type" = mkOption {
            description = "ConsistentHashType defines the type of input to hash on. Valid Type values are\n\"SourceIP\",\n\"Header\",\n\"Headers\",\n\"Cookie\".\n\"QueryParams\".";
            type = types.str;
          };
        };

        config = {
          "cookie" = mkOverride 1002 null;
          "header" = mkOverride 1002 null;
          "headers" = mkOverride 1002 null;
          "queryParams" = mkOverride 1002 null;
          "tableSize" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie" =
      {

        options = {
          "attributes" = mkOption {
            description = "Additional Attributes to set for the generated cookie.";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "name" = mkOption {
            description = "Name of the cookie to hash.\nIf this cookie does not exist in the request, Envoy will generate a cookie and set\nthe TTL on the response back to the client based on Layer 4\nattributes of the backend endpoint, to ensure that these future requests\ngo to the same backend endpoint. Make sure to set the TTL field for this case.";
            type = types.str;
          };
          "ttl" = mkOption {
            description = "TTL of the generated cookie if the cookie is not present. This value sets the\nMax-Age attribute value.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "attributes" = mkOverride 1002 null;
          "ttl" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeader" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashQueryParams" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the query param to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverride" =
      {

        options = {
          "extractFrom" = mkOption {
            description = "ExtractFrom defines the sources to extract endpoint override information from.";
            type = (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom"
              )
            );
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom" =
      {

        options = {
          "header" = mkOption {
            description = "Header defines the header to get the override endpoint addresses.\nThe header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.\nFor example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.\nThe IPv6 address is enclosed in square brackets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "header" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStart" =
      {

        options = {
          "window" = mkOption {
            description = "Window defines the duration of the warm up period for newly added host.\nDuring slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently only supports linear growth of traffic. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAware" =
      {

        options = {
          "preferLocal" = mkOption {
            description = "PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal"
              )
            );
          };
        };

        config = {
          "preferLocal" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal" =
      {

        options = {
          "force" = mkOption {
            description = "ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior\nwhich maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce"
              )
            );
          };
          "minEndpointsThreshold" = mkOption {
            description = "MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.";
            type = (types.nullOr types.int);
          };
          "percentageEnabled" = mkOption {
            description = "Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "force" = mkOverride 1002 null;
          "minEndpointsThreshold" = mkOverride 1002 null;
          "percentageEnabled" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce" =
      {

        options = {
          "minEndpointsInZoneThreshold" = mkOption {
            description = "MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone\noverride. This is useful for protecting zones with fewer endpoints.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "minEndpointsInZoneThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocol" =
      {

        options = {
          "version" = mkOption {
            description = "Version of ProxyProtol\nValid ProxyProtocolVersion values are\n\"V1\"\n\"V2\"";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry" = {

      options = {
        "numAttemptsPerPriority" = mkOption {
          description = "NumAttemptsPerPriority defines the number of requests (initial attempt + retries)\nthat should be sent to the same priority before switching to a different one.\nIf not specified or set to 0, all requests are sent to the highest priority that is healthy.";
          type = (types.nullOr types.int);
        };
        "numRetries" = mkOption {
          description = "NumRetries is the number of retries to be attempted. Defaults to 2.";
          type = (types.nullOr types.int);
        };
        "perRetry" = mkOption {
          description = "PerRetry is the retry policy to be applied per retry attempt.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetry"
            )
          );
        };
        "retryOn" = mkOption {
          description = "RetryOn specifies the retry trigger condition.\n\nIf not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOn"
            )
          );
        };
      };

      config = {
        "numAttemptsPerPriority" = mkOverride 1002 null;
        "numRetries" = mkOverride 1002 null;
        "perRetry" = mkOverride 1002 null;
        "retryOn" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetry" =
      {

        options = {
          "backOff" = mkOption {
            description = "Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential\nback-off algorithm for retries. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOff"
              )
            );
          };
          "timeout" = mkOption {
            description = "Timeout is the timeout per retry attempt.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "backOff" = mkOverride 1002 null;
          "timeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOff" =
      {

        options = {
          "baseInterval" = mkOption {
            description = "BaseInterval is the base interval between retries.";
            type = (types.nullOr types.str);
          };
          "maxInterval" = mkOption {
            description = "MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.\nThe default is 10 times the base_interval";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "baseInterval" = mkOverride 1002 null;
          "maxInterval" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOn" =
      {

        options = {
          "httpStatusCodes" = mkOption {
            description = "HttpStatusCodes specifies the http status codes to be retried.\nThe retriable-status-codes trigger must also be configured for these status codes to trigger a retry.";
            type = (types.nullOr (types.listOf types.int));
          };
          "triggers" = mkOption {
            description = "Triggers specifies the retry trigger condition(Http/Grpc).";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "httpStatusCodes" = mkOverride 1002 null;
          "triggers" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive" =
      {

        options = {
          "idleTime" = mkOption {
            description = "The duration a connection needs to be idle before keep-alive\nprobes start being sent.\nThe duration format is\nDefaults to `7200s`.";
            type = (types.nullOr types.str);
          };
          "interval" = mkOption {
            description = "The duration between keep-alive probes.\nDefaults to `75s`.";
            type = (types.nullOr types.str);
          };
          "probes" = mkOption {
            description = "The total number of unacknowledged probes to send before deciding\nthe connection is dead.\nDefaults to 9.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "idleTime" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "probes" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeout" = {

      options = {
        "http" = mkOption {
          description = "Timeout settings for HTTP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp"
            )
          );
        };
        "tcp" = mkOption {
          description = "Timeout settings for TCP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcp"
            )
          );
        };
      };

      config = {
        "http" = mkOverride 1002 null;
        "tcp" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp" =
      {

        options = {
          "connectionIdleTimeout" = mkOption {
            description = "The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.\nDefault: 1 hour.";
            type = (types.nullOr types.str);
          };
          "maxConnectionDuration" = mkOption {
            description = "The maximum duration of an HTTP connection.\nDefault: unlimited.";
            type = (types.nullOr types.str);
          };
          "maxStreamDuration" = mkOption {
            description = "MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time\nfrom when the request is sent until the response stream is fully consumed and does not apply to\nnon-streaming requests.\nWhen set to \"0s\", no max duration is applied and streams can run indefinitely.";
            type = (types.nullOr types.str);
          };
          "requestTimeout" = mkOption {
            description = "RequestTimeout is the time until which entire response is received from the upstream.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "connectionIdleTimeout" = mkOverride 1002 null;
          "maxConnectionDuration" = mkOverride 1002 null;
          "maxStreamDuration" = mkOverride 1002 null;
          "requestTimeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcp" = {

      options = {
        "connectTimeout" = mkOption {
          description = "The timeout for network connection establishment, including TCP and TLS handshakes.\nDefault: 10 seconds.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "connectTimeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderOpenTelemetry" = {

      options = {
        "headers" = mkOption {
          description = "Headers is a list of additional headers to send with OTLP export requests.\nThese headers are added as gRPC initial metadata for the OTLP gRPC service.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderOpenTelemetryHeaders"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "resourceAttributes" = mkOption {
          description = "ResourceAttributes is a set of labels that describe the source of traces.\nIt's recommended to follow semantic conventions: https://opentelemetry.io/docs/reference/specification/resource/semantic_conventions/";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "headers" = mkOverride 1002 null;
        "resourceAttributes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderOpenTelemetryHeaders" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the HTTP Header to be matched. Name matching MUST be\ncase-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).\n\nIf multiple entries specify equivalent header names, the first entry with\nan equivalent name MUST be considered for a match. Subsequent entries\nwith an equivalent header name MUST be ignored. Due to the\ncase-insensitivity of header names, \"foo\" and \"Foo\" are considered\nequivalent.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value is the value of HTTP Header to be matched.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingProviderZipkin" = {

      options = {
        "disableSharedSpanContext" = mkOption {
          description = "DisableSharedSpanContext determines whether the default Envoy behaviour of\nclient and server spans sharing the same span context should be disabled.";
          type = (types.nullOr types.bool);
        };
        "enable128BitTraceId" = mkOption {
          description = "Enable128BitTraceID determines whether a 128bit trace id will be used\nwhen creating a new trace instance. If set to false, a 64bit trace\nid will be used.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "disableSharedSpanContext" = mkOverride 1002 null;
        "enable128BitTraceId" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingSamplingFraction" = {

      options = {
        "denominator" = mkOption {
          description = "";
          type = (types.nullOr types.int);
        };
        "numerator" = mkOption {
          description = "";
          type = types.int;
        };
      };

      config = {
        "denominator" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxySpecTelemetryTracingSpanName" = {

      options = {
        "client" = mkOption {
          description = "Client defines operation name of the span which will be used for tracing.";
          type = types.str;
        };
        "server" = mkOption {
          description = "Server defines the operation name of the upstream span which will be used for tracing.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxyStatus" = {

      options = {
        "ancestors" = mkOption {
          description = "Ancestors represent the status information for all the GatewayClass or Gateway\nreference this EnvoyProxy with ParametersReference.";
          type = (
            types.nullOr (types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxyStatusAncestors"))
          );
        };
      };

      config = {
        "ancestors" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxyStatusAncestors" = {

      options = {
        "ancestorRef" = mkOption {
          description = "AncestorRef corresponds a GatewayClass or Gateway use this EnvoyProxy with ParametersReference.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxyStatusAncestorsAncestorRef");
        };
        "conditions" = mkOption {
          description = "Conditions describes the status of the Policy with respect to the given Ancestor.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.EnvoyProxyStatusAncestorsConditions")
            )
          );
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxyStatusAncestorsAncestorRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent.\nWhen unspecified, \"gateway.networking.k8s.io\" is inferred.\nTo set the core API group (such as for a \"Service\" kind referent),\nGroup must be explicitly set to \"\" (empty string).\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent.\n\nThere are two kinds of parent resources with \"Core\" support:\n\n* Gateway (Gateway conformance profile)\n* Service (Mesh conformance profile, ClusterIP Services only)\n\nSupport for other resources is Implementation-Specific.";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.\n\nSupport: Core";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referent. When unspecified, this refers\nto the local namespace of the Route.\n\nNote that there are specific rules for ParentRefs which cross namespace\nboundaries. Cross-namespace references are only valid if they are explicitly\nallowed by something in the namespace they are referring to. For example:\nGateway has the AllowedRoutes field, and ReferenceGrant provides a\ngeneric way to enable any other kind of cross-namespace reference.\n\n<gateway:experimental:description>\nParentRefs from a Route to a Service in the same namespace are \"producer\"\nroutes, which apply default routing rules to inbound connections from\nany namespace to the Service.\n\nParentRefs from a Route to a Service in a different namespace are\n\"consumer\" routes, and these routing rules are only applied to outbound\nconnections originating from the same namespace as the Route, for which\nthe intended destination of the connections are a Service targeted as a\nParentRef of the Route.\n</gateway:experimental:description>\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port is the network port this Route targets. It can be interpreted\ndifferently based on the type of parent resource.\n\nWhen the parent resource is a Gateway, this targets all listeners\nlistening on the specified port that also support this kind of Route(and\nselect this Route). It's not recommended to set `Port` unless the\nnetworking behaviors specified in a Route must apply to a specific port\nas opposed to a listener(s) whose port(s) may be changed. When both Port\nand SectionName are specified, the name and port of the selected listener\nmust match both specified values.\n\n<gateway:experimental:description>\nWhen the parent resource is a Service, this targets a specific port in the\nService spec. When both Port (experimental) and SectionName are specified,\nthe name and port of the selected port must match both specified values.\n</gateway:experimental:description>\n\nImplementations MAY choose to support other parent resources.\nImplementations supporting other types of parent resources MUST clearly\ndocument how/if Port is interpreted.\n\nFor the purpose of status, an attachment is considered successful as\nlong as the parent resource accepts it partially. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment\nfrom the referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route,\nthe Route MUST be considered detached from the Gateway.\n\nSupport: Extended";
          type = (types.nullOr types.int);
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. In the\nfollowing resources, SectionName is interpreted as the following:\n\n* Gateway: Listener name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n* Service: Port name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n\nImplementations MAY choose to support attaching Routes to other resources.\nIf that is the case, they MUST clearly document how SectionName is\ninterpreted.\n\nWhen unspecified (empty string), this will reference the entire resource.\nFor the purpose of status, an attachment is considered successful if at\nleast one section in the parent resource accepts it. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment from\nthe referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route, the\nRoute MUST be considered detached from the Gateway.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.EnvoyProxyStatusAncestorsConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = types.str;
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "type of condition in CamelCase or in foo.example.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilter" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "Spec defines the desired state of HTTPRouteFilter.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpec");
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpec" = {

      options = {
        "credentialInjection" = mkOption {
          description = "HTTPCredentialInjectionFilter defines the configuration to inject credentials into the request.\nThis is useful when the backend service requires credentials in the request, and the original\nrequest does not contain them. The filter can inject credentials into the request before forwarding\nit to the backend service.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecCredentialInjection")
          );
        };
        "directResponse" = mkOption {
          description = "HTTPDirectResponseFilter defines the configuration to return a fixed response.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecDirectResponse")
          );
        };
        "matches" = mkOption {
          description = "Matches defines additional matching criteria for the HTTPRoute rule.\nAs with HTTPRouteRule.Matches, the rule is matched if any one match applies.\nWhen both HTTPRouteRule.Matches and HTTPRouteFilter.Matches are set, the\neffective matching is the logical AND of the two sets.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecMatches")
            )
          );
        };
        "urlRewrite" = mkOption {
          description = "HTTPURLRewriteFilter define rewrites of HTTP URL components such as path and host";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecUrlRewrite"));
        };
      };

      config = {
        "credentialInjection" = mkOverride 1002 null;
        "directResponse" = mkOverride 1002 null;
        "matches" = mkOverride 1002 null;
        "urlRewrite" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecCredentialInjection" = {

      options = {
        "credential" = mkOption {
          description = "Credential is the credential to be injected.";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecCredentialInjectionCredential"
          );
        };
        "header" = mkOption {
          description = "Header is the name of the header where the credentials are injected.\nIf not specified, the credentials are injected into the Authorization header.";
          type = (types.nullOr types.str);
        };
        "overwrite" = mkOption {
          description = "Whether to overwrite the value or not if the injected headers already exist.\nIf not specified, the default value is false.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "header" = mkOverride 1002 null;
        "overwrite" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecCredentialInjectionCredential" = {

      options = {
        "valueRef" = mkOption {
          description = "ValueRef is a reference to the secret containing the credentials to be injected.\nThis is an Opaque secret. The credential should be stored in the key\n\"credential\", and the value should be the credential to be injected.\nFor example, for basic authentication, the value should be \"Basic <base64 encoded username:password>\".\nfor bearer token, the value should be \"Bearer <token>\".\nNote: The secret must be in the same namespace as the HTTPRouteFilter.";
          type = (
            submoduleOf "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecCredentialInjectionCredentialValueRef"
          );
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecCredentialInjectionCredentialValueRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"Secret\".";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referenced object. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecDirectResponse" = {

      options = {
        "body" = mkOption {
          description = "Body of the direct response.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecDirectResponseBody")
          );
        };
        "contentType" = mkOption {
          description = "Content Type of the direct response. This will be set in the Content-Type header.";
          type = (types.nullOr types.str);
        };
        "header" = mkOption {
          description = "Header defines the headers of the direct response.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecDirectResponseHeader")
          );
        };
        "statusCode" = mkOption {
          description = "Status Code of the HTTP response\nIf unset, defaults to 200.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "body" = mkOverride 1002 null;
        "contentType" = mkOverride 1002 null;
        "header" = mkOverride 1002 null;
        "statusCode" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecDirectResponseBody" = {

      options = {
        "inline" = mkOption {
          description = "Inline contains the value as an inline string.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type is the type of method to use to read the body value.\nValid values are Inline and ValueRef, default is Inline.";
          type = types.str;
        };
        "valueRef" = mkOption {
          description = "ValueRef contains the contents of the body\nspecified as a local object reference.\nOnly a reference to ConfigMap is supported.\n\nThe value of key `response.body` in the ConfigMap will be used as the response body.\nIf the key is not found, the first value in the ConfigMap will be used.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecDirectResponseBodyValueRef"
            )
          );
        };
      };

      config = {
        "inline" = mkOverride 1002 null;
        "valueRef" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecDirectResponseBodyValueRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"HTTPRoute\" or \"Service\".";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecDirectResponseHeader" = {

      options = {
        "add" = mkOption {
          description = "Add adds the given header(s) (name, value) to the request\nbefore the action. It appends to any existing values associated\nwith the header name.\n\nInput:\n  GET /foo HTTP/1.1\n  my-header: foo\n\nConfig:\n  add:\n  - name: \"my-header\"\n    value: \"bar,baz\"\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header: foo,bar,baz";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecDirectResponseHeaderAdd"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "remove" = mkOption {
          description = "Remove the given header(s) from the HTTP request before the action. The\nvalue of Remove is a list of HTTP header names. Note that the header\nnames are case-insensitive (see\nhttps://datatracker.ietf.org/doc/html/rfc2616#section-4.2).\n\nInput:\n  GET /foo HTTP/1.1\n  my-header1: foo\n  my-header2: bar\n  my-header3: baz\n\nConfig:\n  remove: [\"my-header1\", \"my-header3\"]\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header2: bar";
          type = (types.nullOr (types.listOf types.str));
        };
        "set" = mkOption {
          description = "Set overwrites the request with the given header (name, value)\nbefore the action.\n\nInput:\n  GET /foo HTTP/1.1\n  my-header: foo\n\nConfig:\n  set:\n  - name: \"my-header\"\n    value: \"bar\"\n\nOutput:\n  GET /foo HTTP/1.1\n  my-header: bar";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecDirectResponseHeaderSet"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "add" = mkOverride 1002 null;
        "remove" = mkOverride 1002 null;
        "set" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecDirectResponseHeaderAdd" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the HTTP Header to be matched. Name matching MUST be\ncase-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).\n\nIf multiple entries specify equivalent header names, the first entry with\nan equivalent name MUST be considered for a match. Subsequent entries\nwith an equivalent header name MUST be ignored. Due to the\ncase-insensitivity of header names, \"foo\" and \"Foo\" are considered\nequivalent.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value is the value of HTTP Header to be matched.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecDirectResponseHeaderSet" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the HTTP Header to be matched. Name matching MUST be\ncase-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).\n\nIf multiple entries specify equivalent header names, the first entry with\nan equivalent name MUST be considered for a match. Subsequent entries\nwith an equivalent header name MUST be ignored. Due to the\ncase-insensitivity of header names, \"foo\" and \"Foo\" are considered\nequivalent.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value is the value of HTTP Header to be matched.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecMatches" = {

      options = {
        "cookies" = mkOption {
          description = "Cookies is a list of cookie matchers evaluated against the HTTP request.\nAll specified matchers must match.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecMatchesCookies"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "cookies" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecMatchesCookies" = {

      options = {
        "name" = mkOption {
          description = "Name is the cookie name to evaluate.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type specifies how to match against the value of the cookie.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is the cookie value to be matched.";
          type = types.str;
        };
      };

      config = {
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecUrlRewrite" = {

      options = {
        "hostname" = mkOption {
          description = "Hostname is the value to be used to replace the Host header value during\nforwarding.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecUrlRewriteHostname")
          );
        };
        "path" = mkOption {
          description = "Path defines a path rewrite.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecUrlRewritePath")
          );
        };
      };

      config = {
        "hostname" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecUrlRewriteHostname" = {

      options = {
        "header" = mkOption {
          description = "Header is the name of the header whose value would be used to rewrite the Host header";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "HTTPPathModifierType defines the type of Hostname rewrite.";
          type = types.str;
        };
      };

      config = {
        "header" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecUrlRewritePath" = {

      options = {
        "replaceRegexMatch" = mkOption {
          description = "ReplaceRegexMatch defines a path regex rewrite. The path portions matched by the regex pattern are replaced by the defined substitution.\nhttps://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-field-config-route-v3-routeaction-regex-rewrite\nSome examples:\n(1) replaceRegexMatch:\n      pattern: ^/service/([^/]+)(/.*)$\n      substitution: \\2/instance/\\1\n    Would transform /service/foo/v1/api into /v1/api/instance/foo.\n(2) replaceRegexMatch:\n      pattern: one\n      substitution: two\n    Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/two/zzz.\n(3) replaceRegexMatch:\n      pattern: ^(.*?)one(.*)$\n      substitution: \\1two\\2\n    Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/one/zzz.\n(3) replaceRegexMatch:\n      pattern: (?i)/xxx/\n      substitution: /yyy/\n    Would transform path /aaa/XxX/bbb into /aaa/yyy/bbb (case-insensitive).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecUrlRewritePathReplaceRegexMatch"
            )
          );
        };
        "type" = mkOption {
          description = "HTTPPathModifierType defines the type of path redirect or rewrite.";
          type = types.str;
        };
      };

      config = {
        "replaceRegexMatch" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilterSpecUrlRewritePathReplaceRegexMatch" = {

      options = {
        "pattern" = mkOption {
          description = "Pattern matches a regular expression against the value of the HTTP Path.The regex string must\nadhere to the syntax documented in https://github.com/google/re2/wiki/Syntax.";
          type = types.str;
        };
        "substitution" = mkOption {
          description = "Substitution is an expression that replaces the matched portion.The expression may include numbered\ncapture groups that adhere to syntax documented in https://github.com/google/re2/wiki/Syntax.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicy" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "Spec defines the desired state of SecurityPolicy.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpec");
        };
        "status" = mkOption {
          description = "Status defines the current status of SecurityPolicy.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicyStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpec" = {

      options = {
        "apiKeyAuth" = mkOption {
          description = "APIKeyAuth defines the configuration for the API Key Authentication.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecApiKeyAuth"));
        };
        "authorization" = mkOption {
          description = "Authorization defines the authorization configuration.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorization")
          );
        };
        "basicAuth" = mkOption {
          description = "BasicAuth defines the configuration for the HTTP Basic Authentication.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecBasicAuth"));
        };
        "cors" = mkOption {
          description = "CORS defines the configuration for Cross-Origin Resource Sharing (CORS).";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecCors"));
        };
        "extAuth" = mkOption {
          description = "ExtAuth defines the configuration for External Authorization.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuth"));
        };
        "jwt" = mkOption {
          description = "JWT defines the configuration for JSON Web Token (JWT) authentication.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwt"));
        };
        "oidc" = mkOption {
          description = "OIDC defines the configuration for the OpenID Connect (OIDC) authentication.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidc"));
        };
        "targetRef" = mkOption {
          description = "TargetRef is the name of the resource this policy is being attached to.\nThis policy and the TargetRef MUST be in the same namespace for this\nPolicy to have effect\n\nDeprecated: use targetRefs/targetSelectors instead";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecTargetRef"));
        };
        "targetRefs" = mkOption {
          description = "TargetRefs are the names of the Gateway resources this policy\nis being attached to.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecTargetRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "targetSelectors" = mkOption {
          description = "TargetSelectors allow targeting resources for this policy based on labels";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecTargetSelectors")
            )
          );
        };
      };

      config = {
        "apiKeyAuth" = mkOverride 1002 null;
        "authorization" = mkOverride 1002 null;
        "basicAuth" = mkOverride 1002 null;
        "cors" = mkOverride 1002 null;
        "extAuth" = mkOverride 1002 null;
        "jwt" = mkOverride 1002 null;
        "oidc" = mkOverride 1002 null;
        "targetRef" = mkOverride 1002 null;
        "targetRefs" = mkOverride 1002 null;
        "targetSelectors" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecApiKeyAuth" = {

      options = {
        "credentialRefs" = mkOption {
          description = "CredentialRefs is the Kubernetes secret which contains the API keys.\nThis is an Opaque secret.\nEach API key is stored in the key representing the client id.\nIf the secrets have a key for a duplicated client, the first one will be used.";
          type = (
            coerceAttrsOfSubmodulesToListByKey
              "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecApiKeyAuthCredentialRefs"
              "name"
              [ ]
          );
          apply = attrsToList;
        };
        "extractFrom" = mkOption {
          description = "ExtractFrom is where to fetch the key from the coming request.\nThe value from the first source that has a key will be used.";
          type = (
            types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecApiKeyAuthExtractFrom")
          );
        };
        "forwardClientIDHeader" = mkOption {
          description = "ForwardClientIDHeader is the name of the header to forward the client identity to the backend\nservice. The header will be added to the request with the client id as the value.";
          type = (types.nullOr types.str);
        };
        "sanitize" = mkOption {
          description = "Sanitize indicates whether to remove the API key from the request before forwarding it to the backend service.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "forwardClientIDHeader" = mkOverride 1002 null;
        "sanitize" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecApiKeyAuthCredentialRefs" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"Secret\".";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referenced object. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecApiKeyAuthExtractFrom" = {

      options = {
        "cookies" = mkOption {
          description = "Cookies is the names of the cookie to fetch the key from.\nIf multiple cookies are specified, envoy will look for the api key in the order of the list.\nThis field is optional, but only one of headers, params or cookies is supposed to be specified.";
          type = (types.nullOr (types.listOf types.str));
        };
        "headers" = mkOption {
          description = "Headers is the names of the header to fetch the key from.\nIf multiple headers are specified, envoy will look for the api key in the order of the list.\nThis field is optional, but only one of headers, params or cookies is supposed to be specified.";
          type = (types.nullOr (types.listOf types.str));
        };
        "params" = mkOption {
          description = "Params is the names of the query parameter to fetch the key from.\nIf multiple params are specified, envoy will look for the api key in the order of the list.\nThis field is optional, but only one of headers, params or cookies is supposed to be specified.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "cookies" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "params" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorization" = {

      options = {
        "defaultAction" = mkOption {
          description = "DefaultAction defines the default action to be taken if no rules match.\nIf not specified, the default action is Deny.";
          type = (types.nullOr types.str);
        };
        "rules" = mkOption {
          description = "Rules defines a list of authorization rules.\nThese rules are evaluated in order, the first matching rule will be applied,\nand the rest will be skipped.\n\nFor example, if there are two rules: the first rule allows the request\nand the second rule denies it, when a request matches both rules, it will be allowed.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorizationRules"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "defaultAction" = mkOverride 1002 null;
        "rules" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorizationRules" = {

      options = {
        "action" = mkOption {
          description = "Action defines the action to be taken if the rule matches.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is a user-friendly name for the rule.\nIf not specified, Envoy Gateway will generate a unique name for the rule.";
          type = (types.nullOr types.str);
        };
        "operation" = mkOption {
          description = "Operation specifies the operation of a request, such as HTTP methods.\nIf not specified, all operations are matched on.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorizationRulesOperation"
            )
          );
        };
        "principal" = mkOption {
          description = "Principal specifies the client identity of a request.\nIf there are multiple principal types, all principals must match for the rule to match.\nFor example, if there are two principals: one for client IP and one for JWT claim,\nthe rule will match only if both the client IP and the JWT claim match.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipal");
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "operation" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorizationRulesOperation" = {

      options = {
        "methods" = mkOption {
          description = "Methods are the HTTP methods of the request.\nIf multiple methods are specified, all specified methods are allowed or denied, based on the action of the rule.";
          type = (types.listOf types.str);
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipal" = {

      options = {
        "clientCIDRs" = mkOption {
          description = "ClientCIDRs are the IP CIDR ranges of the client.\nValid examples are \"192.168.1.0/24\" or \"2001:db8::/64\"\n\nIf multiple CIDR ranges are specified, one of the CIDR ranges must match\nthe client IP for the rule to match.\n\nThe client IP is inferred from the X-Forwarded-For header, a custom header,\nor the proxy protocol.\nYou can use the `ClientIPDetection` or the `ProxyProtocol` field in\nthe `ClientTrafficPolicy` to configure how the client IP is detected.\n\nFor TCPRoute targets (raw TCP connections), HTTP headers such as\nX-Forwarded-For are not available. The client IP is obtained from the\nTCP connection's peer address. If intermediaries (load balancers, NAT)\nterminate or proxy TCP, the original client IP will only be available\nif the intermediary preserves the source address (for example by\nenabling the PROXY protocol or avoiding SNAT). Ensure your L4 proxy is\nconfigured to preserve the source IP to enable correct client-IP\nmatching for TCPRoute targets.";
          type = (types.nullOr (types.listOf types.str));
        };
        "headers" = mkOption {
          description = "Headers authorize the request based on user identity extracted from custom headers.\nIf multiple headers are specified, all headers must match for the rule to match.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipalHeaders"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "jwt" = mkOption {
          description = "JWT authorize the request based on the JWT claims and scopes.\nNote: in order to use JWT claims for authorization, you must configure the\nJWT authentication in the same `SecurityPolicy`.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipalJwt"
            )
          );
        };
        "sourceCIDRs" = mkOption {
          description = "SourceCIDRs are the IP CIDR ranges of the source (L4 peer IP).\nValid examples are \"192.168.1.0/24\" or \"2001:db8::/64\"\n\nIf multiple CIDR ranges are specified, one of the CIDR ranges must match\nthe source IP for the rule to match.\n\nThe source IP is the IP address of the peer that connected to Envoy.\nThis IP is obtained from the TCP connection's peer address and is not\naffected by X-Forwarded-For or other IP detection headers.\nIf intermediaries (load balancers, NAT) terminate or proxy TCP,\nthe original client IP will only be available if the intermediary\npreserves the source address (for example by enabling the PROXY protocol\nor avoiding SNAT).";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "clientCIDRs" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "jwt" = mkOverride 1002 null;
        "sourceCIDRs" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipalHeaders" = {

      options = {
        "name" = mkOption {
          description = "Name of the HTTP header.\nThe header name is case-insensitive unless PreserveHeaderCase is set to true.\nFor example, \"Foo\" and \"foo\" are considered the same header.";
          type = types.str;
        };
        "values" = mkOption {
          description = "Values are the values that the header must match.\nIf multiple values are specified, the rule will match if any of the values match.";
          type = (types.listOf types.str);
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipalJwt" = {

      options = {
        "claims" = mkOption {
          description = "Claims are the claims in a JWT token.\n\nIf multiple claims are specified, all claims must match for the rule to match.\nFor example, if there are two claims: one for the audience and one for the issuer,\nthe rule will match only if both the audience and the issuer match.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "provider" = mkOption {
          description = "Provider is the name of the JWT provider that used to verify the JWT token.\nIn order to use JWT claims for authorization, you must configure the JWT\nauthentication with the same provider in the same `SecurityPolicy`.";
          type = types.str;
        };
        "scopes" = mkOption {
          description = "Scopes are a special type of claim in a JWT token that represents the permissions of the client.\n\nThe value of the scopes field should be a space delimited string that is expected in the\nscope (or scp) claim, as defined in RFC 6749: https://datatracker.ietf.org/doc/html/rfc6749#page-23.\n\nIf multiple scopes are specified, all scopes must match for the rule to match.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims" = {

      options = {
        "name" = mkOption {
          description = "Name is the name of the claim.\nIf it is a nested claim, use a dot (.) separated string as the name to\nrepresent the full path to the claim.\nFor example, if the claim is in the \"department\" field in the \"organization\" field,\nthe name should be \"organization.department\".";
          type = types.str;
        };
        "valueType" = mkOption {
          description = "ValueType is the type of the claim value.\nOnly String and StringArray types are supported for now.";
          type = (types.nullOr types.str);
        };
        "values" = mkOption {
          description = "Values are the values that the claim must match.\nIf the claim is a string type, the specified value must match exactly.\nIf the claim is a string array type, the specified value must match one of the values in the array.\nIf multiple values are specified, one of the values must match for the rule to match.";
          type = (types.listOf types.str);
        };
      };

      config = {
        "valueType" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecBasicAuth" = {

      options = {
        "forwardUsernameHeader" = mkOption {
          description = "This field specifies the header name to forward a successfully authenticated user to\nthe backend. The header will be added to the request with the username as the value.\n\nIf it is not specified, the username will not be forwarded.";
          type = (types.nullOr types.str);
        };
        "users" = mkOption {
          description = "The Kubernetes secret which contains the username-password pairs in\nhtpasswd format, used to verify user credentials in the \"Authorization\"\nheader.\n\nThis is an Opaque secret. The username-password pairs should be stored in\nthe key \".htpasswd\". As the key name indicates, the value needs to be the\nhtpasswd format, for example: \"user1:{SHA}hashed_user1_password\".\nRight now, only SHA hash algorithm is supported.\nReference to https://httpd.apache.org/docs/2.4/programs/htpasswd.html\nfor more details.\n\nNote: The secret must be in the same namespace as the SecurityPolicy.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecBasicAuthUsers");
        };
      };

      config = {
        "forwardUsernameHeader" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecBasicAuthUsers" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"Secret\".";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referenced object. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecCors" = {

      options = {
        "allowCredentials" = mkOption {
          description = "AllowCredentials indicates whether a request can include user credentials\nlike cookies, authentication headers, or TLS client certificates.\nIt specifies the value in the Access-Control-Allow-Credentials CORS response header.";
          type = (types.nullOr types.bool);
        };
        "allowHeaders" = mkOption {
          description = "AllowHeaders defines the headers that are allowed to be sent with requests.\nIt specifies the allowed headers in the Access-Control-Allow-Headers CORS response header..\nThe value \"*\" allows any header to be sent.";
          type = (types.nullOr (types.listOf types.str));
        };
        "allowMethods" = mkOption {
          description = "AllowMethods defines the methods that are allowed to make requests.\nIt specifies the allowed methods in the Access-Control-Allow-Methods CORS response header..\nThe value \"*\" allows any method to be used.";
          type = (types.nullOr (types.listOf types.str));
        };
        "allowOrigins" = mkOption {
          description = "AllowOrigins defines the origins that are allowed to make requests.\nIt specifies the allowed origins in the Access-Control-Allow-Origin CORS response header.\nThe value \"*\" allows any origin to make requests.";
          type = (types.nullOr (types.listOf types.str));
        };
        "exposeHeaders" = mkOption {
          description = "ExposeHeaders defines which response headers should be made accessible to\nscripts running in the browser.\nIt specifies the headers in the Access-Control-Expose-Headers CORS response header..\nThe value \"*\" allows any header to be exposed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "maxAge" = mkOption {
          description = "MaxAge defines how long the results of a preflight request can be cached.\nIt specifies the value in the Access-Control-Max-Age CORS response header..";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "allowCredentials" = mkOverride 1002 null;
        "allowHeaders" = mkOverride 1002 null;
        "allowMethods" = mkOverride 1002 null;
        "allowOrigins" = mkOverride 1002 null;
        "exposeHeaders" = mkOverride 1002 null;
        "maxAge" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuth" = {

      options = {
        "bodyToExtAuth" = mkOption {
          description = "BodyToExtAuth defines the Body to Ext Auth configuration.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthBodyToExtAuth")
          );
        };
        "contextExtensions" = mkOption {
          description = "ContextExtensions are analogous to http_request.headers, however these\ncontents will not be sent to the upstream server. This provides an\nextension mechanism for sending additional information to the auth server\nwithout modifying the proto definition. It maps to the internal opaque\ncontext in the filter chain.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthContextExtensions"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "failOpen" = mkOption {
          description = "FailOpen is a switch used to control the behavior when a response from the External Authorization service cannot be obtained.\nIf FailOpen is set to true, the system allows the traffic to pass through.\nOtherwise, if it is set to false or not set (defaulting to false),\nthe system blocks the traffic and returns a HTTP 5xx error, reflecting a fail-closed approach.\nThis setting determines whether to prioritize accessibility over strict security in case of authorization service failure.\n\nIf set to true, the External Authorization will also be bypassed if its configuration is invalid.";
          type = (types.nullOr types.bool);
        };
        "grpc" = mkOption {
          description = "GRPC defines the gRPC External Authorization service.\nEither GRPCService or HTTPService must be specified,\nand only one of them can be provided.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpc"));
        };
        "headersToExtAuth" = mkOption {
          description = "HeadersToExtAuth defines the client request headers that will be included\nin the request to the external authorization service.\nNote: If not specified, the default behavior for gRPC and HTTP external\nauthorization services is different due to backward compatibility reasons.\nAll headers will be included in the check request to a gRPC authorization server.\nOnly the following headers will be included in the check request to an HTTP\nauthorization server: Host, Method, Path, Content-Length, and Authorization.\nAnd these headers will always be included to the check request to an HTTP\nauthorization server by default, no matter whether they are specified\nin HeadersToExtAuth or not.";
          type = (types.nullOr (types.listOf types.str));
        };
        "http" = mkOption {
          description = "HTTP defines the HTTP External Authorization service.\nEither GRPCService or HTTPService must be specified,\nand only one of them can be provided.";
          type = (types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttp"));
        };
        "recomputeRoute" = mkOption {
          description = "RecomputeRoute clears the route cache and recalculates the routing decision.\nThis field must be enabled if the headers added or modified by the ExtAuth are used for\nroute matching decisions. If the recomputation selects a new route, features targeting\nthe new matched route will be applied.";
          type = (types.nullOr types.bool);
        };
        "timeout" = mkOption {
          description = "Timeout defines the timeout for requests to the external authorization service.\nIf not specified, defaults to 10 seconds.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "bodyToExtAuth" = mkOverride 1002 null;
        "contextExtensions" = mkOverride 1002 null;
        "failOpen" = mkOverride 1002 null;
        "grpc" = mkOverride 1002 null;
        "headersToExtAuth" = mkOverride 1002 null;
        "http" = mkOverride 1002 null;
        "recomputeRoute" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthBodyToExtAuth" = {

      options = {
        "maxRequestBytes" = mkOption {
          description = "MaxRequestBytes is the maximum size of a message body that the filter will hold in memory.\nEnvoy will return HTTP 413 and will not initiate the authorization process when buffer\nreaches the number set in this field.\nNote that this setting will have precedence over failOpen mode.";
          type = types.int;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthContextExtensions" = {

      options = {
        "name" = mkOption {
          description = "Name of the context extension.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type is the type of method to use to read the ContextExtension value.\nValid values are Value and ValueRef, default is Value.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Value of the context extension.";
          type = (types.nullOr types.str);
        };
        "valueRef" = mkOption {
          description = "ValueRef for the context extension's value.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthContextExtensionsValueRef"
            )
          );
        };
      };

      config = {
        "value" = mkOverride 1002 null;
        "valueRef" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthContextExtensionsValueRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = types.str;
        };
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"HTTPRoute\" or \"Service\".";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpc" = {

      options = {
        "backendRef" = mkOption {
          description = "BackendRef references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.\n\nDeprecated: Use BackendRefs instead.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendRef")
          );
        };
        "backendRefs" = mkOption {
          description = "BackendRefs references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "backendSettings" = mkOption {
          description = "BackendSettings holds configuration for managing the connection\nto the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettings"
            )
          );
        };
      };

      config = {
        "backendRef" = mkOverride 1002 null;
        "backendRefs" = mkOverride 1002 null;
        "backendSettings" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendRefs" = {

      options = {
        "fallback" = mkOption {
          description = "Fallback indicates whether the backend is designated as a fallback.\nMultiple fallback backends can be configured.\nIt is highly recommended to configure active or passive health checks to ensure that failover can be detected\nwhen the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.\nThe overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when\nthe health of the active backends falls below 72%.";
          type = (types.nullOr types.bool);
        };
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
        "weight" = mkOption {
          description = "Weight specifies the proportion of requests forwarded to the referenced\nbackend. This is computed as weight/(sum of all weights in this\nBackendRefs list). For non-zero values, there may be some epsilon from\nthe exact proportion defined here depending on the precision an\nimplementation supports. Weight is not a percentage and the sum of\nweights does not need to equal 100.\n\nIf only one backend is specified and it has a weight greater than 0, 100%\nof the traffic is forwarded to that backend. If weight is set to 0, no\ntraffic should be forwarded for this entry. If unspecified, weight\ndefaults to 1.\n\nSupport for this field varies based on the context where used.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "fallback" = mkOverride 1002 null;
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "weight" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettings" = {

      options = {
        "circuitBreaker" = mkOption {
          description = "Circuit Breaker settings for the upstream connections and requests.\nIf not set, circuit breakers will be enabled with the default thresholds";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker"
            )
          );
        };
        "connection" = mkOption {
          description = "Connection includes backend connection settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsConnection"
            )
          );
        };
        "dns" = mkOption {
          description = "DNS includes dns resolution settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsDns"
            )
          );
        };
        "healthCheck" = mkOption {
          description = "HealthCheck allows gateway to perform active health checking on backends.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck"
            )
          );
        };
        "http2" = mkOption {
          description = "HTTP2 provides HTTP/2 configuration for backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2"
            )
          );
        };
        "loadBalancer" = mkOption {
          description = "LoadBalancer policy to apply when routing traffic from the gateway to\nthe backend endpoints. Defaults to `LeastRequest`.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer"
            )
          );
        };
        "proxyProtocol" = mkOption {
          description = "ProxyProtocol enables the Proxy Protocol when communicating with the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocol"
            )
          );
        };
        "retry" = mkOption {
          description = "Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.\nIf not set, retry will be disabled.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetry"
            )
          );
        };
        "tcpKeepalive" = mkOption {
          description = "TcpKeepalive settings associated with the upstream client connection.\nDisabled by default.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout settings for the backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTimeout"
            )
          );
        };
      };

      config = {
        "circuitBreaker" = mkOverride 1002 null;
        "connection" = mkOverride 1002 null;
        "dns" = mkOverride 1002 null;
        "healthCheck" = mkOverride 1002 null;
        "http2" = mkOverride 1002 null;
        "loadBalancer" = mkOverride 1002 null;
        "proxyProtocol" = mkOverride 1002 null;
        "retry" = mkOverride 1002 null;
        "tcpKeepalive" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker" = {

      options = {
        "maxConnections" = mkOption {
          description = "The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxParallelRequests" = mkOption {
          description = "The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxParallelRetries" = mkOption {
          description = "The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxPendingRequests" = mkOption {
          description = "The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxRequestsPerConnection" = mkOption {
          description = "The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.\nDefault: unlimited.";
          type = (types.nullOr types.int);
        };
        "perEndpoint" = mkOption {
          description = "PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpoint"
            )
          );
        };
      };

      config = {
        "maxConnections" = mkOverride 1002 null;
        "maxParallelRequests" = mkOverride 1002 null;
        "maxParallelRetries" = mkOverride 1002 null;
        "maxPendingRequests" = mkOverride 1002 null;
        "maxRequestsPerConnection" = mkOverride 1002 null;
        "perEndpoint" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpoint" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsConnection" = {

      options = {
        "bufferLimit" = mkOption {
          description = "BufferLimit Soft limit on size of the cluster’s connections read and write buffers.\nBufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.\nIf unspecified, an implementation defined default is applied (32768 bytes).\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote: that when the suffix is not provided, the value is interpreted as bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "preconnect" = mkOption {
          description = "Preconnect configures proactive upstream connections to reduce latency by establishing\nconnections before they’re needed and avoiding connection establishment overhead.\n\nIf unset, Envoy will fetch connections as needed to serve in-flight requests.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionPreconnect"
            )
          );
        };
        "socketBufferLimit" = mkOption {
          description = "SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket\nto backend.\nSocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote that when the suffix is not provided, the value is interpreted as bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "bufferLimit" = mkOverride 1002 null;
        "preconnect" = mkOverride 1002 null;
        "socketBufferLimit" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionPreconnect" =
      {

        options = {
          "perEndpointPercent" = mkOption {
            description = "PerEndpointPercent configures how many additional connections to maintain per\nupstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a\npercentage of the connections required by active streams\n(e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).\n\nAllowed value range is between 100-300. When both PerEndpointPercent and\nPredictivePercent are set, Envoy ensures both are satisfied (max of the two).";
            type = (types.nullOr types.int);
          };
          "predictivePercent" = mkOption {
            description = "PredictivePercent configures how many additional connections to maintain\nacross the cluster by anticipating which upstream endpoint the load balancer\nwill select next, useful for low-QPS services. Relies on deterministic\nloadbalancing and is only supported with Random or RoundRobin.\nExpressed as a percentage of the connections required by active streams\n(e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).\n\nMinimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are\nset Envoy ensures both are satisfied per host (max of the two).";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "perEndpointPercent" = mkOverride 1002 null;
          "predictivePercent" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsDns" = {

      options = {
        "dnsRefreshRate" = mkOption {
          description = "DNSRefreshRate specifies the rate at which DNS records should be refreshed.\nDefaults to 30 seconds.";
          type = (types.nullOr types.str);
        };
        "lookupFamily" = mkOption {
          description = "LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).\nIf set, this configuration overrides other defaults.";
          type = (types.nullOr types.str);
        };
        "respectDnsTtl" = mkOption {
          description = "RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.\nIf the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.\nDefaults to true.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "dnsRefreshRate" = mkOverride 1002 null;
        "lookupFamily" = mkOverride 1002 null;
        "respectDnsTtl" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck" = {

      options = {
        "active" = mkOption {
          description = "Active health check configuration";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive"
            )
          );
        };
        "panicThreshold" = mkOption {
          description = "When number of unhealthy endpoints for a backend reaches this threshold\nEnvoy will disregard health status and balance across all endpoints.\nIt's designed to prevent a situation in which host failures cascade throughout the cluster\nas load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.";
          type = (types.nullOr types.int);
        };
        "passive" = mkOption {
          description = "Passive passive check configuration";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive"
            )
          );
        };
      };

      config = {
        "active" = mkOverride 1002 null;
        "panicThreshold" = mkOverride 1002 null;
        "passive" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive" = {

      options = {
        "grpc" = mkOption {
          description = "GRPC defines the configuration of the GRPC health checker.\nIt's optional, and can only be used if the specified type is GRPC.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpc"
            )
          );
        };
        "healthyThreshold" = mkOption {
          description = "HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.";
          type = (types.nullOr types.int);
        };
        "http" = mkOption {
          description = "HTTP defines the configuration of http health checker.\nIt's required while the health checker type is HTTP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp"
            )
          );
        };
        "initialJitter" = mkOption {
          description = "InitialJitter defines the maximum time Envoy will wait before the first health check.\nEnvoy will randomly select a value between 0 and the initial jitter value.";
          type = (types.nullOr types.str);
        };
        "interval" = mkOption {
          description = "Interval defines the time between active health checks.";
          type = (types.nullOr types.str);
        };
        "tcp" = mkOption {
          description = "TCP defines the configuration of tcp health checker.\nIt's required while the health checker type is TCP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcp"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout defines the time to wait for a health check response.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type defines the type of health checker.";
          type = types.str;
        };
        "unhealthyThreshold" = mkOption {
          description = "UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "grpc" = mkOverride 1002 null;
        "healthyThreshold" = mkOverride 1002 null;
        "http" = mkOverride 1002 null;
        "initialJitter" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "tcp" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
        "unhealthyThreshold" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpc" =
      {

        options = {
          "service" = mkOption {
            description = "Service to send in the health check request.\nIf this is not specified, then the health check request applies to the entire\nserver and not to a specific service.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "service" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp" =
      {

        options = {
          "expectedResponse" = mkOption {
            description = "ExpectedResponse defines a list of HTTP expected responses to match.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse"
              )
            );
          };
          "expectedStatuses" = mkOption {
            description = "ExpectedStatuses defines a list of HTTP response statuses considered healthy.\nDefaults to 200 only";
            type = (types.nullOr (types.listOf types.int));
          };
          "hostname" = mkOption {
            description = "Hostname defines the HTTP host that will be requested during health checking.\nDefault: HTTPRoute or GRPCRoute hostname.";
            type = (types.nullOr types.str);
          };
          "method" = mkOption {
            description = "Method defines the HTTP method used for health checking.\nDefaults to GET";
            type = (types.nullOr types.str);
          };
          "path" = mkOption {
            description = "Path defines the HTTP path that will be requested during health checking.";
            type = types.str;
          };
        };

        config = {
          "expectedResponse" = mkOverride 1002 null;
          "expectedStatuses" = mkOverride 1002 null;
          "hostname" = mkOverride 1002 null;
          "method" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcp" =
      {

        options = {
          "receive" = mkOption {
            description = "Receive defines the expected response payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive"
              )
            );
          };
          "send" = mkOption {
            description = "Send defines the request payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend"
              )
            );
          };
        };

        config = {
          "receive" = mkOverride 1002 null;
          "send" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive" = {

      options = {
        "baseEjectionTime" = mkOption {
          description = "BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.";
          type = (types.nullOr types.str);
        };
        "consecutive5XxErrors" = mkOption {
          description = "Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.";
          type = (types.nullOr types.int);
        };
        "consecutiveGatewayErrors" = mkOption {
          description = "ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.";
          type = (types.nullOr types.int);
        };
        "consecutiveLocalOriginFailures" = mkOption {
          description = "ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.\nParameter takes effect only when split_external_local_origin_errors is set to true.";
          type = (types.nullOr types.int);
        };
        "failurePercentageThreshold" = mkOption {
          description = "FailurePercentageThreshold sets the failure percentage threshold for outlier detection.\nIf the failure percentage of a given host is greater than or equal to this value, it will be ejected.\nDefaults to 85.";
          type = (types.nullOr types.int);
        };
        "interval" = mkOption {
          description = "Interval defines the time between passive health checks.";
          type = (types.nullOr types.str);
        };
        "maxEjectionPercent" = mkOption {
          description = "MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.";
          type = (types.nullOr types.int);
        };
        "splitExternalLocalOriginErrors" = mkOption {
          description = "SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "baseEjectionTime" = mkOverride 1002 null;
        "consecutive5XxErrors" = mkOverride 1002 null;
        "consecutiveGatewayErrors" = mkOverride 1002 null;
        "consecutiveLocalOriginFailures" = mkOverride 1002 null;
        "failurePercentageThreshold" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "maxEjectionPercent" = mkOverride 1002 null;
        "splitExternalLocalOriginErrors" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2" = {

      options = {
        "initialConnectionWindowSize" = mkOption {
          description = "InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.\nIf not set, the default value is 1 MiB.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "initialStreamWindowSize" = mkOption {
          description = "InitialStreamWindowSize sets the initial window size for HTTP/2 streams.\nIf not set, the default value is 64 KiB(64*1024).";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxConcurrentStreams" = mkOption {
          description = "MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.\nIf not set, the default value is 100.";
          type = (types.nullOr types.int);
        };
        "onInvalidMessage" = mkOption {
          description = "OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error\nIt's recommended for L2 Envoy deployments to set this value to TerminateStream.\nhttps://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two\nDefault: TerminateConnection";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "initialConnectionWindowSize" = mkOverride 1002 null;
        "initialStreamWindowSize" = mkOverride 1002 null;
        "maxConcurrentStreams" = mkOverride 1002 null;
        "onInvalidMessage" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer" = {

      options = {
        "consistentHash" = mkOption {
          description = "ConsistentHash defines the configuration when the load balancer type is\nset to ConsistentHash";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash"
            )
          );
        };
        "endpointOverride" = mkOption {
          description = "EndpointOverride defines the configuration for endpoint override.\nWhen specified, the load balancer will attempt to route requests to endpoints\nbased on the override information extracted from request headers or metadata.\n If the override endpoints are not available, the configured load balancer policy will be used as fallback.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverride"
            )
          );
        };
        "slowStart" = mkOption {
          description = "SlowStart defines the configuration related to the slow start load balancer policy.\nIf set, during slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently this is only supported for RoundRobin and LeastRequest load balancers";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStart"
            )
          );
        };
        "type" = mkOption {
          description = "Type decides the type of Load Balancer policy.\nValid LoadBalancerType values are\n\"ConsistentHash\",\n\"LeastRequest\",\n\"Random\",\n\"RoundRobin\".";
          type = types.str;
        };
        "zoneAware" = mkOption {
          description = "ZoneAware defines the configuration related to the distribution of requests between locality zones.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAware"
            )
          );
        };
      };

      config = {
        "consistentHash" = mkOverride 1002 null;
        "endpointOverride" = mkOverride 1002 null;
        "slowStart" = mkOverride 1002 null;
        "zoneAware" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash" =
      {

        options = {
          "cookie" = mkOption {
            description = "Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie"
              )
            );
          };
          "header" = mkOption {
            description = "Header configures the header hash policy when the consistent hash type is set to Header.\n\nDeprecated: use Headers instead";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeader"
              )
            );
          };
          "headers" = mkOption {
            description = "Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "queryParams" = mkOption {
            description = "QueryParams configures the query parameter hash policy when the consistent hash type is set to QueryParams.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashQueryParams"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "tableSize" = mkOption {
            description = "The table size for consistent hashing, must be prime number limited to 5000011.";
            type = (types.nullOr types.int);
          };
          "type" = mkOption {
            description = "ConsistentHashType defines the type of input to hash on. Valid Type values are\n\"SourceIP\",\n\"Header\",\n\"Headers\",\n\"Cookie\".\n\"QueryParams\".";
            type = types.str;
          };
        };

        config = {
          "cookie" = mkOverride 1002 null;
          "header" = mkOverride 1002 null;
          "headers" = mkOverride 1002 null;
          "queryParams" = mkOverride 1002 null;
          "tableSize" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie" =
      {

        options = {
          "attributes" = mkOption {
            description = "Additional Attributes to set for the generated cookie.";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "name" = mkOption {
            description = "Name of the cookie to hash.\nIf this cookie does not exist in the request, Envoy will generate a cookie and set\nthe TTL on the response back to the client based on Layer 4\nattributes of the backend endpoint, to ensure that these future requests\ngo to the same backend endpoint. Make sure to set the TTL field for this case.";
            type = types.str;
          };
          "ttl" = mkOption {
            description = "TTL of the generated cookie if the cookie is not present. This value sets the\nMax-Age attribute value.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "attributes" = mkOverride 1002 null;
          "ttl" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeader" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashQueryParams" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the query param to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverride" =
      {

        options = {
          "extractFrom" = mkOption {
            description = "ExtractFrom defines the sources to extract endpoint override information from.";
            type = (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFrom"
              )
            );
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFrom" =
      {

        options = {
          "header" = mkOption {
            description = "Header defines the header to get the override endpoint addresses.\nThe header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.\nFor example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.\nThe IPv6 address is enclosed in square brackets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "header" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStart" =
      {

        options = {
          "window" = mkOption {
            description = "Window defines the duration of the warm up period for newly added host.\nDuring slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently only supports linear growth of traffic. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAware" =
      {

        options = {
          "preferLocal" = mkOption {
            description = "PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal"
              )
            );
          };
        };

        config = {
          "preferLocal" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal" =
      {

        options = {
          "force" = mkOption {
            description = "ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior\nwhich maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForce"
              )
            );
          };
          "minEndpointsThreshold" = mkOption {
            description = "MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.";
            type = (types.nullOr types.int);
          };
          "percentageEnabled" = mkOption {
            description = "Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "force" = mkOverride 1002 null;
          "minEndpointsThreshold" = mkOverride 1002 null;
          "percentageEnabled" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForce" =
      {

        options = {
          "minEndpointsInZoneThreshold" = mkOption {
            description = "MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone\noverride. This is useful for protecting zones with fewer endpoints.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "minEndpointsInZoneThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocol" = {

      options = {
        "version" = mkOption {
          description = "Version of ProxyProtol\nValid ProxyProtocolVersion values are\n\"V1\"\n\"V2\"";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetry" = {

      options = {
        "numAttemptsPerPriority" = mkOption {
          description = "NumAttemptsPerPriority defines the number of requests (initial attempt + retries)\nthat should be sent to the same priority before switching to a different one.\nIf not specified or set to 0, all requests are sent to the highest priority that is healthy.";
          type = (types.nullOr types.int);
        };
        "numRetries" = mkOption {
          description = "NumRetries is the number of retries to be attempted. Defaults to 2.";
          type = (types.nullOr types.int);
        };
        "perRetry" = mkOption {
          description = "PerRetry is the retry policy to be applied per retry attempt.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetry"
            )
          );
        };
        "retryOn" = mkOption {
          description = "RetryOn specifies the retry trigger condition.\n\nIf not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOn"
            )
          );
        };
      };

      config = {
        "numAttemptsPerPriority" = mkOverride 1002 null;
        "numRetries" = mkOverride 1002 null;
        "perRetry" = mkOverride 1002 null;
        "retryOn" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetry" = {

      options = {
        "backOff" = mkOption {
          description = "Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential\nback-off algorithm for retries. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOff"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout is the timeout per retry attempt.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "backOff" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOff" =
      {

        options = {
          "baseInterval" = mkOption {
            description = "BaseInterval is the base interval between retries.";
            type = (types.nullOr types.str);
          };
          "maxInterval" = mkOption {
            description = "MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.\nThe default is 10 times the base_interval";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "baseInterval" = mkOverride 1002 null;
          "maxInterval" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOn" = {

      options = {
        "httpStatusCodes" = mkOption {
          description = "HttpStatusCodes specifies the http status codes to be retried.\nThe retriable-status-codes trigger must also be configured for these status codes to trigger a retry.";
          type = (types.nullOr (types.listOf types.int));
        };
        "triggers" = mkOption {
          description = "Triggers specifies the retry trigger condition(Http/Grpc).";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "httpStatusCodes" = mkOverride 1002 null;
        "triggers" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive" = {

      options = {
        "idleTime" = mkOption {
          description = "The duration a connection needs to be idle before keep-alive\nprobes start being sent.\nThe duration format is\nDefaults to `7200s`.";
          type = (types.nullOr types.str);
        };
        "interval" = mkOption {
          description = "The duration between keep-alive probes.\nDefaults to `75s`.";
          type = (types.nullOr types.str);
        };
        "probes" = mkOption {
          description = "The total number of unacknowledged probes to send before deciding\nthe connection is dead.\nDefaults to 9.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "idleTime" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "probes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTimeout" = {

      options = {
        "http" = mkOption {
          description = "Timeout settings for HTTP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp"
            )
          );
        };
        "tcp" = mkOption {
          description = "Timeout settings for TCP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcp"
            )
          );
        };
      };

      config = {
        "http" = mkOverride 1002 null;
        "tcp" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp" = {

      options = {
        "connectionIdleTimeout" = mkOption {
          description = "The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.\nDefault: 1 hour.";
          type = (types.nullOr types.str);
        };
        "maxConnectionDuration" = mkOption {
          description = "The maximum duration of an HTTP connection.\nDefault: unlimited.";
          type = (types.nullOr types.str);
        };
        "maxStreamDuration" = mkOption {
          description = "MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time\nfrom when the request is sent until the response stream is fully consumed and does not apply to\nnon-streaming requests.\nWhen set to \"0s\", no max duration is applied and streams can run indefinitely.";
          type = (types.nullOr types.str);
        };
        "requestTimeout" = mkOption {
          description = "RequestTimeout is the time until which entire response is received from the upstream.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "connectionIdleTimeout" = mkOverride 1002 null;
        "maxConnectionDuration" = mkOverride 1002 null;
        "maxStreamDuration" = mkOverride 1002 null;
        "requestTimeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcp" = {

      options = {
        "connectTimeout" = mkOption {
          description = "The timeout for network connection establishment, including TCP and TLS handshakes.\nDefault: 10 seconds.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "connectTimeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttp" = {

      options = {
        "backendRef" = mkOption {
          description = "BackendRef references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.\n\nDeprecated: Use BackendRefs instead.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendRef")
          );
        };
        "backendRefs" = mkOption {
          description = "BackendRefs references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "backendSettings" = mkOption {
          description = "BackendSettings holds configuration for managing the connection\nto the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettings"
            )
          );
        };
        "headersToBackend" = mkOption {
          description = "HeadersToBackend are the authorization response headers that will be added\nto the original client request before sending it to the backend server.\nNote that coexisting headers will be overridden.\nIf not specified, no authorization response headers will be added to the\noriginal client request.";
          type = (types.nullOr (types.listOf types.str));
        };
        "path" = mkOption {
          description = "Path is the path of the HTTP External Authorization service.\nIf path is specified, the authorization request will be sent to that path,\nor else the authorization request will use the path of the original request.\n\nPlease note that the original request path will be appended to the path specified here.\nFor example, if the original request path is \"/hello\", and the path specified here is \"/auth\",\nthen the path of the authorization request will be \"/auth/hello\". If the path is not specified,\nthe path of the authorization request will be \"/hello\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "backendRef" = mkOverride 1002 null;
        "backendRefs" = mkOverride 1002 null;
        "backendSettings" = mkOverride 1002 null;
        "headersToBackend" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendRefs" = {

      options = {
        "fallback" = mkOption {
          description = "Fallback indicates whether the backend is designated as a fallback.\nMultiple fallback backends can be configured.\nIt is highly recommended to configure active or passive health checks to ensure that failover can be detected\nwhen the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.\nThe overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when\nthe health of the active backends falls below 72%.";
          type = (types.nullOr types.bool);
        };
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
        "weight" = mkOption {
          description = "Weight specifies the proportion of requests forwarded to the referenced\nbackend. This is computed as weight/(sum of all weights in this\nBackendRefs list). For non-zero values, there may be some epsilon from\nthe exact proportion defined here depending on the precision an\nimplementation supports. Weight is not a percentage and the sum of\nweights does not need to equal 100.\n\nIf only one backend is specified and it has a weight greater than 0, 100%\nof the traffic is forwarded to that backend. If weight is set to 0, no\ntraffic should be forwarded for this entry. If unspecified, weight\ndefaults to 1.\n\nSupport for this field varies based on the context where used.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "fallback" = mkOverride 1002 null;
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "weight" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettings" = {

      options = {
        "circuitBreaker" = mkOption {
          description = "Circuit Breaker settings for the upstream connections and requests.\nIf not set, circuit breakers will be enabled with the default thresholds";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker"
            )
          );
        };
        "connection" = mkOption {
          description = "Connection includes backend connection settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsConnection"
            )
          );
        };
        "dns" = mkOption {
          description = "DNS includes dns resolution settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsDns"
            )
          );
        };
        "healthCheck" = mkOption {
          description = "HealthCheck allows gateway to perform active health checking on backends.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck"
            )
          );
        };
        "http2" = mkOption {
          description = "HTTP2 provides HTTP/2 configuration for backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHttp2"
            )
          );
        };
        "loadBalancer" = mkOption {
          description = "LoadBalancer policy to apply when routing traffic from the gateway to\nthe backend endpoints. Defaults to `LeastRequest`.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer"
            )
          );
        };
        "proxyProtocol" = mkOption {
          description = "ProxyProtocol enables the Proxy Protocol when communicating with the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocol"
            )
          );
        };
        "retry" = mkOption {
          description = "Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.\nIf not set, retry will be disabled.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetry"
            )
          );
        };
        "tcpKeepalive" = mkOption {
          description = "TcpKeepalive settings associated with the upstream client connection.\nDisabled by default.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout settings for the backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTimeout"
            )
          );
        };
      };

      config = {
        "circuitBreaker" = mkOverride 1002 null;
        "connection" = mkOverride 1002 null;
        "dns" = mkOverride 1002 null;
        "healthCheck" = mkOverride 1002 null;
        "http2" = mkOverride 1002 null;
        "loadBalancer" = mkOverride 1002 null;
        "proxyProtocol" = mkOverride 1002 null;
        "retry" = mkOverride 1002 null;
        "tcpKeepalive" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker" = {

      options = {
        "maxConnections" = mkOption {
          description = "The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxParallelRequests" = mkOption {
          description = "The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxParallelRetries" = mkOption {
          description = "The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxPendingRequests" = mkOption {
          description = "The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxRequestsPerConnection" = mkOption {
          description = "The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.\nDefault: unlimited.";
          type = (types.nullOr types.int);
        };
        "perEndpoint" = mkOption {
          description = "PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpoint"
            )
          );
        };
      };

      config = {
        "maxConnections" = mkOverride 1002 null;
        "maxParallelRequests" = mkOverride 1002 null;
        "maxParallelRetries" = mkOverride 1002 null;
        "maxPendingRequests" = mkOverride 1002 null;
        "maxRequestsPerConnection" = mkOverride 1002 null;
        "perEndpoint" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpoint" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsConnection" = {

      options = {
        "bufferLimit" = mkOption {
          description = "BufferLimit Soft limit on size of the cluster’s connections read and write buffers.\nBufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.\nIf unspecified, an implementation defined default is applied (32768 bytes).\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote: that when the suffix is not provided, the value is interpreted as bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "preconnect" = mkOption {
          description = "Preconnect configures proactive upstream connections to reduce latency by establishing\nconnections before they’re needed and avoiding connection establishment overhead.\n\nIf unset, Envoy will fetch connections as needed to serve in-flight requests.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsConnectionPreconnect"
            )
          );
        };
        "socketBufferLimit" = mkOption {
          description = "SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket\nto backend.\nSocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote that when the suffix is not provided, the value is interpreted as bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "bufferLimit" = mkOverride 1002 null;
        "preconnect" = mkOverride 1002 null;
        "socketBufferLimit" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsConnectionPreconnect" =
      {

        options = {
          "perEndpointPercent" = mkOption {
            description = "PerEndpointPercent configures how many additional connections to maintain per\nupstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a\npercentage of the connections required by active streams\n(e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).\n\nAllowed value range is between 100-300. When both PerEndpointPercent and\nPredictivePercent are set, Envoy ensures both are satisfied (max of the two).";
            type = (types.nullOr types.int);
          };
          "predictivePercent" = mkOption {
            description = "PredictivePercent configures how many additional connections to maintain\nacross the cluster by anticipating which upstream endpoint the load balancer\nwill select next, useful for low-QPS services. Relies on deterministic\nloadbalancing and is only supported with Random or RoundRobin.\nExpressed as a percentage of the connections required by active streams\n(e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).\n\nMinimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are\nset Envoy ensures both are satisfied per host (max of the two).";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "perEndpointPercent" = mkOverride 1002 null;
          "predictivePercent" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsDns" = {

      options = {
        "dnsRefreshRate" = mkOption {
          description = "DNSRefreshRate specifies the rate at which DNS records should be refreshed.\nDefaults to 30 seconds.";
          type = (types.nullOr types.str);
        };
        "lookupFamily" = mkOption {
          description = "LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).\nIf set, this configuration overrides other defaults.";
          type = (types.nullOr types.str);
        };
        "respectDnsTtl" = mkOption {
          description = "RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.\nIf the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.\nDefaults to true.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "dnsRefreshRate" = mkOverride 1002 null;
        "lookupFamily" = mkOverride 1002 null;
        "respectDnsTtl" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck" = {

      options = {
        "active" = mkOption {
          description = "Active health check configuration";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive"
            )
          );
        };
        "panicThreshold" = mkOption {
          description = "When number of unhealthy endpoints for a backend reaches this threshold\nEnvoy will disregard health status and balance across all endpoints.\nIt's designed to prevent a situation in which host failures cascade throughout the cluster\nas load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.";
          type = (types.nullOr types.int);
        };
        "passive" = mkOption {
          description = "Passive passive check configuration";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive"
            )
          );
        };
      };

      config = {
        "active" = mkOverride 1002 null;
        "panicThreshold" = mkOverride 1002 null;
        "passive" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive" = {

      options = {
        "grpc" = mkOption {
          description = "GRPC defines the configuration of the GRPC health checker.\nIt's optional, and can only be used if the specified type is GRPC.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpc"
            )
          );
        };
        "healthyThreshold" = mkOption {
          description = "HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.";
          type = (types.nullOr types.int);
        };
        "http" = mkOption {
          description = "HTTP defines the configuration of http health checker.\nIt's required while the health checker type is HTTP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp"
            )
          );
        };
        "initialJitter" = mkOption {
          description = "InitialJitter defines the maximum time Envoy will wait before the first health check.\nEnvoy will randomly select a value between 0 and the initial jitter value.";
          type = (types.nullOr types.str);
        };
        "interval" = mkOption {
          description = "Interval defines the time between active health checks.";
          type = (types.nullOr types.str);
        };
        "tcp" = mkOption {
          description = "TCP defines the configuration of tcp health checker.\nIt's required while the health checker type is TCP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcp"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout defines the time to wait for a health check response.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type defines the type of health checker.";
          type = types.str;
        };
        "unhealthyThreshold" = mkOption {
          description = "UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "grpc" = mkOverride 1002 null;
        "healthyThreshold" = mkOverride 1002 null;
        "http" = mkOverride 1002 null;
        "initialJitter" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "tcp" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
        "unhealthyThreshold" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpc" =
      {

        options = {
          "service" = mkOption {
            description = "Service to send in the health check request.\nIf this is not specified, then the health check request applies to the entire\nserver and not to a specific service.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "service" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp" =
      {

        options = {
          "expectedResponse" = mkOption {
            description = "ExpectedResponse defines a list of HTTP expected responses to match.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse"
              )
            );
          };
          "expectedStatuses" = mkOption {
            description = "ExpectedStatuses defines a list of HTTP response statuses considered healthy.\nDefaults to 200 only";
            type = (types.nullOr (types.listOf types.int));
          };
          "hostname" = mkOption {
            description = "Hostname defines the HTTP host that will be requested during health checking.\nDefault: HTTPRoute or GRPCRoute hostname.";
            type = (types.nullOr types.str);
          };
          "method" = mkOption {
            description = "Method defines the HTTP method used for health checking.\nDefaults to GET";
            type = (types.nullOr types.str);
          };
          "path" = mkOption {
            description = "Path defines the HTTP path that will be requested during health checking.";
            type = types.str;
          };
        };

        config = {
          "expectedResponse" = mkOverride 1002 null;
          "expectedStatuses" = mkOverride 1002 null;
          "hostname" = mkOverride 1002 null;
          "method" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcp" =
      {

        options = {
          "receive" = mkOption {
            description = "Receive defines the expected response payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive"
              )
            );
          };
          "send" = mkOption {
            description = "Send defines the request payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend"
              )
            );
          };
        };

        config = {
          "receive" = mkOverride 1002 null;
          "send" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive" = {

      options = {
        "baseEjectionTime" = mkOption {
          description = "BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.";
          type = (types.nullOr types.str);
        };
        "consecutive5XxErrors" = mkOption {
          description = "Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.";
          type = (types.nullOr types.int);
        };
        "consecutiveGatewayErrors" = mkOption {
          description = "ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.";
          type = (types.nullOr types.int);
        };
        "consecutiveLocalOriginFailures" = mkOption {
          description = "ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.\nParameter takes effect only when split_external_local_origin_errors is set to true.";
          type = (types.nullOr types.int);
        };
        "failurePercentageThreshold" = mkOption {
          description = "FailurePercentageThreshold sets the failure percentage threshold for outlier detection.\nIf the failure percentage of a given host is greater than or equal to this value, it will be ejected.\nDefaults to 85.";
          type = (types.nullOr types.int);
        };
        "interval" = mkOption {
          description = "Interval defines the time between passive health checks.";
          type = (types.nullOr types.str);
        };
        "maxEjectionPercent" = mkOption {
          description = "MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.";
          type = (types.nullOr types.int);
        };
        "splitExternalLocalOriginErrors" = mkOption {
          description = "SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "baseEjectionTime" = mkOverride 1002 null;
        "consecutive5XxErrors" = mkOverride 1002 null;
        "consecutiveGatewayErrors" = mkOverride 1002 null;
        "consecutiveLocalOriginFailures" = mkOverride 1002 null;
        "failurePercentageThreshold" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "maxEjectionPercent" = mkOverride 1002 null;
        "splitExternalLocalOriginErrors" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHttp2" = {

      options = {
        "initialConnectionWindowSize" = mkOption {
          description = "InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.\nIf not set, the default value is 1 MiB.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "initialStreamWindowSize" = mkOption {
          description = "InitialStreamWindowSize sets the initial window size for HTTP/2 streams.\nIf not set, the default value is 64 KiB(64*1024).";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxConcurrentStreams" = mkOption {
          description = "MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.\nIf not set, the default value is 100.";
          type = (types.nullOr types.int);
        };
        "onInvalidMessage" = mkOption {
          description = "OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error\nIt's recommended for L2 Envoy deployments to set this value to TerminateStream.\nhttps://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two\nDefault: TerminateConnection";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "initialConnectionWindowSize" = mkOverride 1002 null;
        "initialStreamWindowSize" = mkOverride 1002 null;
        "maxConcurrentStreams" = mkOverride 1002 null;
        "onInvalidMessage" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer" = {

      options = {
        "consistentHash" = mkOption {
          description = "ConsistentHash defines the configuration when the load balancer type is\nset to ConsistentHash";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash"
            )
          );
        };
        "endpointOverride" = mkOption {
          description = "EndpointOverride defines the configuration for endpoint override.\nWhen specified, the load balancer will attempt to route requests to endpoints\nbased on the override information extracted from request headers or metadata.\n If the override endpoints are not available, the configured load balancer policy will be used as fallback.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverride"
            )
          );
        };
        "slowStart" = mkOption {
          description = "SlowStart defines the configuration related to the slow start load balancer policy.\nIf set, during slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently this is only supported for RoundRobin and LeastRequest load balancers";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStart"
            )
          );
        };
        "type" = mkOption {
          description = "Type decides the type of Load Balancer policy.\nValid LoadBalancerType values are\n\"ConsistentHash\",\n\"LeastRequest\",\n\"Random\",\n\"RoundRobin\".";
          type = types.str;
        };
        "zoneAware" = mkOption {
          description = "ZoneAware defines the configuration related to the distribution of requests between locality zones.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAware"
            )
          );
        };
      };

      config = {
        "consistentHash" = mkOverride 1002 null;
        "endpointOverride" = mkOverride 1002 null;
        "slowStart" = mkOverride 1002 null;
        "zoneAware" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash" =
      {

        options = {
          "cookie" = mkOption {
            description = "Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie"
              )
            );
          };
          "header" = mkOption {
            description = "Header configures the header hash policy when the consistent hash type is set to Header.\n\nDeprecated: use Headers instead";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeader"
              )
            );
          };
          "headers" = mkOption {
            description = "Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "queryParams" = mkOption {
            description = "QueryParams configures the query parameter hash policy when the consistent hash type is set to QueryParams.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashQueryParams"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "tableSize" = mkOption {
            description = "The table size for consistent hashing, must be prime number limited to 5000011.";
            type = (types.nullOr types.int);
          };
          "type" = mkOption {
            description = "ConsistentHashType defines the type of input to hash on. Valid Type values are\n\"SourceIP\",\n\"Header\",\n\"Headers\",\n\"Cookie\".\n\"QueryParams\".";
            type = types.str;
          };
        };

        config = {
          "cookie" = mkOverride 1002 null;
          "header" = mkOverride 1002 null;
          "headers" = mkOverride 1002 null;
          "queryParams" = mkOverride 1002 null;
          "tableSize" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie" =
      {

        options = {
          "attributes" = mkOption {
            description = "Additional Attributes to set for the generated cookie.";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "name" = mkOption {
            description = "Name of the cookie to hash.\nIf this cookie does not exist in the request, Envoy will generate a cookie and set\nthe TTL on the response back to the client based on Layer 4\nattributes of the backend endpoint, to ensure that these future requests\ngo to the same backend endpoint. Make sure to set the TTL field for this case.";
            type = types.str;
          };
          "ttl" = mkOption {
            description = "TTL of the generated cookie if the cookie is not present. This value sets the\nMax-Age attribute value.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "attributes" = mkOverride 1002 null;
          "ttl" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeader" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashQueryParams" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the query param to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverride" =
      {

        options = {
          "extractFrom" = mkOption {
            description = "ExtractFrom defines the sources to extract endpoint override information from.";
            type = (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFrom"
              )
            );
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFrom" =
      {

        options = {
          "header" = mkOption {
            description = "Header defines the header to get the override endpoint addresses.\nThe header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.\nFor example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.\nThe IPv6 address is enclosed in square brackets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "header" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStart" =
      {

        options = {
          "window" = mkOption {
            description = "Window defines the duration of the warm up period for newly added host.\nDuring slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently only supports linear growth of traffic. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAware" =
      {

        options = {
          "preferLocal" = mkOption {
            description = "PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal"
              )
            );
          };
        };

        config = {
          "preferLocal" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal" =
      {

        options = {
          "force" = mkOption {
            description = "ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior\nwhich maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForce"
              )
            );
          };
          "minEndpointsThreshold" = mkOption {
            description = "MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.";
            type = (types.nullOr types.int);
          };
          "percentageEnabled" = mkOption {
            description = "Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "force" = mkOverride 1002 null;
          "minEndpointsThreshold" = mkOverride 1002 null;
          "percentageEnabled" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForce" =
      {

        options = {
          "minEndpointsInZoneThreshold" = mkOption {
            description = "MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone\noverride. This is useful for protecting zones with fewer endpoints.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "minEndpointsInZoneThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocol" = {

      options = {
        "version" = mkOption {
          description = "Version of ProxyProtol\nValid ProxyProtocolVersion values are\n\"V1\"\n\"V2\"";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetry" = {

      options = {
        "numAttemptsPerPriority" = mkOption {
          description = "NumAttemptsPerPriority defines the number of requests (initial attempt + retries)\nthat should be sent to the same priority before switching to a different one.\nIf not specified or set to 0, all requests are sent to the highest priority that is healthy.";
          type = (types.nullOr types.int);
        };
        "numRetries" = mkOption {
          description = "NumRetries is the number of retries to be attempted. Defaults to 2.";
          type = (types.nullOr types.int);
        };
        "perRetry" = mkOption {
          description = "PerRetry is the retry policy to be applied per retry attempt.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetry"
            )
          );
        };
        "retryOn" = mkOption {
          description = "RetryOn specifies the retry trigger condition.\n\nIf not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOn"
            )
          );
        };
      };

      config = {
        "numAttemptsPerPriority" = mkOverride 1002 null;
        "numRetries" = mkOverride 1002 null;
        "perRetry" = mkOverride 1002 null;
        "retryOn" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetry" = {

      options = {
        "backOff" = mkOption {
          description = "Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential\nback-off algorithm for retries. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOff"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout is the timeout per retry attempt.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "backOff" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOff" =
      {

        options = {
          "baseInterval" = mkOption {
            description = "BaseInterval is the base interval between retries.";
            type = (types.nullOr types.str);
          };
          "maxInterval" = mkOption {
            description = "MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.\nThe default is 10 times the base_interval";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "baseInterval" = mkOverride 1002 null;
          "maxInterval" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOn" = {

      options = {
        "httpStatusCodes" = mkOption {
          description = "HttpStatusCodes specifies the http status codes to be retried.\nThe retriable-status-codes trigger must also be configured for these status codes to trigger a retry.";
          type = (types.nullOr (types.listOf types.int));
        };
        "triggers" = mkOption {
          description = "Triggers specifies the retry trigger condition(Http/Grpc).";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "httpStatusCodes" = mkOverride 1002 null;
        "triggers" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive" = {

      options = {
        "idleTime" = mkOption {
          description = "The duration a connection needs to be idle before keep-alive\nprobes start being sent.\nThe duration format is\nDefaults to `7200s`.";
          type = (types.nullOr types.str);
        };
        "interval" = mkOption {
          description = "The duration between keep-alive probes.\nDefaults to `75s`.";
          type = (types.nullOr types.str);
        };
        "probes" = mkOption {
          description = "The total number of unacknowledged probes to send before deciding\nthe connection is dead.\nDefaults to 9.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "idleTime" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "probes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTimeout" = {

      options = {
        "http" = mkOption {
          description = "Timeout settings for HTTP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp"
            )
          );
        };
        "tcp" = mkOption {
          description = "Timeout settings for TCP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcp"
            )
          );
        };
      };

      config = {
        "http" = mkOverride 1002 null;
        "tcp" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp" = {

      options = {
        "connectionIdleTimeout" = mkOption {
          description = "The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.\nDefault: 1 hour.";
          type = (types.nullOr types.str);
        };
        "maxConnectionDuration" = mkOption {
          description = "The maximum duration of an HTTP connection.\nDefault: unlimited.";
          type = (types.nullOr types.str);
        };
        "maxStreamDuration" = mkOption {
          description = "MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time\nfrom when the request is sent until the response stream is fully consumed and does not apply to\nnon-streaming requests.\nWhen set to \"0s\", no max duration is applied and streams can run indefinitely.";
          type = (types.nullOr types.str);
        };
        "requestTimeout" = mkOption {
          description = "RequestTimeout is the time until which entire response is received from the upstream.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "connectionIdleTimeout" = mkOverride 1002 null;
        "maxConnectionDuration" = mkOverride 1002 null;
        "maxStreamDuration" = mkOverride 1002 null;
        "requestTimeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcp" = {

      options = {
        "connectTimeout" = mkOption {
          description = "The timeout for network connection establishment, including TCP and TLS handshakes.\nDefault: 10 seconds.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "connectTimeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwt" = {

      options = {
        "optional" = mkOption {
          description = "Optional determines whether a missing JWT is acceptable, defaulting to false if not specified.\nNote: Even if optional is set to true, JWT authentication will still fail if an invalid JWT is presented.";
          type = (types.nullOr types.bool);
        };
        "providers" = mkOption {
          description = "Providers defines the JSON Web Token (JWT) authentication provider type.\nWhen multiple JWT providers are specified, the JWT is considered valid if\nany of the providers successfully validate the JWT. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/jwt_authn_filter.html.";
          type = (
            coerceAttrsOfSubmodulesToListByKey "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProviders"
              "name"
              [ ]
          );
          apply = attrsToList;
        };
      };

      config = {
        "optional" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProviders" = {

      options = {
        "audiences" = mkOption {
          description = "Audiences is a list of JWT audiences allowed access. For additional details, see\nhttps://tools.ietf.org/html/rfc7519#section-4.1.3. If not provided, JWT audiences\nare not checked.";
          type = (types.nullOr (types.listOf types.str));
        };
        "claimToHeaders" = mkOption {
          description = "ClaimToHeaders is a list of JWT claims that must be extracted into HTTP request headers\nFor examples, following config:\nThe claim must be of type; string, int, double, bool. Array type claims are not supported";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersClaimToHeaders"
              )
            )
          );
        };
        "extractFrom" = mkOption {
          description = "ExtractFrom defines different ways to extract the JWT token from HTTP request.\nIf empty, it defaults to extract JWT token from the Authorization HTTP request header using Bearer schema\nor access_token from query parameters.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersExtractFrom"
            )
          );
        };
        "issuer" = mkOption {
          description = "Issuer is the principal that issued the JWT and takes the form of a URL or email address.\nFor additional details, see https://tools.ietf.org/html/rfc7519#section-4.1.1 for\nURL format and https://rfc-editor.org/rfc/rfc5322.html for email format. If not provided,\nthe JWT issuer is not checked.";
          type = (types.nullOr types.str);
        };
        "localJWKS" = mkOption {
          description = "LocalJWKS defines how to get the JSON Web Key Sets (JWKS) from a local source.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersLocalJWKS")
          );
        };
        "name" = mkOption {
          description = "Name defines a unique name for the JWT provider. A name can have a variety of forms,\nincluding RFC1123 subdomains, RFC 1123 labels, or RFC 1035 labels.";
          type = types.str;
        };
        "recomputeRoute" = mkOption {
          description = "RecomputeRoute clears the route cache and recalculates the routing decision.\nThis field must be enabled if the headers generated from the claim are used for\nroute matching decisions. If the recomputation selects a new route, features targeting\nthe new matched route will be applied.";
          type = (types.nullOr types.bool);
        };
        "remoteJWKS" = mkOption {
          description = "RemoteJWKS defines how to fetch and cache JSON Web Key Sets (JWKS) from a remote\nHTTP/HTTPS endpoint.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKS")
          );
        };
      };

      config = {
        "audiences" = mkOverride 1002 null;
        "claimToHeaders" = mkOverride 1002 null;
        "extractFrom" = mkOverride 1002 null;
        "issuer" = mkOverride 1002 null;
        "localJWKS" = mkOverride 1002 null;
        "recomputeRoute" = mkOverride 1002 null;
        "remoteJWKS" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersClaimToHeaders" = {

      options = {
        "claim" = mkOption {
          description = "Claim is the JWT Claim that should be saved into the header : it can be a nested claim of type\n(eg. \"claim.nested.key\", \"sub\"). The nested claim name must use dot \".\"\nto separate the JSON name path.";
          type = types.str;
        };
        "header" = mkOption {
          description = "Header defines the name of the HTTP request header that the JWT Claim will be saved into.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersExtractFrom" = {

      options = {
        "cookies" = mkOption {
          description = "Cookies represents a list of cookie names to extract the JWT token from.";
          type = (types.nullOr (types.listOf types.str));
        };
        "headers" = mkOption {
          description = "Headers represents a list of HTTP request headers to extract the JWT token from.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersExtractFromHeaders"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "params" = mkOption {
          description = "Params represents a list of query parameters to extract the JWT token from.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "cookies" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "params" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersExtractFromHeaders" = {

      options = {
        "name" = mkOption {
          description = "Name is the HTTP header name to retrieve the token";
          type = types.str;
        };
        "valuePrefix" = mkOption {
          description = "ValuePrefix is the prefix that should be stripped before extracting the token.\nThe format would be used by Envoy like \"{ValuePrefix}<TOKEN>\".\nFor example, \"Authorization: Bearer <TOKEN>\", then the ValuePrefix=\"Bearer \" with a space at the end.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "valuePrefix" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersLocalJWKS" = {

      options = {
        "inline" = mkOption {
          description = "Inline contains the value as an inline string.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type is the type of method to use to read the body value.\nValid values are Inline and ValueRef, default is Inline.";
          type = types.str;
        };
        "valueRef" = mkOption {
          description = "ValueRef is a reference to a local ConfigMap that contains the JSON Web Key Sets (JWKS).\n\nThe value of key `jwks` in the ConfigMap will be used.\nIf the key is not found, the first value in the ConfigMap will be used.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersLocalJWKSValueRef"
            )
          );
        };
      };

      config = {
        "inline" = mkOverride 1002 null;
        "valueRef" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersLocalJWKSValueRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"HTTPRoute\" or \"Service\".";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKS" = {

      options = {
        "backendRef" = mkOption {
          description = "BackendRef references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.\n\nDeprecated: Use BackendRefs instead.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendRef"
            )
          );
        };
        "backendRefs" = mkOption {
          description = "BackendRefs references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "backendSettings" = mkOption {
          description = "BackendSettings holds configuration for managing the connection\nto the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettings"
            )
          );
        };
        "cacheDuration" = mkOption {
          description = "Duration is a string value representing a duration in time. The format is as specified\nin GEP-2257, a strict subset of the syntax parsed by Golang time.ParseDuration.";
          type = (types.nullOr types.str);
        };
        "uri" = mkOption {
          description = "URI is the HTTPS URI to fetch the JWKS. Envoy's system trust bundle is used to validate the server certificate.\nIf a custom trust bundle is needed, it can be specified in a BackendTLSConfig resource and target the BackendRefs.";
          type = types.str;
        };
      };

      config = {
        "backendRef" = mkOverride 1002 null;
        "backendRefs" = mkOverride 1002 null;
        "backendSettings" = mkOverride 1002 null;
        "cacheDuration" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendRefs" = {

      options = {
        "fallback" = mkOption {
          description = "Fallback indicates whether the backend is designated as a fallback.\nMultiple fallback backends can be configured.\nIt is highly recommended to configure active or passive health checks to ensure that failover can be detected\nwhen the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.\nThe overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when\nthe health of the active backends falls below 72%.";
          type = (types.nullOr types.bool);
        };
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
        "weight" = mkOption {
          description = "Weight specifies the proportion of requests forwarded to the referenced\nbackend. This is computed as weight/(sum of all weights in this\nBackendRefs list). For non-zero values, there may be some epsilon from\nthe exact proportion defined here depending on the precision an\nimplementation supports. Weight is not a percentage and the sum of\nweights does not need to equal 100.\n\nIf only one backend is specified and it has a weight greater than 0, 100%\nof the traffic is forwarded to that backend. If weight is set to 0, no\ntraffic should be forwarded for this entry. If unspecified, weight\ndefaults to 1.\n\nSupport for this field varies based on the context where used.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "fallback" = mkOverride 1002 null;
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "weight" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettings" = {

      options = {
        "circuitBreaker" = mkOption {
          description = "Circuit Breaker settings for the upstream connections and requests.\nIf not set, circuit breakers will be enabled with the default thresholds";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsCircuitBreaker"
            )
          );
        };
        "connection" = mkOption {
          description = "Connection includes backend connection settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsConnection"
            )
          );
        };
        "dns" = mkOption {
          description = "DNS includes dns resolution settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsDns"
            )
          );
        };
        "healthCheck" = mkOption {
          description = "HealthCheck allows gateway to perform active health checking on backends.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheck"
            )
          );
        };
        "http2" = mkOption {
          description = "HTTP2 provides HTTP/2 configuration for backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHttp2"
            )
          );
        };
        "loadBalancer" = mkOption {
          description = "LoadBalancer policy to apply when routing traffic from the gateway to\nthe backend endpoints. Defaults to `LeastRequest`.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancer"
            )
          );
        };
        "proxyProtocol" = mkOption {
          description = "ProxyProtocol enables the Proxy Protocol when communicating with the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsProxyProtocol"
            )
          );
        };
        "retry" = mkOption {
          description = "Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.\nIf not set, retry will be disabled.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetry"
            )
          );
        };
        "tcpKeepalive" = mkOption {
          description = "TcpKeepalive settings associated with the upstream client connection.\nDisabled by default.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTcpKeepalive"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout settings for the backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeout"
            )
          );
        };
      };

      config = {
        "circuitBreaker" = mkOverride 1002 null;
        "connection" = mkOverride 1002 null;
        "dns" = mkOverride 1002 null;
        "healthCheck" = mkOverride 1002 null;
        "http2" = mkOverride 1002 null;
        "loadBalancer" = mkOverride 1002 null;
        "proxyProtocol" = mkOverride 1002 null;
        "retry" = mkOverride 1002 null;
        "tcpKeepalive" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsCircuitBreaker" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxParallelRequests" = mkOption {
            description = "The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxParallelRetries" = mkOption {
            description = "The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxPendingRequests" = mkOption {
            description = "The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
          "maxRequestsPerConnection" = mkOption {
            description = "The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.\nDefault: unlimited.";
            type = (types.nullOr types.int);
          };
          "perEndpoint" = mkOption {
            description = "PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsCircuitBreakerPerEndpoint"
              )
            );
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
          "maxParallelRequests" = mkOverride 1002 null;
          "maxParallelRetries" = mkOverride 1002 null;
          "maxPendingRequests" = mkOverride 1002 null;
          "maxRequestsPerConnection" = mkOverride 1002 null;
          "perEndpoint" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsCircuitBreakerPerEndpoint" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsConnection" =
      {

        options = {
          "bufferLimit" = mkOption {
            description = "BufferLimit Soft limit on size of the cluster’s connections read and write buffers.\nBufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.\nIf unspecified, an implementation defined default is applied (32768 bytes).\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote: that when the suffix is not provided, the value is interpreted as bytes.";
            type = (types.nullOr (types.either types.int types.str));
          };
          "preconnect" = mkOption {
            description = "Preconnect configures proactive upstream connections to reduce latency by establishing\nconnections before they’re needed and avoiding connection establishment overhead.\n\nIf unset, Envoy will fetch connections as needed to serve in-flight requests.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsConnectionPreconnect"
              )
            );
          };
          "socketBufferLimit" = mkOption {
            description = "SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket\nto backend.\nSocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote that when the suffix is not provided, the value is interpreted as bytes.";
            type = (types.nullOr (types.either types.int types.str));
          };
        };

        config = {
          "bufferLimit" = mkOverride 1002 null;
          "preconnect" = mkOverride 1002 null;
          "socketBufferLimit" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsConnectionPreconnect" =
      {

        options = {
          "perEndpointPercent" = mkOption {
            description = "PerEndpointPercent configures how many additional connections to maintain per\nupstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a\npercentage of the connections required by active streams\n(e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).\n\nAllowed value range is between 100-300. When both PerEndpointPercent and\nPredictivePercent are set, Envoy ensures both are satisfied (max of the two).";
            type = (types.nullOr types.int);
          };
          "predictivePercent" = mkOption {
            description = "PredictivePercent configures how many additional connections to maintain\nacross the cluster by anticipating which upstream endpoint the load balancer\nwill select next, useful for low-QPS services. Relies on deterministic\nloadbalancing and is only supported with Random or RoundRobin.\nExpressed as a percentage of the connections required by active streams\n(e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).\n\nMinimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are\nset Envoy ensures both are satisfied per host (max of the two).";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "perEndpointPercent" = mkOverride 1002 null;
          "predictivePercent" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsDns" = {

      options = {
        "dnsRefreshRate" = mkOption {
          description = "DNSRefreshRate specifies the rate at which DNS records should be refreshed.\nDefaults to 30 seconds.";
          type = (types.nullOr types.str);
        };
        "lookupFamily" = mkOption {
          description = "LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).\nIf set, this configuration overrides other defaults.";
          type = (types.nullOr types.str);
        };
        "respectDnsTtl" = mkOption {
          description = "RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.\nIf the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.\nDefaults to true.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "dnsRefreshRate" = mkOverride 1002 null;
        "lookupFamily" = mkOverride 1002 null;
        "respectDnsTtl" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheck" =
      {

        options = {
          "active" = mkOption {
            description = "Active health check configuration";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActive"
              )
            );
          };
          "panicThreshold" = mkOption {
            description = "When number of unhealthy endpoints for a backend reaches this threshold\nEnvoy will disregard health status and balance across all endpoints.\nIt's designed to prevent a situation in which host failures cascade throughout the cluster\nas load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.";
            type = (types.nullOr types.int);
          };
          "passive" = mkOption {
            description = "Passive passive check configuration";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckPassive"
              )
            );
          };
        };

        config = {
          "active" = mkOverride 1002 null;
          "panicThreshold" = mkOverride 1002 null;
          "passive" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActive" =
      {

        options = {
          "grpc" = mkOption {
            description = "GRPC defines the configuration of the GRPC health checker.\nIt's optional, and can only be used if the specified type is GRPC.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveGrpc"
              )
            );
          };
          "healthyThreshold" = mkOption {
            description = "HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.";
            type = (types.nullOr types.int);
          };
          "http" = mkOption {
            description = "HTTP defines the configuration of http health checker.\nIt's required while the health checker type is HTTP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveHttp"
              )
            );
          };
          "initialJitter" = mkOption {
            description = "InitialJitter defines the maximum time Envoy will wait before the first health check.\nEnvoy will randomly select a value between 0 and the initial jitter value.";
            type = (types.nullOr types.str);
          };
          "interval" = mkOption {
            description = "Interval defines the time between active health checks.";
            type = (types.nullOr types.str);
          };
          "tcp" = mkOption {
            description = "TCP defines the configuration of tcp health checker.\nIt's required while the health checker type is TCP.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcp"
              )
            );
          };
          "timeout" = mkOption {
            description = "Timeout defines the time to wait for a health check response.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of health checker.";
            type = types.str;
          };
          "unhealthyThreshold" = mkOption {
            description = "UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "grpc" = mkOverride 1002 null;
          "healthyThreshold" = mkOverride 1002 null;
          "http" = mkOverride 1002 null;
          "initialJitter" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "tcp" = mkOverride 1002 null;
          "timeout" = mkOverride 1002 null;
          "unhealthyThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveGrpc" =
      {

        options = {
          "service" = mkOption {
            description = "Service to send in the health check request.\nIf this is not specified, then the health check request applies to the entire\nserver and not to a specific service.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "service" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveHttp" =
      {

        options = {
          "expectedResponse" = mkOption {
            description = "ExpectedResponse defines a list of HTTP expected responses to match.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveHttpExpectedResponse"
              )
            );
          };
          "expectedStatuses" = mkOption {
            description = "ExpectedStatuses defines a list of HTTP response statuses considered healthy.\nDefaults to 200 only";
            type = (types.nullOr (types.listOf types.int));
          };
          "hostname" = mkOption {
            description = "Hostname defines the HTTP host that will be requested during health checking.\nDefault: HTTPRoute or GRPCRoute hostname.";
            type = (types.nullOr types.str);
          };
          "method" = mkOption {
            description = "Method defines the HTTP method used for health checking.\nDefaults to GET";
            type = (types.nullOr types.str);
          };
          "path" = mkOption {
            description = "Path defines the HTTP path that will be requested during health checking.";
            type = types.str;
          };
        };

        config = {
          "expectedResponse" = mkOverride 1002 null;
          "expectedStatuses" = mkOverride 1002 null;
          "hostname" = mkOverride 1002 null;
          "method" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveHttpExpectedResponse" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcp" =
      {

        options = {
          "receive" = mkOption {
            description = "Receive defines the expected response payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpReceive"
              )
            );
          };
          "send" = mkOption {
            description = "Send defines the request payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpSend"
              )
            );
          };
        };

        config = {
          "receive" = mkOverride 1002 null;
          "send" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpReceive" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpSend" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckPassive" =
      {

        options = {
          "baseEjectionTime" = mkOption {
            description = "BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.";
            type = (types.nullOr types.str);
          };
          "consecutive5XxErrors" = mkOption {
            description = "Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.";
            type = (types.nullOr types.int);
          };
          "consecutiveGatewayErrors" = mkOption {
            description = "ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.";
            type = (types.nullOr types.int);
          };
          "consecutiveLocalOriginFailures" = mkOption {
            description = "ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.\nParameter takes effect only when split_external_local_origin_errors is set to true.";
            type = (types.nullOr types.int);
          };
          "failurePercentageThreshold" = mkOption {
            description = "FailurePercentageThreshold sets the failure percentage threshold for outlier detection.\nIf the failure percentage of a given host is greater than or equal to this value, it will be ejected.\nDefaults to 85.";
            type = (types.nullOr types.int);
          };
          "interval" = mkOption {
            description = "Interval defines the time between passive health checks.";
            type = (types.nullOr types.str);
          };
          "maxEjectionPercent" = mkOption {
            description = "MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.";
            type = (types.nullOr types.int);
          };
          "splitExternalLocalOriginErrors" = mkOption {
            description = "SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "baseEjectionTime" = mkOverride 1002 null;
          "consecutive5XxErrors" = mkOverride 1002 null;
          "consecutiveGatewayErrors" = mkOverride 1002 null;
          "consecutiveLocalOriginFailures" = mkOverride 1002 null;
          "failurePercentageThreshold" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "maxEjectionPercent" = mkOverride 1002 null;
          "splitExternalLocalOriginErrors" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHttp2" = {

      options = {
        "initialConnectionWindowSize" = mkOption {
          description = "InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.\nIf not set, the default value is 1 MiB.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "initialStreamWindowSize" = mkOption {
          description = "InitialStreamWindowSize sets the initial window size for HTTP/2 streams.\nIf not set, the default value is 64 KiB(64*1024).";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxConcurrentStreams" = mkOption {
          description = "MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.\nIf not set, the default value is 100.";
          type = (types.nullOr types.int);
        };
        "onInvalidMessage" = mkOption {
          description = "OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error\nIt's recommended for L2 Envoy deployments to set this value to TerminateStream.\nhttps://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two\nDefault: TerminateConnection";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "initialConnectionWindowSize" = mkOverride 1002 null;
        "initialStreamWindowSize" = mkOverride 1002 null;
        "maxConcurrentStreams" = mkOverride 1002 null;
        "onInvalidMessage" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancer" =
      {

        options = {
          "consistentHash" = mkOption {
            description = "ConsistentHash defines the configuration when the load balancer type is\nset to ConsistentHash";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHash"
              )
            );
          };
          "endpointOverride" = mkOption {
            description = "EndpointOverride defines the configuration for endpoint override.\nWhen specified, the load balancer will attempt to route requests to endpoints\nbased on the override information extracted from request headers or metadata.\n If the override endpoints are not available, the configured load balancer policy will be used as fallback.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerEndpointOverride"
              )
            );
          };
          "slowStart" = mkOption {
            description = "SlowStart defines the configuration related to the slow start load balancer policy.\nIf set, during slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently this is only supported for RoundRobin and LeastRequest load balancers";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerSlowStart"
              )
            );
          };
          "type" = mkOption {
            description = "Type decides the type of Load Balancer policy.\nValid LoadBalancerType values are\n\"ConsistentHash\",\n\"LeastRequest\",\n\"Random\",\n\"RoundRobin\".";
            type = types.str;
          };
          "zoneAware" = mkOption {
            description = "ZoneAware defines the configuration related to the distribution of requests between locality zones.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAware"
              )
            );
          };
        };

        config = {
          "consistentHash" = mkOverride 1002 null;
          "endpointOverride" = mkOverride 1002 null;
          "slowStart" = mkOverride 1002 null;
          "zoneAware" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHash" =
      {

        options = {
          "cookie" = mkOption {
            description = "Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashCookie"
              )
            );
          };
          "header" = mkOption {
            description = "Header configures the header hash policy when the consistent hash type is set to Header.\n\nDeprecated: use Headers instead";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashHeader"
              )
            );
          };
          "headers" = mkOption {
            description = "Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "queryParams" = mkOption {
            description = "QueryParams configures the query parameter hash policy when the consistent hash type is set to QueryParams.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashQueryParams"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "tableSize" = mkOption {
            description = "The table size for consistent hashing, must be prime number limited to 5000011.";
            type = (types.nullOr types.int);
          };
          "type" = mkOption {
            description = "ConsistentHashType defines the type of input to hash on. Valid Type values are\n\"SourceIP\",\n\"Header\",\n\"Headers\",\n\"Cookie\".\n\"QueryParams\".";
            type = types.str;
          };
        };

        config = {
          "cookie" = mkOverride 1002 null;
          "header" = mkOverride 1002 null;
          "headers" = mkOverride 1002 null;
          "queryParams" = mkOverride 1002 null;
          "tableSize" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashCookie" =
      {

        options = {
          "attributes" = mkOption {
            description = "Additional Attributes to set for the generated cookie.";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "name" = mkOption {
            description = "Name of the cookie to hash.\nIf this cookie does not exist in the request, Envoy will generate a cookie and set\nthe TTL on the response back to the client based on Layer 4\nattributes of the backend endpoint, to ensure that these future requests\ngo to the same backend endpoint. Make sure to set the TTL field for this case.";
            type = types.str;
          };
          "ttl" = mkOption {
            description = "TTL of the generated cookie if the cookie is not present. This value sets the\nMax-Age attribute value.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "attributes" = mkOverride 1002 null;
          "ttl" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashHeader" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashQueryParams" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the query param to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerEndpointOverride" =
      {

        options = {
          "extractFrom" = mkOption {
            description = "ExtractFrom defines the sources to extract endpoint override information from.";
            type = (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerEndpointOverrideExtractFrom"
              )
            );
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerEndpointOverrideExtractFrom" =
      {

        options = {
          "header" = mkOption {
            description = "Header defines the header to get the override endpoint addresses.\nThe header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.\nFor example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.\nThe IPv6 address is enclosed in square brackets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "header" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerSlowStart" =
      {

        options = {
          "window" = mkOption {
            description = "Window defines the duration of the warm up period for newly added host.\nDuring slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently only supports linear growth of traffic. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAware" =
      {

        options = {
          "preferLocal" = mkOption {
            description = "PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePreferLocal"
              )
            );
          };
        };

        config = {
          "preferLocal" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePreferLocal" =
      {

        options = {
          "force" = mkOption {
            description = "ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior\nwhich maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePreferLocalForce"
              )
            );
          };
          "minEndpointsThreshold" = mkOption {
            description = "MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.";
            type = (types.nullOr types.int);
          };
          "percentageEnabled" = mkOption {
            description = "Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "force" = mkOverride 1002 null;
          "minEndpointsThreshold" = mkOverride 1002 null;
          "percentageEnabled" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePreferLocalForce" =
      {

        options = {
          "minEndpointsInZoneThreshold" = mkOption {
            description = "MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone\noverride. This is useful for protecting zones with fewer endpoints.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "minEndpointsInZoneThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsProxyProtocol" =
      {

        options = {
          "version" = mkOption {
            description = "Version of ProxyProtol\nValid ProxyProtocolVersion values are\n\"V1\"\n\"V2\"";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetry" = {

      options = {
        "numAttemptsPerPriority" = mkOption {
          description = "NumAttemptsPerPriority defines the number of requests (initial attempt + retries)\nthat should be sent to the same priority before switching to a different one.\nIf not specified or set to 0, all requests are sent to the highest priority that is healthy.";
          type = (types.nullOr types.int);
        };
        "numRetries" = mkOption {
          description = "NumRetries is the number of retries to be attempted. Defaults to 2.";
          type = (types.nullOr types.int);
        };
        "perRetry" = mkOption {
          description = "PerRetry is the retry policy to be applied per retry attempt.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPerRetry"
            )
          );
        };
        "retryOn" = mkOption {
          description = "RetryOn specifies the retry trigger condition.\n\nIf not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryRetryOn"
            )
          );
        };
      };

      config = {
        "numAttemptsPerPriority" = mkOverride 1002 null;
        "numRetries" = mkOverride 1002 null;
        "perRetry" = mkOverride 1002 null;
        "retryOn" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPerRetry" =
      {

        options = {
          "backOff" = mkOption {
            description = "Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential\nback-off algorithm for retries. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPerRetryBackOff"
              )
            );
          };
          "timeout" = mkOption {
            description = "Timeout is the timeout per retry attempt.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "backOff" = mkOverride 1002 null;
          "timeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPerRetryBackOff" =
      {

        options = {
          "baseInterval" = mkOption {
            description = "BaseInterval is the base interval between retries.";
            type = (types.nullOr types.str);
          };
          "maxInterval" = mkOption {
            description = "MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.\nThe default is 10 times the base_interval";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "baseInterval" = mkOverride 1002 null;
          "maxInterval" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryRetryOn" =
      {

        options = {
          "httpStatusCodes" = mkOption {
            description = "HttpStatusCodes specifies the http status codes to be retried.\nThe retriable-status-codes trigger must also be configured for these status codes to trigger a retry.";
            type = (types.nullOr (types.listOf types.int));
          };
          "triggers" = mkOption {
            description = "Triggers specifies the retry trigger condition(Http/Grpc).";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "httpStatusCodes" = mkOverride 1002 null;
          "triggers" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTcpKeepalive" =
      {

        options = {
          "idleTime" = mkOption {
            description = "The duration a connection needs to be idle before keep-alive\nprobes start being sent.\nThe duration format is\nDefaults to `7200s`.";
            type = (types.nullOr types.str);
          };
          "interval" = mkOption {
            description = "The duration between keep-alive probes.\nDefaults to `75s`.";
            type = (types.nullOr types.str);
          };
          "probes" = mkOption {
            description = "The total number of unacknowledged probes to send before deciding\nthe connection is dead.\nDefaults to 9.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "idleTime" = mkOverride 1002 null;
          "interval" = mkOverride 1002 null;
          "probes" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeout" = {

      options = {
        "http" = mkOption {
          description = "Timeout settings for HTTP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutHttp"
            )
          );
        };
        "tcp" = mkOption {
          description = "Timeout settings for TCP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutTcp"
            )
          );
        };
      };

      config = {
        "http" = mkOverride 1002 null;
        "tcp" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutHttp" =
      {

        options = {
          "connectionIdleTimeout" = mkOption {
            description = "The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.\nDefault: 1 hour.";
            type = (types.nullOr types.str);
          };
          "maxConnectionDuration" = mkOption {
            description = "The maximum duration of an HTTP connection.\nDefault: unlimited.";
            type = (types.nullOr types.str);
          };
          "maxStreamDuration" = mkOption {
            description = "MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time\nfrom when the request is sent until the response stream is fully consumed and does not apply to\nnon-streaming requests.\nWhen set to \"0s\", no max duration is applied and streams can run indefinitely.";
            type = (types.nullOr types.str);
          };
          "requestTimeout" = mkOption {
            description = "RequestTimeout is the time until which entire response is received from the upstream.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "connectionIdleTimeout" = mkOverride 1002 null;
          "maxConnectionDuration" = mkOverride 1002 null;
          "maxStreamDuration" = mkOverride 1002 null;
          "requestTimeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutTcp" =
      {

        options = {
          "connectTimeout" = mkOption {
            description = "The timeout for network connection establishment, including TCP and TLS handshakes.\nDefault: 10 seconds.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "connectTimeout" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidc" = {

      options = {
        "clientID" = mkOption {
          description = "The client ID to be used in the OIDC\n[Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).\n\nOnly one of clientID or clientIDRef must be set.";
          type = (types.nullOr types.str);
        };
        "clientIDRef" = mkOption {
          description = "The Kubernetes secret which contains the client ID to be used in the\n[Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).\nExactly one of clientID or clientIDRef must be set.\nThis is an Opaque secret. The client ID should be stored in the key \"client-id\".\n\nOnly one of clientID or clientIDRef must be set.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcClientIDRef")
          );
        };
        "clientSecret" = mkOption {
          description = "The Kubernetes secret which contains the OIDC client secret to be used in the\n[Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).\n\nThis is an Opaque secret. The client secret should be stored in the key\n\"client-secret\".";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcClientSecret");
        };
        "cookieConfig" = mkOption {
          description = "CookieConfigs allows setting the SameSite attribute for OIDC cookies.\nBy default, its unset.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcCookieConfig")
          );
        };
        "cookieDomain" = mkOption {
          description = "The optional domain to set the access and ID token cookies on.\nIf not set, the cookies will default to the host of the request, not including the subdomains.\nIf set, the cookies will be set on the specified domain and all subdomains.\nThis means that requests to any subdomain will not require reauthentication after users log in to the parent domain.";
          type = (types.nullOr types.str);
        };
        "cookieNames" = mkOption {
          description = "The optional cookie name overrides to be used for Bearer and IdToken cookies in the\n[Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).\nIf not specified, uses a randomly generated suffix";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcCookieNames")
          );
        };
        "csrfTokenTTL" = mkOption {
          description = "CSRFTokenTTL defines how long the CSRF token generated during the OAuth2 authorization flow remains valid.\n\nThis duration determines the lifetime of the CSRF cookie, which is validated against the CSRF token\nin the \"state\" parameter when the provider redirects back to the callback endpoint.\n\nIf omitted, Envoy Gateway defaults the token expiration to 10 minutes.";
          type = (types.nullOr types.str);
        };
        "defaultRefreshTokenTTL" = mkOption {
          description = "DefaultRefreshTokenTTL is the default lifetime of the refresh token.\nThis field is only used when the exp (expiration time) claim is omitted in\nthe refresh token or the refresh token is not JWT.\n\nIf not specified, defaults to 604800s (one week).\nNote: this field is only applicable when the \"refreshToken\" field is set to true.";
          type = (types.nullOr types.str);
        };
        "defaultTokenTTL" = mkOption {
          description = "DefaultTokenTTL is the default lifetime of the id token and access token.\nPlease note that Envoy will always use the expiry time from the response\nof the authorization server if it is provided. This field is only used when\nthe expiry time is not provided by the authorization.\n\nIf not specified, defaults to 0. In this case, the \"expires_in\" field in\nthe authorization response must be set by the authorization server, or the\nOAuth flow will fail.";
          type = (types.nullOr types.str);
        };
        "denyRedirect" = mkOption {
          description = "Any request that matches any of the provided matchers (with either tokens that are expired or missing tokens) will not be redirected to the OIDC Provider.\nThis behavior can be useful for AJAX or machine requests.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcDenyRedirect")
          );
        };
        "disableTokenEncryption" = mkOption {
          description = "Disable token encryption. When set to true, both the access token and the ID token will be stored in plain text.\nThis option should only be used in secure environments where token encryption is not required.\nDefault is false (tokens are encrypted).";
          type = (types.nullOr types.bool);
        };
        "forwardAccessToken" = mkOption {
          description = "ForwardAccessToken indicates whether the Envoy should forward the access token\nvia the Authorization header Bearer scheme to the upstream.\nIf not specified, defaults to false.";
          type = (types.nullOr types.bool);
        };
        "logoutPath" = mkOption {
          description = "The path to log a user out, clearing their credential cookies.\n\nIf not specified, uses a default logout path \"/logout\"";
          type = (types.nullOr types.str);
        };
        "passThroughAuthHeader" = mkOption {
          description = "Skips OIDC authentication when the request contains a header that will be extracted by the JWT filter. Unless\nexplicitly stated otherwise in the extractFrom field, this will be the \"Authorization: Bearer ...\" header.\n\nThe passThroughAuthHeader option is typically used for non-browser clients that may not be able to handle OIDC\nredirects and wish to directly supply a token instead.\n\nIf not specified, defaults to false.";
          type = (types.nullOr types.bool);
        };
        "provider" = mkOption {
          description = "The OIDC Provider configuration.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProvider");
        };
        "redirectURL" = mkOption {
          description = "The redirect URL to be used in the OIDC\n[Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).\nIf not specified, uses the default redirect URI \"%REQ(x-forwarded-proto)%://%REQ(:authority)%/oauth2/callback\"";
          type = (types.nullOr types.str);
        };
        "refreshToken" = mkOption {
          description = "RefreshToken indicates whether the Envoy should automatically refresh the\nid token and access token when they expire.\nWhen set to true, the Envoy will use the refresh token to get a new id token\nand access token when they expire.\n\nIf not specified, defaults to true.";
          type = (types.nullOr types.bool);
        };
        "resources" = mkOption {
          description = "The OIDC resources to be used in the\n[Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).";
          type = (types.nullOr (types.listOf types.str));
        };
        "scopes" = mkOption {
          description = "The OIDC scopes to be used in the\n[Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).\nThe \"openid\" scope is always added to the list of scopes if not already\nspecified.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "clientID" = mkOverride 1002 null;
        "clientIDRef" = mkOverride 1002 null;
        "cookieConfig" = mkOverride 1002 null;
        "cookieDomain" = mkOverride 1002 null;
        "cookieNames" = mkOverride 1002 null;
        "csrfTokenTTL" = mkOverride 1002 null;
        "defaultRefreshTokenTTL" = mkOverride 1002 null;
        "defaultTokenTTL" = mkOverride 1002 null;
        "denyRedirect" = mkOverride 1002 null;
        "disableTokenEncryption" = mkOverride 1002 null;
        "forwardAccessToken" = mkOverride 1002 null;
        "logoutPath" = mkOverride 1002 null;
        "passThroughAuthHeader" = mkOverride 1002 null;
        "redirectURL" = mkOverride 1002 null;
        "refreshToken" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcClientIDRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"Secret\".";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referenced object. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcClientSecret" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent. For example \"Secret\".";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referenced object. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcCookieConfig" = {

      options = {
        "sameSite" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "sameSite" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcCookieNames" = {

      options = {
        "accessToken" = mkOption {
          description = "The name of the cookie used to store the AccessToken in the\n[Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).\nIf not specified, defaults to \"AccessToken-(randomly generated uid)\"";
          type = (types.nullOr types.str);
        };
        "idToken" = mkOption {
          description = "The name of the cookie used to store the IdToken in the\n[Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).\nIf not specified, defaults to \"IdToken-(randomly generated uid)\"";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessToken" = mkOverride 1002 null;
        "idToken" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcDenyRedirect" = {

      options = {
        "headers" = mkOption {
          description = "Defines the headers to match against the request to deny redirect to the OIDC Provider.";
          type = (
            coerceAttrsOfSubmodulesToListByKey
              "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcDenyRedirectHeaders"
              "name"
              [ ]
          );
          apply = attrsToList;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcDenyRedirectHeaders" = {

      options = {
        "name" = mkOption {
          description = "Specifies the name of the header in the request.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type specifies how to match against a string.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value specifies the string value that the match must have.";
          type = types.str;
        };
      };

      config = {
        "type" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProvider" = {

      options = {
        "authorizationEndpoint" = mkOption {
          description = "The OIDC Provider's [authorization endpoint](https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint).\nIf not provided, EG will try to discover it from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).";
          type = (types.nullOr types.str);
        };
        "backendRef" = mkOption {
          description = "BackendRef references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.\n\nDeprecated: Use BackendRefs instead.";
          type = (
            types.nullOr (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendRef")
          );
        };
        "backendRefs" = mkOption {
          description = "BackendRefs references a Kubernetes object that represents the\nbackend server to which the authorization request will be sent.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "backendSettings" = mkOption {
          description = "BackendSettings holds configuration for managing the connection\nto the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettings"
            )
          );
        };
        "endSessionEndpoint" = mkOption {
          description = "The OIDC Provider's [end session endpoint](https://openid.net/specs/openid-connect-core-1_0.html#RPLogout).\n\nIf the end session endpoint is provided, EG will use it to log out the user from the OIDC Provider when the user accesses the logout path.\nEG will also try to discover the end session endpoint from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse) when authorizationEndpoint or tokenEndpoint is not provided.";
          type = (types.nullOr types.str);
        };
        "issuer" = mkOption {
          description = "The OIDC Provider's [issuer identifier](https://openid.net/specs/openid-connect-discovery-1_0.html#IssuerDiscovery).\nIssuer MUST be a URI RFC 3986 [RFC3986] with a scheme component that MUST\nbe https, a host component, and optionally, port and path components and\nno query or fragment components.";
          type = types.str;
        };
        "tokenEndpoint" = mkOption {
          description = "The OIDC Provider's [token endpoint](https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint).\nIf not provided, EG will try to discover it from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "authorizationEndpoint" = mkOverride 1002 null;
        "backendRef" = mkOverride 1002 null;
        "backendRefs" = mkOverride 1002 null;
        "backendSettings" = mkOverride 1002 null;
        "endSessionEndpoint" = mkOverride 1002 null;
        "tokenEndpoint" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendRefs" = {

      options = {
        "fallback" = mkOption {
          description = "Fallback indicates whether the backend is designated as a fallback.\nMultiple fallback backends can be configured.\nIt is highly recommended to configure active or passive health checks to ensure that failover can be detected\nwhen the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.\nThe overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when\nthe health of the active backends falls below 72%.";
          type = (types.nullOr types.bool);
        };
        "group" = mkOption {
          description = "Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\nWhen unspecified or empty string, core API group is inferred.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the Kubernetes resource kind of the referent. For example\n\"Service\".\n\nDefaults to \"Service\" when not specified.\n\nExternalName services can refer to CNAME DNS records that may live\noutside of the cluster and as such are difficult to reason about in\nterms of conformance. They also may not be safe to forward to (see\nCVE-2021-25740 for more information). Implementations SHOULD NOT\nsupport ExternalName Services.\n\nSupport: Core (Services with a type other than ExternalName)\n\nSupport: Implementation-specific (Services with type ExternalName)";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the backend. When unspecified, the local\nnamespace is inferred.\n\nNote that when a namespace different than the local namespace is specified,\na ReferenceGrant object is required in the referent namespace to allow that\nnamespace's owner to accept the reference. See the ReferenceGrant\ndocumentation for details.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port specifies the destination port number to use for this resource.\nPort is required when the referent is a Kubernetes Service. In this\ncase, the port number is the service port number, not the target port.\nFor other resources, destination port might be derived from the referent\nresource or this field.";
          type = (types.nullOr types.int);
        };
        "weight" = mkOption {
          description = "Weight specifies the proportion of requests forwarded to the referenced\nbackend. This is computed as weight/(sum of all weights in this\nBackendRefs list). For non-zero values, there may be some epsilon from\nthe exact proportion defined here depending on the precision an\nimplementation supports. Weight is not a percentage and the sum of\nweights does not need to equal 100.\n\nIf only one backend is specified and it has a weight greater than 0, 100%\nof the traffic is forwarded to that backend. If weight is set to 0, no\ntraffic should be forwarded for this entry. If unspecified, weight\ndefaults to 1.\n\nSupport for this field varies based on the context where used.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "fallback" = mkOverride 1002 null;
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "weight" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettings" = {

      options = {
        "circuitBreaker" = mkOption {
          description = "Circuit Breaker settings for the upstream connections and requests.\nIf not set, circuit breakers will be enabled with the default thresholds";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker"
            )
          );
        };
        "connection" = mkOption {
          description = "Connection includes backend connection settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsConnection"
            )
          );
        };
        "dns" = mkOption {
          description = "DNS includes dns resolution settings.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsDns"
            )
          );
        };
        "healthCheck" = mkOption {
          description = "HealthCheck allows gateway to perform active health checking on backends.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheck"
            )
          );
        };
        "http2" = mkOption {
          description = "HTTP2 provides HTTP/2 configuration for backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHttp2"
            )
          );
        };
        "loadBalancer" = mkOption {
          description = "LoadBalancer policy to apply when routing traffic from the gateway to\nthe backend endpoints. Defaults to `LeastRequest`.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer"
            )
          );
        };
        "proxyProtocol" = mkOption {
          description = "ProxyProtocol enables the Proxy Protocol when communicating with the backend.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsProxyProtocol"
            )
          );
        };
        "retry" = mkOption {
          description = "Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.\nIf not set, retry will be disabled.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetry"
            )
          );
        };
        "tcpKeepalive" = mkOption {
          description = "TcpKeepalive settings associated with the upstream client connection.\nDisabled by default.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout settings for the backend connections.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTimeout"
            )
          );
        };
      };

      config = {
        "circuitBreaker" = mkOverride 1002 null;
        "connection" = mkOverride 1002 null;
        "dns" = mkOverride 1002 null;
        "healthCheck" = mkOverride 1002 null;
        "http2" = mkOverride 1002 null;
        "loadBalancer" = mkOverride 1002 null;
        "proxyProtocol" = mkOverride 1002 null;
        "retry" = mkOverride 1002 null;
        "tcpKeepalive" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker" = {

      options = {
        "maxConnections" = mkOption {
          description = "The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxParallelRequests" = mkOption {
          description = "The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxParallelRetries" = mkOption {
          description = "The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxPendingRequests" = mkOption {
          description = "The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.";
          type = (types.nullOr types.int);
        };
        "maxRequestsPerConnection" = mkOption {
          description = "The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.\nDefault: unlimited.";
          type = (types.nullOr types.int);
        };
        "perEndpoint" = mkOption {
          description = "PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpoint"
            )
          );
        };
      };

      config = {
        "maxConnections" = mkOverride 1002 null;
        "maxParallelRequests" = mkOverride 1002 null;
        "maxParallelRetries" = mkOverride 1002 null;
        "maxPendingRequests" = mkOverride 1002 null;
        "maxRequestsPerConnection" = mkOverride 1002 null;
        "perEndpoint" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpoint" =
      {

        options = {
          "maxConnections" = mkOption {
            description = "MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "maxConnections" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsConnection" = {

      options = {
        "bufferLimit" = mkOption {
          description = "BufferLimit Soft limit on size of the cluster’s connections read and write buffers.\nBufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.\nIf unspecified, an implementation defined default is applied (32768 bytes).\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote: that when the suffix is not provided, the value is interpreted as bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "preconnect" = mkOption {
          description = "Preconnect configures proactive upstream connections to reduce latency by establishing\nconnections before they’re needed and avoiding connection establishment overhead.\n\nIf unset, Envoy will fetch connections as needed to serve in-flight requests.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsConnectionPreconnect"
            )
          );
        };
        "socketBufferLimit" = mkOption {
          description = "SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket\nto backend.\nSocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.\nFor example, 20Mi, 1Gi, 256Ki etc.\nNote that when the suffix is not provided, the value is interpreted as bytes.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "bufferLimit" = mkOverride 1002 null;
        "preconnect" = mkOverride 1002 null;
        "socketBufferLimit" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsConnectionPreconnect" =
      {

        options = {
          "perEndpointPercent" = mkOption {
            description = "PerEndpointPercent configures how many additional connections to maintain per\nupstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a\npercentage of the connections required by active streams\n(e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).\n\nAllowed value range is between 100-300. When both PerEndpointPercent and\nPredictivePercent are set, Envoy ensures both are satisfied (max of the two).";
            type = (types.nullOr types.int);
          };
          "predictivePercent" = mkOption {
            description = "PredictivePercent configures how many additional connections to maintain\nacross the cluster by anticipating which upstream endpoint the load balancer\nwill select next, useful for low-QPS services. Relies on deterministic\nloadbalancing and is only supported with Random or RoundRobin.\nExpressed as a percentage of the connections required by active streams\n(e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).\n\nMinimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are\nset Envoy ensures both are satisfied per host (max of the two).";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "perEndpointPercent" = mkOverride 1002 null;
          "predictivePercent" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsDns" = {

      options = {
        "dnsRefreshRate" = mkOption {
          description = "DNSRefreshRate specifies the rate at which DNS records should be refreshed.\nDefaults to 30 seconds.";
          type = (types.nullOr types.str);
        };
        "lookupFamily" = mkOption {
          description = "LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).\nIf set, this configuration overrides other defaults.";
          type = (types.nullOr types.str);
        };
        "respectDnsTtl" = mkOption {
          description = "RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.\nIf the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.\nDefaults to true.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "dnsRefreshRate" = mkOverride 1002 null;
        "lookupFamily" = mkOverride 1002 null;
        "respectDnsTtl" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheck" = {

      options = {
        "active" = mkOption {
          description = "Active health check configuration";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive"
            )
          );
        };
        "panicThreshold" = mkOption {
          description = "When number of unhealthy endpoints for a backend reaches this threshold\nEnvoy will disregard health status and balance across all endpoints.\nIt's designed to prevent a situation in which host failures cascade throughout the cluster\nas load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.";
          type = (types.nullOr types.int);
        };
        "passive" = mkOption {
          description = "Passive passive check configuration";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive"
            )
          );
        };
      };

      config = {
        "active" = mkOverride 1002 null;
        "panicThreshold" = mkOverride 1002 null;
        "passive" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive" = {

      options = {
        "grpc" = mkOption {
          description = "GRPC defines the configuration of the GRPC health checker.\nIt's optional, and can only be used if the specified type is GRPC.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpc"
            )
          );
        };
        "healthyThreshold" = mkOption {
          description = "HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.";
          type = (types.nullOr types.int);
        };
        "http" = mkOption {
          description = "HTTP defines the configuration of http health checker.\nIt's required while the health checker type is HTTP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp"
            )
          );
        };
        "initialJitter" = mkOption {
          description = "InitialJitter defines the maximum time Envoy will wait before the first health check.\nEnvoy will randomly select a value between 0 and the initial jitter value.";
          type = (types.nullOr types.str);
        };
        "interval" = mkOption {
          description = "Interval defines the time between active health checks.";
          type = (types.nullOr types.str);
        };
        "tcp" = mkOption {
          description = "TCP defines the configuration of tcp health checker.\nIt's required while the health checker type is TCP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcp"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout defines the time to wait for a health check response.";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type defines the type of health checker.";
          type = types.str;
        };
        "unhealthyThreshold" = mkOption {
          description = "UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "grpc" = mkOverride 1002 null;
        "healthyThreshold" = mkOverride 1002 null;
        "http" = mkOverride 1002 null;
        "initialJitter" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "tcp" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
        "unhealthyThreshold" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpc" =
      {

        options = {
          "service" = mkOption {
            description = "Service to send in the health check request.\nIf this is not specified, then the health check request applies to the entire\nserver and not to a specific service.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "service" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp" =
      {

        options = {
          "expectedResponse" = mkOption {
            description = "ExpectedResponse defines a list of HTTP expected responses to match.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse"
              )
            );
          };
          "expectedStatuses" = mkOption {
            description = "ExpectedStatuses defines a list of HTTP response statuses considered healthy.\nDefaults to 200 only";
            type = (types.nullOr (types.listOf types.int));
          };
          "hostname" = mkOption {
            description = "Hostname defines the HTTP host that will be requested during health checking.\nDefault: HTTPRoute or GRPCRoute hostname.";
            type = (types.nullOr types.str);
          };
          "method" = mkOption {
            description = "Method defines the HTTP method used for health checking.\nDefaults to GET";
            type = (types.nullOr types.str);
          };
          "path" = mkOption {
            description = "Path defines the HTTP path that will be requested during health checking.";
            type = types.str;
          };
        };

        config = {
          "expectedResponse" = mkOverride 1002 null;
          "expectedStatuses" = mkOverride 1002 null;
          "hostname" = mkOverride 1002 null;
          "method" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcp" =
      {

        options = {
          "receive" = mkOption {
            description = "Receive defines the expected response payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive"
              )
            );
          };
          "send" = mkOption {
            description = "Send defines the request payload.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend"
              )
            );
          };
        };

        config = {
          "receive" = mkOverride 1002 null;
          "send" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend" =
      {

        options = {
          "binary" = mkOption {
            description = "Binary payload base64 encoded.";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "Text payload in plain text.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type defines the type of the payload.";
            type = types.str;
          };
        };

        config = {
          "binary" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive" = {

      options = {
        "baseEjectionTime" = mkOption {
          description = "BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.";
          type = (types.nullOr types.str);
        };
        "consecutive5XxErrors" = mkOption {
          description = "Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.";
          type = (types.nullOr types.int);
        };
        "consecutiveGatewayErrors" = mkOption {
          description = "ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.";
          type = (types.nullOr types.int);
        };
        "consecutiveLocalOriginFailures" = mkOption {
          description = "ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.\nParameter takes effect only when split_external_local_origin_errors is set to true.";
          type = (types.nullOr types.int);
        };
        "failurePercentageThreshold" = mkOption {
          description = "FailurePercentageThreshold sets the failure percentage threshold for outlier detection.\nIf the failure percentage of a given host is greater than or equal to this value, it will be ejected.\nDefaults to 85.";
          type = (types.nullOr types.int);
        };
        "interval" = mkOption {
          description = "Interval defines the time between passive health checks.";
          type = (types.nullOr types.str);
        };
        "maxEjectionPercent" = mkOption {
          description = "MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.";
          type = (types.nullOr types.int);
        };
        "splitExternalLocalOriginErrors" = mkOption {
          description = "SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "baseEjectionTime" = mkOverride 1002 null;
        "consecutive5XxErrors" = mkOverride 1002 null;
        "consecutiveGatewayErrors" = mkOverride 1002 null;
        "consecutiveLocalOriginFailures" = mkOverride 1002 null;
        "failurePercentageThreshold" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "maxEjectionPercent" = mkOverride 1002 null;
        "splitExternalLocalOriginErrors" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHttp2" = {

      options = {
        "initialConnectionWindowSize" = mkOption {
          description = "InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.\nIf not set, the default value is 1 MiB.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "initialStreamWindowSize" = mkOption {
          description = "InitialStreamWindowSize sets the initial window size for HTTP/2 streams.\nIf not set, the default value is 64 KiB(64*1024).";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxConcurrentStreams" = mkOption {
          description = "MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.\nIf not set, the default value is 100.";
          type = (types.nullOr types.int);
        };
        "onInvalidMessage" = mkOption {
          description = "OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error\nIt's recommended for L2 Envoy deployments to set this value to TerminateStream.\nhttps://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two\nDefault: TerminateConnection";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "initialConnectionWindowSize" = mkOverride 1002 null;
        "initialStreamWindowSize" = mkOverride 1002 null;
        "maxConcurrentStreams" = mkOverride 1002 null;
        "onInvalidMessage" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer" = {

      options = {
        "consistentHash" = mkOption {
          description = "ConsistentHash defines the configuration when the load balancer type is\nset to ConsistentHash";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash"
            )
          );
        };
        "endpointOverride" = mkOption {
          description = "EndpointOverride defines the configuration for endpoint override.\nWhen specified, the load balancer will attempt to route requests to endpoints\nbased on the override information extracted from request headers or metadata.\n If the override endpoints are not available, the configured load balancer policy will be used as fallback.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverride"
            )
          );
        };
        "slowStart" = mkOption {
          description = "SlowStart defines the configuration related to the slow start load balancer policy.\nIf set, during slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently this is only supported for RoundRobin and LeastRequest load balancers";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStart"
            )
          );
        };
        "type" = mkOption {
          description = "Type decides the type of Load Balancer policy.\nValid LoadBalancerType values are\n\"ConsistentHash\",\n\"LeastRequest\",\n\"Random\",\n\"RoundRobin\".";
          type = types.str;
        };
        "zoneAware" = mkOption {
          description = "ZoneAware defines the configuration related to the distribution of requests between locality zones.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAware"
            )
          );
        };
      };

      config = {
        "consistentHash" = mkOverride 1002 null;
        "endpointOverride" = mkOverride 1002 null;
        "slowStart" = mkOverride 1002 null;
        "zoneAware" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash" =
      {

        options = {
          "cookie" = mkOption {
            description = "Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie"
              )
            );
          };
          "header" = mkOption {
            description = "Header configures the header hash policy when the consistent hash type is set to Header.\n\nDeprecated: use Headers instead";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeader"
              )
            );
          };
          "headers" = mkOption {
            description = "Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeaders"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "queryParams" = mkOption {
            description = "QueryParams configures the query parameter hash policy when the consistent hash type is set to QueryParams.";
            type = (
              types.nullOr (
                coerceAttrsOfSubmodulesToListByKey
                  "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashQueryParams"
                  "name"
                  [ ]
              )
            );
            apply = attrsToList;
          };
          "tableSize" = mkOption {
            description = "The table size for consistent hashing, must be prime number limited to 5000011.";
            type = (types.nullOr types.int);
          };
          "type" = mkOption {
            description = "ConsistentHashType defines the type of input to hash on. Valid Type values are\n\"SourceIP\",\n\"Header\",\n\"Headers\",\n\"Cookie\".\n\"QueryParams\".";
            type = types.str;
          };
        };

        config = {
          "cookie" = mkOverride 1002 null;
          "header" = mkOverride 1002 null;
          "headers" = mkOverride 1002 null;
          "queryParams" = mkOverride 1002 null;
          "tableSize" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie" =
      {

        options = {
          "attributes" = mkOption {
            description = "Additional Attributes to set for the generated cookie.";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "name" = mkOption {
            description = "Name of the cookie to hash.\nIf this cookie does not exist in the request, Envoy will generate a cookie and set\nthe TTL on the response back to the client based on Layer 4\nattributes of the backend endpoint, to ensure that these future requests\ngo to the same backend endpoint. Make sure to set the TTL field for this case.";
            type = types.str;
          };
          "ttl" = mkOption {
            description = "TTL of the generated cookie if the cookie is not present. This value sets the\nMax-Age attribute value.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "attributes" = mkOverride 1002 null;
          "ttl" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeader" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeaders" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the header to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashQueryParams" =
      {

        options = {
          "name" = mkOption {
            description = "Name of the query param to hash.";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverride" =
      {

        options = {
          "extractFrom" = mkOption {
            description = "ExtractFrom defines the sources to extract endpoint override information from.";
            type = (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom"
              )
            );
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom" =
      {

        options = {
          "header" = mkOption {
            description = "Header defines the header to get the override endpoint addresses.\nThe header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.\nFor example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.\nThe IPv6 address is enclosed in square brackets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "header" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStart" =
      {

        options = {
          "window" = mkOption {
            description = "Window defines the duration of the warm up period for newly added host.\nDuring slow start window, traffic sent to the newly added hosts will gradually increase.\nCurrently only supports linear growth of traffic. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig";
            type = types.str;
          };
        };

        config = { };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAware" =
      {

        options = {
          "preferLocal" = mkOption {
            description = "PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal"
              )
            );
          };
        };

        config = {
          "preferLocal" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal" =
      {

        options = {
          "force" = mkOption {
            description = "ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior\nwhich maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.";
            type = (
              types.nullOr (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce"
              )
            );
          };
          "minEndpointsThreshold" = mkOption {
            description = "MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.";
            type = (types.nullOr types.int);
          };
          "percentageEnabled" = mkOption {
            description = "Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "force" = mkOverride 1002 null;
          "minEndpointsThreshold" = mkOverride 1002 null;
          "percentageEnabled" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce" =
      {

        options = {
          "minEndpointsInZoneThreshold" = mkOption {
            description = "MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone\noverride. This is useful for protecting zones with fewer endpoints.";
            type = (types.nullOr types.int);
          };
        };

        config = {
          "minEndpointsInZoneThreshold" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsProxyProtocol" = {

      options = {
        "version" = mkOption {
          description = "Version of ProxyProtol\nValid ProxyProtocolVersion values are\n\"V1\"\n\"V2\"";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetry" = {

      options = {
        "numAttemptsPerPriority" = mkOption {
          description = "NumAttemptsPerPriority defines the number of requests (initial attempt + retries)\nthat should be sent to the same priority before switching to a different one.\nIf not specified or set to 0, all requests are sent to the highest priority that is healthy.";
          type = (types.nullOr types.int);
        };
        "numRetries" = mkOption {
          description = "NumRetries is the number of retries to be attempted. Defaults to 2.";
          type = (types.nullOr types.int);
        };
        "perRetry" = mkOption {
          description = "PerRetry is the retry policy to be applied per retry attempt.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetry"
            )
          );
        };
        "retryOn" = mkOption {
          description = "RetryOn specifies the retry trigger condition.\n\nIf not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOn"
            )
          );
        };
      };

      config = {
        "numAttemptsPerPriority" = mkOverride 1002 null;
        "numRetries" = mkOverride 1002 null;
        "perRetry" = mkOverride 1002 null;
        "retryOn" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetry" = {

      options = {
        "backOff" = mkOption {
          description = "Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential\nback-off algorithm for retries. For additional details,\nsee https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOff"
            )
          );
        };
        "timeout" = mkOption {
          description = "Timeout is the timeout per retry attempt.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "backOff" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOff" =
      {

        options = {
          "baseInterval" = mkOption {
            description = "BaseInterval is the base interval between retries.";
            type = (types.nullOr types.str);
          };
          "maxInterval" = mkOption {
            description = "MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.\nThe default is 10 times the base_interval";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "baseInterval" = mkOverride 1002 null;
          "maxInterval" = mkOverride 1002 null;
        };

      };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOn" = {

      options = {
        "httpStatusCodes" = mkOption {
          description = "HttpStatusCodes specifies the http status codes to be retried.\nThe retriable-status-codes trigger must also be configured for these status codes to trigger a retry.";
          type = (types.nullOr (types.listOf types.int));
        };
        "triggers" = mkOption {
          description = "Triggers specifies the retry trigger condition(Http/Grpc).";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "httpStatusCodes" = mkOverride 1002 null;
        "triggers" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive" = {

      options = {
        "idleTime" = mkOption {
          description = "The duration a connection needs to be idle before keep-alive\nprobes start being sent.\nThe duration format is\nDefaults to `7200s`.";
          type = (types.nullOr types.str);
        };
        "interval" = mkOption {
          description = "The duration between keep-alive probes.\nDefaults to `75s`.";
          type = (types.nullOr types.str);
        };
        "probes" = mkOption {
          description = "The total number of unacknowledged probes to send before deciding\nthe connection is dead.\nDefaults to 9.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "idleTime" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "probes" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTimeout" = {

      options = {
        "http" = mkOption {
          description = "Timeout settings for HTTP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp"
            )
          );
        };
        "tcp" = mkOption {
          description = "Timeout settings for TCP.";
          type = (
            types.nullOr (
              submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcp"
            )
          );
        };
      };

      config = {
        "http" = mkOverride 1002 null;
        "tcp" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp" = {

      options = {
        "connectionIdleTimeout" = mkOption {
          description = "The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.\nDefault: 1 hour.";
          type = (types.nullOr types.str);
        };
        "maxConnectionDuration" = mkOption {
          description = "The maximum duration of an HTTP connection.\nDefault: unlimited.";
          type = (types.nullOr types.str);
        };
        "maxStreamDuration" = mkOption {
          description = "MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time\nfrom when the request is sent until the response stream is fully consumed and does not apply to\nnon-streaming requests.\nWhen set to \"0s\", no max duration is applied and streams can run indefinitely.";
          type = (types.nullOr types.str);
        };
        "requestTimeout" = mkOption {
          description = "RequestTimeout is the time until which entire response is received from the upstream.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "connectionIdleTimeout" = mkOverride 1002 null;
        "maxConnectionDuration" = mkOverride 1002 null;
        "maxStreamDuration" = mkOverride 1002 null;
        "requestTimeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcp" = {

      options = {
        "connectTimeout" = mkOption {
          description = "The timeout for network connection establishment, including TCP and TLS handshakes.\nDefault: 10 seconds.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "connectTimeout" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecTargetRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the target resource.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the target resource.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the target resource.";
          type = types.str;
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. When\nunspecified, this targetRef targets the entire resource. In the following\nresources, SectionName is interpreted as the following:\n\n* Gateway: Listener name\n* HTTPRoute: HTTPRouteRule name\n* Service: Port name\n\nIf a SectionName is specified, but does not exist on the targeted object,\nthe Policy must fail to attach, and the policy implementation should record\na `ResolvedRefs` or similar Condition in the Policy's status.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecTargetRefs" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the target resource.";
          type = types.str;
        };
        "kind" = mkOption {
          description = "Kind is kind of the target resource.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of the target resource.";
          type = types.str;
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. When\nunspecified, this targetRef targets the entire resource. In the following\nresources, SectionName is interpreted as the following:\n\n* Gateway: Listener name\n* HTTPRoute: HTTPRouteRule name\n* Service: Port name\n\nIf a SectionName is specified, but does not exist on the targeted object,\nthe Policy must fail to attach, and the policy implementation should record\na `ResolvedRefs` or similar Condition in the Policy's status.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecTargetSelectors" = {

      options = {
        "group" = mkOption {
          description = "Group is the group that this selector targets. Defaults to gateway.networking.k8s.io";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the resource kind that this selector targets.";
          type = types.str;
        };
        "matchExpressions" = mkOption {
          description = "MatchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecTargetSelectorsMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "MatchLabels are the set of label selectors for identifying the targeted resource";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicySpecTargetSelectorsMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicyStatus" = {

      options = {
        "ancestors" = mkOption {
          description = "Ancestors is a list of ancestor resources (usually Gateways) that are\nassociated with the policy, and the status of the policy with respect to\neach ancestor. When this policy attaches to a parent, the controller that\nmanages the parent and the ancestors MUST add an entry to this list when\nthe controller first sees the policy and SHOULD update the entry as\nappropriate when the relevant ancestor is modified.\n\nNote that choosing the relevant ancestor is left to the Policy designers;\nan important part of Policy design is designing the right object level at\nwhich to namespace this status.\n\nNote also that implementations MUST ONLY populate ancestor status for\nthe Ancestor resources they are responsible for. Implementations MUST\nuse the ControllerName field to uniquely identify the entries in this list\nthat they are responsible for.\n\nNote that to achieve this, the list of PolicyAncestorStatus structs\nMUST be treated as a map with a composite key, made up of the AncestorRef\nand ControllerName fields combined.\n\nA maximum of 16 ancestors will be represented in this list. An empty list\nmeans the Policy is not relevant for any ancestors.\n\nIf this slice is full, implementations MUST NOT add further entries.\nInstead they MUST consider the policy unimplementable and signal that\non any related resources such as the ancestor that would be referenced\nhere. For example, if this list was full on BackendTLSPolicy, no\nadditional Gateways would be able to reference the Service targeted by\nthe BackendTLSPolicy.";
          type = (types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicyStatusAncestors"));
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicyStatusAncestors" = {

      options = {
        "ancestorRef" = mkOption {
          description = "AncestorRef corresponds with a ParentRef in the spec that this\nPolicyAncestorStatus struct describes the status of.";
          type = (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicyStatusAncestorsAncestorRef");
        };
        "conditions" = mkOption {
          description = "Conditions describes the status of the Policy with respect to the given Ancestor.\n\n<gateway:util:excludeFromCRD>\n\nNotes for implementors:\n\nConditions are a listType `map`, which means that they function like a\nmap with a key of the `type` field _in the k8s apiserver_.\n\nThis means that implementations must obey some rules when updating this\nsection.\n\n* Implementations MUST perform a read-modify-write cycle on this field\n  before modifying it. That is, when modifying this field, implementations\n  must be confident they have fetched the most recent version of this field,\n  and ensure that changes they make are on that recent version.\n* Implementations MUST NOT remove or reorder Conditions that they are not\n  directly responsible for. For example, if an implementation sees a Condition\n  with type `special.io/SomeField`, it MUST NOT remove, change or update that\n  Condition.\n* Implementations MUST always _merge_ changes into Conditions of the same Type,\n  rather than creating more than one Condition of the same Type.\n* Implementations MUST always update the `observedGeneration` field of the\n  Condition to the `metadata.generation` of the Gateway at the time of update creation.\n* If the `observedGeneration` of a Condition is _greater than_ the value the\n  implementation knows about, then it MUST NOT perform the update on that Condition,\n  but must wait for a future reconciliation and status update. (The assumption is that\n  the implementation's copy of the object is stale and an update will be re-triggered\n  if relevant.)\n\n</gateway:util:excludeFromCRD>";
          type = (
            types.listOf (submoduleOf "gateway.envoyproxy.io.v1alpha1.SecurityPolicyStatusAncestorsConditions")
          );
        };
        "controllerName" = mkOption {
          description = "ControllerName is a domain/path string that indicates the name of the\ncontroller that wrote this status. This corresponds with the\ncontrollerName field on GatewayClass.\n\nExample: \"example.net/gateway-controller\".\n\nThe format of this field is DOMAIN \"/\" PATH, where DOMAIN and PATH are\nvalid Kubernetes names\n(https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\n\nControllers MUST populate this field when writing status. Controllers should ensure that\nentries to status populated with their ControllerName are cleaned up when they are no\nlonger necessary.";
          type = types.str;
        };
      };

      config = { };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicyStatusAncestorsAncestorRef" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent.\nWhen unspecified, \"gateway.networking.k8s.io\" is inferred.\nTo set the core API group (such as for a \"Service\" kind referent),\nGroup must be explicitly set to \"\" (empty string).\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent.\n\nThere are two kinds of parent resources with \"Core\" support:\n\n* Gateway (Gateway conformance profile)\n* Service (Mesh conformance profile, ClusterIP Services only)\n\nSupport for other resources is Implementation-Specific.";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.\n\nSupport: Core";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referent. When unspecified, this refers\nto the local namespace of the Route.\n\nNote that there are specific rules for ParentRefs which cross namespace\nboundaries. Cross-namespace references are only valid if they are explicitly\nallowed by something in the namespace they are referring to. For example:\nGateway has the AllowedRoutes field, and ReferenceGrant provides a\ngeneric way to enable any other kind of cross-namespace reference.\n\n<gateway:experimental:description>\nParentRefs from a Route to a Service in the same namespace are \"producer\"\nroutes, which apply default routing rules to inbound connections from\nany namespace to the Service.\n\nParentRefs from a Route to a Service in a different namespace are\n\"consumer\" routes, and these routing rules are only applied to outbound\nconnections originating from the same namespace as the Route, for which\nthe intended destination of the connections are a Service targeted as a\nParentRef of the Route.\n</gateway:experimental:description>\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port is the network port this Route targets. It can be interpreted\ndifferently based on the type of parent resource.\n\nWhen the parent resource is a Gateway, this targets all listeners\nlistening on the specified port that also support this kind of Route(and\nselect this Route). It's not recommended to set `Port` unless the\nnetworking behaviors specified in a Route must apply to a specific port\nas opposed to a listener(s) whose port(s) may be changed. When both Port\nand SectionName are specified, the name and port of the selected listener\nmust match both specified values.\n\n<gateway:experimental:description>\nWhen the parent resource is a Service, this targets a specific port in the\nService spec. When both Port (experimental) and SectionName are specified,\nthe name and port of the selected port must match both specified values.\n</gateway:experimental:description>\n\nImplementations MAY choose to support other parent resources.\nImplementations supporting other types of parent resources MUST clearly\ndocument how/if Port is interpreted.\n\nFor the purpose of status, an attachment is considered successful as\nlong as the parent resource accepts it partially. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment\nfrom the referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route,\nthe Route MUST be considered detached from the Gateway.\n\nSupport: Extended";
          type = (types.nullOr types.int);
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. In the\nfollowing resources, SectionName is interpreted as the following:\n\n* Gateway: Listener name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n* Service: Port name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n\nImplementations MAY choose to support attaching Routes to other resources.\nIf that is the case, they MUST clearly document how SectionName is\ninterpreted.\n\nWhen unspecified (empty string), this will reference the entire resource.\nFor the purpose of status, an attachment is considered successful if at\nleast one section in the parent resource accepts it. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment from\nthe referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route, the\nRoute MUST be considered detached from the Gateway.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "sectionName" = mkOverride 1002 null;
      };

    };
    "gateway.envoyproxy.io.v1alpha1.SecurityPolicyStatusAncestorsConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = types.str;
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "type of condition in CamelCase or in foo.example.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "observedGeneration" = mkOverride 1002 null;
      };

    };

  };
in
{
  # all resource versions
  options = {
    resources = {
      "gateway.envoyproxy.io"."v1alpha1"."Backend" = mkOption {
        description = "Backend allows the user to configure the endpoints of a backend and\nthe behavior of the connection from Envoy Proxy to the backend.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.Backend" "backends" "Backend"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "gateway.envoyproxy.io"."v1alpha1"."BackendTrafficPolicy" = mkOption {
        description = "BackendTrafficPolicy allows the user to configure the behavior of the connection\nbetween the Envoy Proxy listener and the backend service.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicy"
              "backendtrafficpolicies"
              "BackendTrafficPolicy"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "gateway.envoyproxy.io"."v1alpha1"."ClientTrafficPolicy" = mkOption {
        description = "ClientTrafficPolicy allows the user to configure the behavior of the connection\nbetween the downstream client and Envoy Proxy listener.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicy" "clienttrafficpolicies"
              "ClientTrafficPolicy"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "gateway.envoyproxy.io"."v1alpha1"."EnvoyExtensionPolicy" = mkOption {
        description = "EnvoyExtensionPolicy allows the user to configure various envoy extensibility options for the Gateway.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicy"
              "envoyextensionpolicies"
              "EnvoyExtensionPolicy"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "gateway.envoyproxy.io"."v1alpha1"."EnvoyPatchPolicy" = mkOption {
        description = "EnvoyPatchPolicy allows the user to modify the generated Envoy xDS\nresources by Envoy Gateway using this patch API";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicy" "envoypatchpolicies"
              "EnvoyPatchPolicy"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "gateway.envoyproxy.io"."v1alpha1"."EnvoyProxy" = mkOption {
        description = "EnvoyProxy is the schema for the envoyproxies API.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.EnvoyProxy" "envoyproxies" "EnvoyProxy"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "gateway.envoyproxy.io"."v1alpha1"."HTTPRouteFilter" = mkOption {
        description = "HTTPRouteFilter is a custom Envoy Gateway HTTPRouteFilter which provides extended\ntraffic processing options such as path regex rewrite, direct response and more.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilter" "httproutefilters"
              "HTTPRouteFilter"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "gateway.envoyproxy.io"."v1alpha1"."SecurityPolicy" = mkOption {
        description = "SecurityPolicy allows the user to configure various security settings for a\nGateway.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.SecurityPolicy" "securitypolicies"
              "SecurityPolicy"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };

    }
    // {
      "backends" = mkOption {
        description = "Backend allows the user to configure the endpoints of a backend and\nthe behavior of the connection from Envoy Proxy to the backend.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.Backend" "backends" "Backend"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "backendTrafficPolicies" = mkOption {
        description = "BackendTrafficPolicy allows the user to configure the behavior of the connection\nbetween the Envoy Proxy listener and the backend service.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.BackendTrafficPolicy"
              "backendtrafficpolicies"
              "BackendTrafficPolicy"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "clientTrafficPolicies" = mkOption {
        description = "ClientTrafficPolicy allows the user to configure the behavior of the connection\nbetween the downstream client and Envoy Proxy listener.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.ClientTrafficPolicy" "clienttrafficpolicies"
              "ClientTrafficPolicy"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "envoyExtensionPolicies" = mkOption {
        description = "EnvoyExtensionPolicy allows the user to configure various envoy extensibility options for the Gateway.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.EnvoyExtensionPolicy"
              "envoyextensionpolicies"
              "EnvoyExtensionPolicy"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "envoyPatchPolicies" = mkOption {
        description = "EnvoyPatchPolicy allows the user to modify the generated Envoy xDS\nresources by Envoy Gateway using this patch API";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.EnvoyPatchPolicy" "envoypatchpolicies"
              "EnvoyPatchPolicy"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "envoyProxies" = mkOption {
        description = "EnvoyProxy is the schema for the envoyproxies API.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.EnvoyProxy" "envoyproxies" "EnvoyProxy"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "httpRouteFilters" = mkOption {
        description = "HTTPRouteFilter is a custom Envoy Gateway HTTPRouteFilter which provides extended\ntraffic processing options such as path regex rewrite, direct response and more.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.HTTPRouteFilter" "httproutefilters"
              "HTTPRouteFilter"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };
      "securityPolicies" = mkOption {
        description = "SecurityPolicy allows the user to configure various security settings for a\nGateway.";
        type = (
          types.attrsOf (
            submoduleForDefinition "gateway.envoyproxy.io.v1alpha1.SecurityPolicy" "securitypolicies"
              "SecurityPolicy"
              "gateway.envoyproxy.io"
              "v1alpha1"
          )
        );
        default = { };
      };

    };
  };

  config = {
    # expose resource definitions
    inherit definitions;

    # register resource types
    types = [
      {
        name = "backends";
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "Backend";
        attrName = "backends";
      }
      {
        name = "backendtrafficpolicies";
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "BackendTrafficPolicy";
        attrName = "backendTrafficPolicies";
      }
      {
        name = "clienttrafficpolicies";
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "ClientTrafficPolicy";
        attrName = "clientTrafficPolicies";
      }
      {
        name = "envoyextensionpolicies";
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "EnvoyExtensionPolicy";
        attrName = "envoyExtensionPolicies";
      }
      {
        name = "envoypatchpolicies";
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "EnvoyPatchPolicy";
        attrName = "envoyPatchPolicies";
      }
      {
        name = "envoyproxies";
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "EnvoyProxy";
        attrName = "envoyProxies";
      }
      {
        name = "httproutefilters";
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "HTTPRouteFilter";
        attrName = "httpRouteFilters";
      }
      {
        name = "securitypolicies";
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "SecurityPolicy";
        attrName = "securityPolicies";
      }
    ];

    resources = {
      "gateway.envoyproxy.io"."v1alpha1"."Backend" = mkAliasDefinitions options.resources."backends";
      "gateway.envoyproxy.io"."v1alpha1"."BackendTrafficPolicy" =
        mkAliasDefinitions
          options.resources."backendTrafficPolicies";
      "gateway.envoyproxy.io"."v1alpha1"."ClientTrafficPolicy" =
        mkAliasDefinitions
          options.resources."clientTrafficPolicies";
      "gateway.envoyproxy.io"."v1alpha1"."EnvoyExtensionPolicy" =
        mkAliasDefinitions
          options.resources."envoyExtensionPolicies";
      "gateway.envoyproxy.io"."v1alpha1"."EnvoyPatchPolicy" =
        mkAliasDefinitions
          options.resources."envoyPatchPolicies";
      "gateway.envoyproxy.io"."v1alpha1"."EnvoyProxy" =
        mkAliasDefinitions
          options.resources."envoyProxies";
      "gateway.envoyproxy.io"."v1alpha1"."HTTPRouteFilter" =
        mkAliasDefinitions
          options.resources."httpRouteFilters";
      "gateway.envoyproxy.io"."v1alpha1"."SecurityPolicy" =
        mkAliasDefinitions
          options.resources."securityPolicies";

    };

    # make all namespaced resources default to the
    # application's namespace
    defaults = [
      {
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "Backend";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "BackendTrafficPolicy";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "ClientTrafficPolicy";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "EnvoyExtensionPolicy";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "EnvoyPatchPolicy";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "EnvoyProxy";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "HTTPRouteFilter";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "gateway.envoyproxy.io";
        version = "v1alpha1";
        kind = "SecurityPolicy";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
    ];
  };
}
